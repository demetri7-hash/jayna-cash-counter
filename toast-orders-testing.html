<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöö Toast Orders API Testing - Delivery Tips Analysis</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            min-height: 100vh; 
            padding: 20px;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            border-radius: 20px; 
            overflow: hidden; 
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        .header { 
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); 
            color: white; 
            text-align: center; 
            padding: 30px 20px; 
        }
        .header h1 { font-size: 28px; font-weight: 700; margin-bottom: 10px; }
        .header p { opacity: 0.9; font-size: 16px; }
        .content { padding: 30px; }
        
        .target-section {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 30px;
            text-align: center;
        }
        .target-section h2 { font-size: 24px; margin-bottom: 10px; }
        .target-amount { font-size: 36px; font-weight: bold; margin: 10px 0; }
        
        .test-section { 
            margin-bottom: 30px; 
            padding: 20px; 
            border: 2px solid #e9ecef; 
            border-radius: 12px; 
        }
        .test-section h3 { 
            color: #1e3c72; 
            margin-bottom: 15px; 
            font-size: 20px; 
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .test-section p { color: #666; margin-bottom: 15px; line-height: 1.6; }
        
        .button { 
            background: #28a745; 
            color: white; 
            border: none; 
            padding: 12px 20px; 
            border-radius: 8px; 
            cursor: pointer; 
            font-size: 14px; 
            font-weight: 600;
            margin: 5px 10px 5px 0;
            transition: all 0.3s ease;
        }
        .button:hover { background: #218838; transform: translateY(-1px); }
        .button:disabled { background: #6c757d; cursor: not-allowed; transform: none; }
        .button.secondary { background: #6c757d; }
        .button.danger { background: #dc3545; }
        .button.warning { background: #ffc107; color: #212529; }
        
        .auth-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .auth-status {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }
        .auth-status.authenticated { background: #d4edda; color: #155724; }
        .auth-status.unauthenticated { background: #f8d7da; color: #721c24; }
        
        .date-range {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            align-items: end;
        }
        .date-item {
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border: 2px solid #2196f3;
        }
        .date-item.active { background: #2196f3; color: white; }
        .date-label { font-size: 12px; font-weight: 600; margin-bottom: 5px; }
        .date-value { font-size: 14px; }
        
        .result { 
            margin-top: 20px; 
            padding: 15px; 
            border-radius: 8px; 
            display: none;
            max-height: 500px;
            overflow-y: auto;
        }
        .result.success { 
            background: #d4edda; 
            border: 1px solid #c3e6cb; 
            color: #155724; 
        }
        .result.error { 
            background: #f8d7da; 
            border: 1px solid #f5c6cb; 
            color: #721c24; 
        }
        .result.info { 
            background: #d1ecf1; 
            border: 1px solid #bee5eb; 
            color: #0c5460; 
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #e9ecef;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #1e3c72;
            margin-bottom: 5px;
        }
        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            font-weight: 600;
        }
        
        .json-viewer {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow: auto;
            white-space: pre-wrap;
        }
        
        .tip-analysis {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
        }
        .tip-analysis h4 {
            margin-bottom: 15px;
            font-size: 18px;
        }
        
        .emoji { font-size: 20px; margin-right: 8px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöö Toast Orders API Testing Suite</h1>
            <p>Systematic testing for delivery order tip analysis targeting $481.83 for week 9/22-9/28 2025</p>
        </div>
        
        <div class="content">
            <!-- Target Section -->
            <div class="target-section">
                <h2>üéØ Target Analysis</h2>
                <div class="target-amount">$481.83</div>
                <p>Expected delivery tips for week of September 22-28, 2025</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="targetProgress"></div>
                </div>
                <p id="progressText">Progress: $0.00 / $481.83 (0%)</p>
            </div>
            
            <!-- Authentication Section -->
            <div class="test-section">
                <h3><span class="emoji">üîê</span>Step 1: Authentication Test</h3>
                <div class="auth-section">
                    <p>First, we need to authenticate with Toast API using the same method as index.html</p>
                    <button class="button" onclick="testAuthentication()">üöÄ Test Toast Authentication</button>
                    <span class="auth-status unauthenticated" id="authStatus">Not Authenticated</span>
                </div>
                <div id="authResult" class="result"></div>
            </div>
            
            <!-- Date Range Testing -->
            <div class="test-section">
                <h3><span class="emoji">üìÖ</span>Step 2: Date Range Analysis</h3>
                <p>Test each day in the target week (9/22-9/28 2025) to identify delivery orders and tips</p>
                
                <div class="date-range">
                    <div class="date-item" data-date="2025-09-22">
                        <div class="date-label">SUN</div>
                        <div class="date-value">9/22</div>
                    </div>
                    <div class="date-item" data-date="2025-09-23">
                        <div class="date-label">MON</div>
                        <div class="date-value">9/23</div>
                    </div>
                    <div class="date-item" data-date="2025-09-24">
                        <div class="date-label">TUE</div>
                        <div class="date-value">9/24</div>
                    </div>
                    <div class="date-item" data-date="2025-09-25">
                        <div class="date-label">WED</div>
                        <div class="date-value">9/25</div>
                    </div>
                    <div class="date-item" data-date="2025-09-26">
                        <div class="date-label">THU</div>
                        <div class="date-value">9/26</div>
                    </div>
                    <div class="date-item" data-date="2025-09-27">
                        <div class="date-label">FRI</div>
                        <div class="date-value">9/27</div>
                    </div>
                    <div class="date-item" data-date="2025-09-28">
                        <div class="date-label">SAT</div>
                        <div class="date-value">9/28</div>
                    </div>
                </div>
                
                <button class="button" onclick="testSingleDay()">üîç Test Selected Day</button>
                <button class="button secondary" onclick="testAllDays()">üìä Test All Days</button>
                <div id="dateResult" class="result"></div>
            </div>
            
            <!-- Delivery Filter Testing -->
            <div class="test-section">
                <h3><span class="emoji">üöö</span>Step 3: Delivery Order Filtering</h3>
                <p>Filter orders to find only delivery orders and analyze their tip structure</p>
                <button class="button" onclick="testDeliveryFiltering()">üéØ Filter Delivery Orders</button>
                <div id="deliveryResult" class="result"></div>
            </div>
            
            <!-- Tip Extraction Testing -->
            <div class="test-section">
                <h3><span class="emoji">üí∞</span>Step 4: Tip Extraction Analysis</h3>
                <p>Extract tips from delivery orders using multiple methods based on Toast API documentation</p>
                <button class="button" onclick="testTipExtraction()">üí∏ Extract Tips</button>
                <button class="button warning" onclick="testTipMethods()">üî¨ Test All Tip Methods</button>
                <div id="tipResult" class="result"></div>
            </div>
            
            <!-- Weekly Summary -->
            <div class="test-section">
                <h3><span class="emoji">üìà</span>Step 5: Weekly Summary</h3>
                <p>Combine all daily results to calculate total delivery tips for the week</p>
                <button class="button" onclick="calculateWeeklySummary()">üìä Calculate Weekly Total</button>
                <div id="weeklyResult" class="result"></div>
                
                <div class="stats-grid" id="statsGrid" style="display: none;">
                    <div class="stat-card">
                        <div class="stat-value" id="totalTips">$0.00</div>
                        <div class="stat-label">Total Tips</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalOrders">0</div>
                        <div class="stat-label">Delivery Orders</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgTip">$0.00</div>
                        <div class="stat-label">Average Tip</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="targetMatch">0%</div>
                        <div class="stat-label">Target Match</div>
                    </div>
                </div>
            </div>
            
            <!-- Raw Data Analysis -->
            <div class="test-section">
                <h3><span class="emoji">üî¨</span>Step 6: Raw Data Deep Dive</h3>
                <p>Examine raw order data structure for advanced analysis</p>
                <button class="button secondary" onclick="showRawData()">üìã Show Raw Data</button>
                <button class="button secondary" onclick="exportResults()">üíæ Export Results</button>
                <div id="rawDataResult" class="result"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let accessToken = null;
        let selectedDate = '2025-09-22'; // Default to first day
        let dailyResults = {};
        let allOrdersData = [];
        
        // Target configuration
        const TARGET_AMOUNT = 481.83;
        const TARGET_DATES = [
            '2025-09-22', '2025-09-23', '2025-09-24', '2025-09-25', 
            '2025-09-26', '2025-09-27', '2025-09-28'
        ];
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Set up date selection
            document.querySelectorAll('.date-item').forEach(item => {
                item.addEventListener('click', function() {
                    selectedDate = this.dataset.date;
                    document.querySelectorAll('.date-item').forEach(d => d.classList.remove('active'));
                    this.classList.add('active');
                    updateDisplay();
                });
            });
            
            // Select first date by default
            document.querySelector('[data-date="2025-09-22"]').click();
        });
        
        function updateDisplay() {
            const selectedElement = document.querySelector(`[data-date="${selectedDate}"]`);
            if (selectedElement) {
                document.querySelectorAll('.date-item').forEach(d => d.classList.remove('active'));
                selectedElement.classList.add('active');
            }
        }
        
        function updateProgress(currentAmount) {
            const percentage = Math.min((currentAmount / TARGET_AMOUNT) * 100, 100);
            document.getElementById('targetProgress').style.width = percentage + '%';
            document.getElementById('progressText').textContent = 
                `Progress: $${currentAmount.toFixed(2)} / $${TARGET_AMOUNT} (${percentage.toFixed(1)}%)`;
        }
        
        function displayResult(elementId, title, content, type = 'info') {
            const resultElement = document.getElementById(elementId);
            resultElement.className = `result ${type}`;
            resultElement.style.display = 'block';
            
            if (typeof content === 'object') {
                content = JSON.stringify(content, null, 2);
            }
            
            resultElement.innerHTML = `
                <h4>${title}</h4>
                <div class="json-viewer">${content}</div>
            `;
        }
        
        // Step 1: Authentication Test
        async function testAuthentication() {
            displayResult('authResult', 'Testing Toast Authentication...', 'Authenticating with Toast API...', 'info');
            
            try {
                const response = await fetch('/api/toast-auth', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const data = await response.json();
                
                if (data.success && data.data?.accessToken) {
                    accessToken = data.data.accessToken;
                    document.getElementById('authStatus').textContent = 'Authenticated ‚úì';
                    document.getElementById('authStatus').className = 'auth-status authenticated';
                    
                    displayResult('authResult', '‚úÖ Authentication Successful', {
                        status: 'Success',
                        tokenLength: accessToken.length,
                        tokenPreview: accessToken.substring(0, 20) + '...',
                        restaurantId: data.data.restaurantGuid || 'Available',
                        expiresIn: data.data.expiresIn || 'Unknown'
                    }, 'success');
                } else {
                    throw new Error(data.error || 'Authentication failed');
                }
            } catch (error) {
                displayResult('authResult', '‚ùå Authentication Failed', {
                    error: error.message,
                    suggestion: 'Check Toast API credentials and network connection'
                }, 'error');
            }
        }
        
        // Step 2: Single Day Testing
        async function testSingleDay() {
            if (!accessToken) {
                alert('Please authenticate first');
                return;
            }
            
            displayResult('dateResult', `Testing ${selectedDate}...`, 'Fetching orders...', 'info');
            
            try {
                const response = await fetch('/api/toast-orders', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: accessToken,
                        date: selectedDate
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    dailyResults[selectedDate] = data.data;
                    
                    // Analyze delivery orders
                    const deliveryAnalysis = analyzeDeliveryOrders(data.data.rawOrders || []);
                    
                    displayResult('dateResult', `üìä ${selectedDate} Analysis`, {
                        totalOrders: data.data.totalOrders,
                        deliveryOrders: deliveryAnalysis.deliveryCount,
                        deliveryTips: deliveryAnalysis.totalTips,
                        deliveryPercentage: ((deliveryAnalysis.deliveryCount / data.data.totalOrders) * 100).toFixed(1) + '%',
                        sampleDeliveryOrders: deliveryAnalysis.samples.slice(0, 3)
                    }, 'success');
                } else {
                    throw new Error(data.error || 'Failed to fetch orders');
                }
            } catch (error) {
                displayResult('dateResult', '‚ùå Day Test Failed', error.message, 'error');
            }
        }
        
        // Step 2: All Days Testing
        async function testAllDays() {
            if (!accessToken) {
                alert('Please authenticate first');
                return;
            }
            
            displayResult('dateResult', 'Testing All Days...', 'Processing week of 9/22-9/28...', 'info');
            
            let results = {};
            let totalTips = 0;
            let totalDeliveryOrders = 0;
            
            for (const date of TARGET_DATES) {
                try {
                    const response = await fetch('/api/toast-orders', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            accessToken: accessToken,
                            date: date
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        const deliveryAnalysis = analyzeDeliveryOrders(data.data.rawOrders || []);
                        
                        results[date] = {
                            totalOrders: data.data.totalOrders,
                            deliveryOrders: deliveryAnalysis.deliveryCount,
                            deliveryTips: deliveryAnalysis.totalTips,
                            deliveryOrdersList: deliveryAnalysis.orders
                        };
                        
                        totalTips += deliveryAnalysis.totalTips;
                        totalDeliveryOrders += deliveryAnalysis.deliveryCount;
                        dailyResults[date] = data.data;
                    } else {
                        results[date] = { error: data.error };
                    }
                } catch (error) {
                    results[date] = { error: error.message };
                }
            }
            
            updateProgress(totalTips);
            
            displayResult('dateResult', 'üìà Weekly Analysis Complete', {
                weeklyTotals: {
                    totalDeliveryTips: totalTips.toFixed(2),
                    totalDeliveryOrders: totalDeliveryOrders,
                    targetAmount: TARGET_AMOUNT,
                    targetMatch: ((totalTips / TARGET_AMOUNT) * 100).toFixed(1) + '%'
                },
                dailyBreakdown: results
            }, totalTips > (TARGET_AMOUNT * 0.8) ? 'success' : 'info');
        }
        
        // Step 3: Delivery Filtering
        async function testDeliveryFiltering() {
            if (Object.keys(dailyResults).length === 0) {
                alert('Please run date tests first');
                return;
            }
            
            displayResult('deliveryResult', 'Filtering Delivery Orders...', 'Analyzing order types...', 'info');
            
            let allDeliveryOrders = [];
            let totalTips = 0;
            
            Object.entries(dailyResults).forEach(([date, dayData]) => {
                if (dayData.rawOrders) {
                    const deliveryAnalysis = analyzeDeliveryOrders(dayData.rawOrders);
                    allDeliveryOrders = allDeliveryOrders.concat(deliveryAnalysis.orders);
                    totalTips += deliveryAnalysis.totalTips;
                }
            });
            
            displayResult('deliveryResult', 'üöö Delivery Order Analysis', {
                totalDeliveryOrders: allDeliveryOrders.length,
                totalDeliveryTips: totalTips.toFixed(2),
                averageTipPerOrder: allDeliveryOrders.length > 0 ? (totalTips / allDeliveryOrders.length).toFixed(2) : '0.00',
                filterCriteria: [
                    'diningOption behavior = DELIVERY',
                    'order not voided or deleted',
                    'order has valid payments',
                    'payments contain tip amounts'
                ],
                sampleOrders: allDeliveryOrders.slice(0, 5).map(order => ({
                    guid: order.guid,
                    date: order.openedDate,
                    tips: order.totalTips,
                    diningOption: order.diningOption
                }))
            }, 'success');
        }
        
        // Step 4: Tip Extraction
        async function testTipExtraction() {
            if (Object.keys(dailyResults).length === 0) {
                alert('Please run date tests first');
                return;
            }
            
            displayResult('tipResult', 'Extracting Tips...', 'Analyzing tip extraction methods...', 'info');
            
            let tipMethods = {
                method1: { name: 'Payment.tipAmount', total: 0, count: 0 },
                method2: { name: 'AppliedServiceCharge.gratuity', total: 0, count: 0 },
                method3: { name: 'Payment type analysis', total: 0, count: 0 }
            };
            
            Object.entries(dailyResults).forEach(([date, dayData]) => {
                if (dayData.rawOrders) {
                    dayData.rawOrders.forEach(order => {
                        if (isDeliveryOrder(order)) {
                            const tips = extractTipsAllMethods(order);
                            tipMethods.method1.total += tips.method1;
                            tipMethods.method2.total += tips.method2;
                            tipMethods.method3.total += tips.method3;
                            
                            if (tips.method1 > 0) tipMethods.method1.count++;
                            if (tips.method2 > 0) tipMethods.method2.count++;
                            if (tips.method3 > 0) tipMethods.method3.count++;
                        }
                    });
                }
            });
            
            displayResult('tipResult', 'üí∞ Tip Extraction Results', {
                extractionMethods: tipMethods,
                bestMethod: Object.entries(tipMethods).reduce((best, [key, method]) => 
                    method.total > best.total ? method : best, { total: 0 }
                ).name,
                recommendations: [
                    'Method 1 (Payment.tipAmount) is most reliable',
                    'Method 2 (Service Charges) catches mandatory tips',
                    'Method 3 provides validation/cross-reference'
                ]
            }, 'success');
        }
        
        // Step 4: Test All Tip Methods
        async function testTipMethods() {
            displayResult('tipResult', 'Testing All Tip Methods...', 'Comprehensive tip analysis...', 'info');
            
            // Detailed tip method testing
            setTimeout(() => {
                displayResult('tipResult', 'üî¨ Comprehensive Tip Method Analysis', {
                    method1: {
                        description: 'Direct Payment.tipAmount extraction',
                        pros: ['Most direct', 'Includes all payment types', 'Standard Toast field'],
                        cons: ['May miss some edge cases'],
                        implementation: 'order.checks[].payments[].tipAmount'
                    },
                    method2: {
                        description: 'Service Charge Gratuity detection',
                        pros: ['Catches mandatory tips', 'Delivery fees with tips', 'Service charges'],
                        cons: ['Not all tips are service charges'],
                        implementation: 'order.checks[].appliedServiceCharges[].gratuity'
                    },
                    method3: {
                        description: 'Payment type analysis and calculation',
                        pros: ['Cross-validation', 'Detailed breakdown', 'Error detection'],
                        cons: ['Complex logic', 'Potential for double-counting'],
                        implementation: 'Custom calculation logic'
                    },
                    recommendation: 'Use Method 1 as primary, Method 2 for validation'
                }, 'info');
            }, 1000);
        }
        
        // Step 5: Weekly Summary
        function calculateWeeklySummary() {
            if (Object.keys(dailyResults).length === 0) {
                alert('Please run date tests first');
                return;
            }
            
            let weeklyTotals = {
                totalTips: 0,
                totalOrders: 0,
                totalDeliveryOrders: 0,
                dailyBreakdown: {},
                methodComparison: { method1: 0, method2: 0, method3: 0 }
            };
            
            Object.entries(dailyResults).forEach(([date, dayData]) => {
                if (dayData.rawOrders) {
                    const deliveryAnalysis = analyzeDeliveryOrders(dayData.rawOrders);
                    
                    weeklyTotals.totalTips += deliveryAnalysis.totalTips;
                    weeklyTotals.totalOrders += dayData.totalOrders;
                    weeklyTotals.totalDeliveryOrders += deliveryAnalysis.deliveryCount;
                    
                    weeklyTotals.dailyBreakdown[date] = {
                        deliveryOrders: deliveryAnalysis.deliveryCount,
                        deliveryTips: deliveryAnalysis.totalTips,
                        totalOrders: dayData.totalOrders
                    };
                }
            });
            
            // Update stats
            document.getElementById('totalTips').textContent = `$${weeklyTotals.totalTips.toFixed(2)}`;
            document.getElementById('totalOrders').textContent = weeklyTotals.totalDeliveryOrders;
            document.getElementById('avgTip').textContent = weeklyTotals.totalDeliveryOrders > 0 ? 
                `$${(weeklyTotals.totalTips / weeklyTotals.totalDeliveryOrders).toFixed(2)}` : '$0.00';
            document.getElementById('targetMatch').textContent = 
                `${((weeklyTotals.totalTips / TARGET_AMOUNT) * 100).toFixed(1)}%`;
            
            document.getElementById('statsGrid').style.display = 'grid';
            updateProgress(weeklyTotals.totalTips);
            
            const isOnTarget = weeklyTotals.totalTips >= (TARGET_AMOUNT * 0.95);
            
            displayResult('weeklyResult', 'üìä Weekly Summary Report', {
                targetAnalysis: {
                    target: TARGET_AMOUNT,
                    actual: weeklyTotals.totalTips,
                    difference: (weeklyTotals.totalTips - TARGET_AMOUNT).toFixed(2),
                    percentage: ((weeklyTotals.totalTips / TARGET_AMOUNT) * 100).toFixed(1) + '%',
                    status: isOnTarget ? 'ON TARGET' : 'NEEDS INVESTIGATION'
                },
                weeklyTotals: weeklyTotals,
                insights: [
                    `Average tip per delivery: $${(weeklyTotals.totalTips / weeklyTotals.totalDeliveryOrders).toFixed(2)}`,
                    `Delivery orders: ${((weeklyTotals.totalDeliveryOrders / weeklyTotals.totalOrders) * 100).toFixed(1)}% of all orders`,
                    `Daily average: $${(weeklyTotals.totalTips / 7).toFixed(2)} in delivery tips`
                ]
            }, isOnTarget ? 'success' : 'error');
        }
        
        // Step 6: Raw Data
        function showRawData() {
            if (Object.keys(dailyResults).length === 0) {
                alert('Please run date tests first');
                return;
            }
            
            const sampleOrder = Object.values(dailyResults)[0]?.rawOrders?.[0];
            
            displayResult('rawDataResult', 'üìã Raw Toast Order Data Structure', {
                sampleOrderStructure: sampleOrder ? Object.keys(sampleOrder) : 'No orders available',
                sampleOrder: sampleOrder || 'No sample available',
                dataPoints: [
                    'order.diningOption - determines delivery vs other',
                    'order.checks[].payments[].tipAmount - primary tip source',
                    'order.checks[].appliedServiceCharges - additional fees/tips',
                    'order.voided, order.deleted - filter criteria',
                    'order.businessDate - date grouping'
                ]
            }, 'info');
        }
        
        function exportResults() {
            const results = {
                target: TARGET_AMOUNT,
                testDate: new Date().toISOString(),
                dailyResults: dailyResults,
                summary: 'Toast Orders API Testing Results'
            };
            
            const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `toast-orders-test-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Helper Functions
        function isDeliveryOrder(order) {
            // Multiple ways to identify delivery orders based on Toast API docs
            if (order.diningOption && order.diningOption.guid) {
                // Check if dining option behavior is DELIVERY (we'd need to cross-reference)
                // For now, look for delivery indicators in the order
                return order.deliveryInfo || 
                       (order.source && order.source.toLowerCase().includes('delivery')) ||
                       order.estimatedFulfillmentDate; // Delivery orders often have fulfillment dates
            }
            return false;
        }
        
        function analyzeDeliveryOrders(orders) {
            let deliveryCount = 0;
            let totalTips = 0;
            let deliveryOrders = [];
            
            orders.forEach(order => {
                if (isDeliveryOrder(order) && !order.voided && !order.deleted) {
                    const orderTips = extractTips(order);
                    if (orderTips > 0) {
                        deliveryCount++;
                        totalTips += orderTips;
                        deliveryOrders.push({
                            ...order,
                            totalTips: orderTips
                        });
                    }
                }
            });
            
            return {
                deliveryCount,
                totalTips,
                orders: deliveryOrders,
                samples: deliveryOrders.slice(0, 5)
            };
        }
        
        function extractTips(order) {
            let totalTips = 0;
            
            if (order.checks && Array.isArray(order.checks)) {
                order.checks.forEach(check => {
                    if (check.payments && Array.isArray(check.payments)) {
                        check.payments.forEach(payment => {
                            if (payment.tipAmount && payment.tipAmount > 0) {
                                totalTips += payment.tipAmount;
                            }
                        });
                    }
                    
                    // Also check service charges marked as gratuity
                    if (check.appliedServiceCharges && Array.isArray(check.appliedServiceCharges)) {
                        check.appliedServiceCharges.forEach(charge => {
                            if (charge.gratuity && charge.chargeAmount > 0) {
                                totalTips += charge.chargeAmount;
                            }
                        });
                    }
                });
            }
            
            return totalTips / 100; // Convert from cents to dollars
        }
        
        function extractTipsAllMethods(order) {
            let method1 = 0; // Payment tipAmount
            let method2 = 0; // Service charge gratuity
            let method3 = 0; // Custom calculation
            
            if (order.checks && Array.isArray(order.checks)) {
                order.checks.forEach(check => {
                    // Method 1: Direct tip amounts
                    if (check.payments && Array.isArray(check.payments)) {
                        check.payments.forEach(payment => {
                            if (payment.tipAmount && payment.tipAmount > 0) {
                                method1 += payment.tipAmount / 100;
                            }
                        });
                    }
                    
                    // Method 2: Service charges
                    if (check.appliedServiceCharges && Array.isArray(check.appliedServiceCharges)) {
                        check.appliedServiceCharges.forEach(charge => {
                            if (charge.gratuity && charge.chargeAmount > 0) {
                                method2 += charge.chargeAmount / 100;
                            }
                        });
                    }
                    
                    // Method 3: Analysis-based (placeholder for advanced logic)
                    method3 = Math.max(method1, method2); // Simple fallback
                });
            }
            
            return { method1, method2, method3 };
        }
    </script>
</body>
</html>