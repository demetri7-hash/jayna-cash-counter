{
  "metadata": {
    "title": "Toast POS API Ecosystem - Complete Documentation",
    "version": "3.0.0",
    "lastUpdated": "2025-10-07",
    "description": "Exhaustive reference guide for the Toast Point-of-Sale (POS) platform API ecosystem including all endpoints, complete schemas, data models, webhooks, and integration patterns",
    "author": "Generated for Claude Code",
    "scope": "All Toast APIs including Orders, Menus, Labor, Configuration, Payments, Stock, Partners, Restaurants, Analytics, and integration specifications"
  },
  "overview": {
    "platform": "Toast POS",
    "provider": "Toast, Inc. (NYSE: TOST)",
    "description": "Cloud-based, all-in-one digital technology platform purpose-built for the restaurant community",
    "architecture": "RESTful API with JSON data format",
    "primaryUse": "Restaurant operations including POS, payments, orders, menus, labor management, inventory, and analytics",
    "targetAudience": ["Integration partners", "Restaurant chains", "Third-party developers", "Internal development teams"],
    "websites": {
      "main": "https://pos.toasttab.com",
      "developer": "https://dev.toasttab.com",
      "documentation": "https://doc.toasttab.com",
      "apiReference": "https://toastintegrations.redoc.ly",
      "analytics": "https://toastprereleaseperformance.redoc.ly",
      "statusPage": "https://status.toasttab.com",
      "community": "Toast Integrations Community Forum"
    }
  },
  "environments": {
    "production": {
      "description": "Live environment with real restaurant data",
      "baseUrl": "https://[toast-api-hostname]",
      "purpose": "Production operations with actual restaurant locations",
      "dataImpact": "All operations affect real restaurant data"
    },
    "sandbox": {
      "description": "Testing environment with sample data",
      "baseUrl": "https://[sandbox-toast-api-hostname]",
      "purpose": "Development, testing, integration certification, and training",
      "dataImpact": "Operations use test data only",
      "features": ["Test mode orders", "Sample restaurants", "Development credentials"]
    }
  },
  "authentication": {
    "protocol": "OAuth 2.0",
    "grantType": "Client Credentials",
    "tokenType": "Bearer (JWT)",
    "endpoint": "/authentication/v1/authentication/login",
    "method": "POST",
    "tokenLifetime": "Typically 24 hours (86400 seconds), but check expires_in value",
    "refreshStrategy": {
      "recommended": "Request new token in last 60 seconds before expiration",
      "implementation": "Monitor expires_in value and implement token refresh logic",
      "reusePolicy": "Reuse tokens for at least 30 minutes"
    },
    "rateLimits": {
      "maxTokensPerHour": 2,
      "maxTokensPerDay": "1-2 tokens recommended",
      "bestPractice": "Implement token caching and reuse strategy"
    },
    "requestFormat": {
      "method": "POST",
      "headers": {
        "Content-Type": "application/json"
      },
      "body": {
        "clientId": "Your client identifier from Toast",
        "clientSecret": "Your client secret - NEVER share via email",
        "userAccessType": "TOAST_MACHINE_CLIENT"
      },
      "example": {
        "clientId": "example-client-id",
        "clientSecret": "example-secret-keep-confidential",
        "userAccessType": "TOAST_MACHINE_CLIENT"
      }
    },
    "responseFormat": {
      "success": {
        "status": 200,
        "body": {
          "access_token": "JWT string",
          "token_type": "Bearer",
          "expires_in": 3599,
          "scope": "Array of granted scopes"
        }
      },
      "error": {
        "status": 401,
        "body": {
          "error": "invalid_client",
          "error_description": "Client authentication failed"
        }
      }
    },
    "usage": {
      "headerName": "Authorization",
      "headerFormat": "Bearer {access_token}",
      "example": "Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
      "requiredForAllAPIs": true
    },
    "tokenDecoding": {
      "format": "JWT (JSON Web Token)",
      "contains": ["Scopes", "Expiration time", "Client ID", "Restaurant GUIDs (for mgmt groups)"],
      "verification": "Use JWT decoding libraries to inspect token contents"
    },
    "security": {
      "clientSecret": {
        "confidentiality": "CRITICAL - Never expose in code, logs, or emails",
        "storage": "Use environment variables or secure secret management",
        "rotation": "Contact Toast support for secret rotation"
      },
      "tokenSecurity": {
        "transmission": "Always use HTTPS",
        "storage": "Securely store tokens in memory or encrypted storage",
        "exposure": "Never log complete tokens"
      }
    }
  },
  "accountTypes": {
    "partnerApiAccount": {
      "description": "For integration partners serving multiple independent restaurants",
      "accessPattern": "Multi-restaurant across different management groups",
      "useCase": "Third-party service providers, SaaS platforms, integration partners",
      "authentication": "Single token valid across all connected restaurants",
      "restaurantAccess": "Restaurants opt-in via Toast Partner Integrations marketplace",
      "identification": "Use Toast-Restaurant-External-ID header for each API call",
      "discovery": "Use partners API /restaurants endpoint to find connected restaurants",
      "webhooks": "Partners webhook notifies when restaurants add/remove integration"
    },
    "restaurantManagementGroupAccount": {
      "description": "For restaurant chains/groups managing their own locations",
      "accessPattern": "All restaurants within a single management group",
      "useCase": "Restaurant chains, franchise operators, internal development teams",
      "authentication": "Single token valid for all group locations",
      "restaurantAccess": "Automatic access to all locations in management group",
      "identification": "Use Toast-Restaurant-External-ID header for specific locations",
      "discovery": "Use restaurants API /groups endpoint to list all group locations",
      "webhooks": "Standard webhooks (menus, orders, etc.) available"
    },
    "standardApiAccess": {
      "description": "Read-only access for analytics and reporting",
      "accessPattern": "Specific restaurants or entire management group",
      "capabilities": ["Read operations only", "Multiple credential sets", "Configurable restaurant access", "Self-service credential generation"],
      "limitations": ["No write operations", "No order creation", "Read-only data access"],
      "useCase": "Business intelligence, reporting tools, analytics platforms",
      "credentialManagement": "Self-service via Toast Developer Portal"
    },
    "analyticsApiAccess": {
      "description": "Specialized access for performance and analytics data",
      "endpoint": "Separate analytics API endpoint",
      "capabilities": ["Historical data access", "Performance metrics", "Aggregated reporting"],
      "credentialCreation": "Via Toast Developer Portal",
      "documentation": "https://toastprereleaseperformance.redoc.ly"
    }
  },
  "scopes": {
    "description": "OAuth 2.0 scopes control granular access to APIs, endpoints, and operations",
    "format": "Included in JWT token after authentication",
    "assignment": "Scopes assigned by Toast based on integration certification and business requirements",
    "viewing": "Available in Toast Developer Portal > Scopes page",
    "scopeList": {
      "orders:read": {
        "description": "Read order information",
        "access": ["GET /orders", "GET /orders/{guid}", "GET /ordersBulk"],
        "dataAccess": "Order details, checks, selections, payments"
      },
      "orders:write": {
        "description": "Create and modify orders",
        "access": ["POST /orders", "POST /orders/{guid}/void", "PATCH /orders/{guid}"],
        "dataAccess": "Order creation, payment processing, order modifications"
      },
      "menus:read": {
        "description": "Access menu data",
        "access": ["GET /menus", "GET /metadata"],
        "dataAccess": "Menu structure, items, modifiers, pricing, availability"
      },
      "config:read": {
        "description": "Read restaurant configuration",
        "access": ["GET /config/*"],
        "dataAccess": "Payment types, discounts, service charges, revenue centers, dining options"
      },
      "labor:read": {
        "description": "Read employee and labor data",
        "access": ["GET /labor/v1/employees", "GET /labor/v1/jobs", "GET /labor/v1/timeEntries", "GET /labor/v1/shifts"],
        "dataAccess": "Employee info, jobs, shifts, time entries, breaks"
      },
      "labor:write": {
        "description": "Manage employees and labor settings",
        "access": ["POST /labor/v1/employees", "PATCH /labor/v1/employees/{id}", "DELETE /labor/v1/employees/{id}"],
        "dataAccess": "Employee CRUD operations, job assignments, wage management"
      },
      "payments:read": {
        "description": "Access payment information",
        "access": ["GET /orders/{guid}/payments"],
        "dataAccess": "Payment details, transaction info, refunds"
      },
      "payments:write": {
        "description": "Process payments",
        "access": ["POST /orders/{guid}/payments"],
        "dataAccess": "Payment authorization, credit card processing"
      },
      "stock:read": {
        "description": "Read inventory data",
        "access": ["GET /stock/v1/items", "GET /stock/v1/items/{itemGuid}"],
        "dataAccess": "Inventory levels, stock status, availability"
      },
      "stock:write": {
        "description": "Update inventory",
        "access": ["PUT /stock/v1/items", "PATCH /stock/v1/items/{itemGuid}"],
        "dataAccess": "Inventory updates, stock quantity changes, availability status"
      },
      "loyalty:read": {
        "description": "Access loyalty program data",
        "access": ["Loyalty API requests from Toast POS"],
        "dataAccess": "Loyalty accounts, points, rewards"
      },
      "loyalty:write": {
        "description": "Manage loyalty transactions",
        "access": ["Loyalty API transaction processing"],
        "dataAccess": "Points accrual, redemption, account management"
      },
      "restaurants:read": {
        "description": "Access restaurant information",
        "access": ["GET /restaurants/v1/restaurants/{guid}", "GET /config/v2/restaurants"],
        "dataAccess": "Restaurant details, settings, configuration"
      },
      "partners:read": {
        "description": "Partner API access for connected restaurants",
        "access": ["GET /partners/v1/restaurants", "GET /partners/v1/connectedRestaurants"],
        "dataAccess": "List of connected restaurant locations"
      },
      "cashmgmt:read": {
        "description": "Read cash management data",
        "access": ["GET /cashmgmt/v1/entries", "GET /cashmgmt/v1/deposits"],
        "dataAccess": "Cash entries, deposits, drawer operations"
      },
      "kitchen:read": {
        "description": "Read kitchen operations data",
        "access": ["GET /kitchen/v1/orders"],
        "dataAccess": "Kitchen display information, order routing"
      }
    },
    "certificationRequired": {
      "orders:write": "Requires integration certification",
      "payments:write": "Requires PCI compliance and certification",
      "labor:write": "Requires employee management certification",
      "stock:write": "Requires inventory management certification"
    }
  },
  "rateLimiting": {
    "description": "Toast APIs implement rate limiting to ensure platform stability",
    "generalLimits": {
      "authentication": {
        "limit": "2 tokens per hour maximum",
        "recommendation": "Request 1-2 tokens per day",
        "enforcement": "Errors returned if limits exceeded"
      },
      "apiCalls": {
        "strategy": "Throttle requests to avoid rate limit errors",
        "implementation": "Implement exponential backoff for retries",
        "monitoring": "Track API response codes for rate limiting (429)"
      }
    },
    "responseCodes": {
      "429": {
        "description": "Too Many Requests - Rate limit exceeded",
        "action": "Implement backoff and retry logic",
        "headers": ["Retry-After header may indicate wait time"]
      }
    },
    "bestPractices": [
      "Implement request queuing",
      "Use exponential backoff for retries",
      "Cache data when appropriate",
      "Batch operations where possible",
      "Monitor rate limit response codes",
      "Use webhooks instead of polling when available"
    ]
  },
  "httpHeaders": {
    "required": {
      "Authorization": {
        "format": "Bearer {access_token}",
        "required": true,
        "description": "OAuth 2.0 bearer token for authentication"
      },
      "Toast-Restaurant-External-ID": {
        "format": "Restaurant GUID string",
        "required": true,
        "description": "Identifies which restaurant the request applies to",
        "example": "4622e7a9-b4be-3fef-9220-b3dad273e0b4"
      },
      "Content-Type": {
        "format": "application/json",
        "required": "For POST, PUT, PATCH requests",
        "description": "Specifies JSON request body format"
      }
    },
    "optional": {
      "Toast-Transaction-Type": {
        "usage": "Outbound APIs (Gift Cards, Loyalty, Tender)",
        "description": "Indicates transaction type for outbound API requests",
        "values": ["GIFTCARD_ACTIVATE", "GIFTCARD_GET_BALANCE", "LOYALTY_TRANSACTION", etc.]
      },
      "Toast-Alternate-Payment-Type-GUID": {
        "usage": "Tender API",
        "description": "GUID of alternative payment type",
        "addedDate": "2025-07-07"
      }
    },
    "responseHeaders": {
      "Toast-Next-Page-Token": {
        "description": "Token for pagination of large result sets",
        "usage": "Include in subsequent requests as pageToken parameter"
      },
      "Retry-After": {
        "description": "Seconds to wait before retrying after rate limit",
        "responseCode": 429
      }
    }
  },
  "apis": {
    "orders": {
      "version": "2.6.4",
      "baseEndpoint": "/orders/v2",
      "description": "Manage restaurant orders, guest checks, menu selections, and payments",
      "requiredScopes": ["orders:read", "orders:write"],
      "capabilities": [
        "Create new orders from external ordering systems",
        "Retrieve order details and history",
        "Add payments to checks",
        "Void orders and selections",
        "Get accurate pricing before order submission",
        "Apply discounts to items and checks",
        "Update delivery information for delivery orders",
        "Retrieve payment information"
      ],
      "endpoints": {
        "createOrder": {
          "method": "POST",
          "path": "/orders/v2/orders",
          "description": "Submit a new order to Toast platform",
          "scope": "orders:write",
          "requestBody": {
            "type": "Order",
            "required": true,
            "schema": {
              "checks": {
                "type": "array",
                "description": "Array of Check objects",
                "required": true
              },
              "diningOption": {
                "type": "object",
                "description": "Dining option reference (dine-in, takeout, delivery, etc.)",
                "required": true
              },
              "approvalStatus": {
                "type": "string",
                "enum": ["APPROVED", "NEEDS_APPROVAL"],
                "description": "Order approval status"
              },
              "estimatedFulfillmentDate": {
                "type": "string",
                "format": "ISO 8601",
                "description": "Estimated time order will be ready"
              },
              "numberOfGuests": {
                "type": "integer",
                "description": "Number of guests for the order"
              },
              "deliveryInfo": {
                "type": "object",
                "description": "Delivery address and contact info",
                "requiredFor": "delivery orders"
              },
              "curbsidePickupInfo": {
                "type": "object",
                "description": "Vehicle info for curbside pickup",
                "requiredFor": "curbside orders"
              }
            }
          },
          "response": {
            "200": {
              "description": "Order created successfully",
              "schema": {
                "guid": "Order GUID",
                "entityType": "Order",
                "checks": "Array of created checks with GUIDs"
              }
            },
            "400": {
              "description": "Bad request - validation error",
              "reasons": [
                "More than 1,000 top-level selections",
                "Request body exceeds 1 MB",
                "Invalid menu item references",
                "Invalid payment information"
              ]
            }
          },
          "limitations": [
            "Cannot create cash orders",
            "Cannot use Toast gift cards",
            "Orders don't trigger SMS notifications",
            "Max 1,000 top-level selections",
            "Request body max 1 MB"
          ]
        },
        "getOrder": {
          "method": "GET",
          "path": "/orders/v2/orders/{guid}",
          "description": "Retrieve details for a specific order",
          "scope": "orders:read",
          "parameters": {
            "guid": {
              "type": "string",
              "location": "path",
              "required": true,
              "description": "Toast order GUID"
            }
          },
          "response": {
            "200": {
              "description": "Order details retrieved successfully",
              "schema": "Complete Order object with all nested data"
            },
            "404": {
              "description": "Order not found"
            }
          }
        },
        "getOrdersBulk": {
          "method": "GET",
          "path": "/orders/v2/orders",
          "description": "Retrieve multiple orders based on date range or business date",
          "scope": "orders:read",
          "parameters": {
            "startDate": {
              "type": "string",
              "format": "ISO 8601",
              "description": "Start of modified date range (UTC)"
            },
            "endDate": {
              "type": "string",
              "format": "ISO 8601",
              "description": "End of modified date range (UTC)"
            },
            "businessDate": {
              "type": "integer",
              "format": "YYYYMMDD",
              "description": "Specific business date to query"
            },
            "pageSize": {
              "type": "integer",
              "default": 100,
              "max": 500,
              "description": "Number of results per page"
            },
            "page": {
              "type": "integer",
              "description": "Page number for pagination"
            },
            "pageToken": {
              "type": "string",
              "description": "Token from Toast-Next-Page-Token header for next page"
            }
          },
          "response": {
            "200": {
              "description": "Array of orders matching criteria",
              "headers": {
                "Toast-Next-Page-Token": "Token for next page if more results exist"
              }
            }
          },
          "notes": [
            "Can only retrieve orders created after 2015-12-01",
            "Use businessDate for specific day's orders",
            "Use startDate/endDate for modified date range",
            "Implement pagination for large result sets"
          ]
        },
        "getPrices": {
          "method": "POST",
          "path": "/orders/v2/prices",
          "description": "Get accurate pricing for order before submission - CRITICAL for correct charges",
          "scope": "orders:read",
          "importance": "MUST USE - ensures accurate pricing with taxes",
          "requestBody": {
            "description": "Order structure without payment",
            "required": true
          },
          "response": {
            "200": {
              "description": "Pricing breakdown for order",
              "includes": [
                "Item prices with modifiers",
                "Tax calculations",
                "Service charges",
                "Discounts applied",
                "Total amount"
              ]
            }
          },
          "bestPractice": "Always call /prices before submitting order to ensure correct total"
        },
        "voidOrder": {
          "method": "POST",
          "path": "/orders/v2/orders/{guid}/void",
          "description": "Void an entire order",
          "scope": "orders:write",
          "parameters": {
            "guid": {
              "type": "string",
              "location": "path",
              "required": true
            }
          },
          "requestBody": {
            "voidReason": {
              "type": "integer",
              "description": "Void reason code from /voidReasons config endpoint"
            }
          },
          "response": {
            "200": "Order voided successfully",
            "400": "Cannot void order (e.g., already paid)"
          }
        },
        "addPayment": {
          "method": "POST",
          "path": "/orders/v2/orders/{orderGuid}/checks/{checkGuid}/payments",
          "description": "Add payment to a specific check",
          "scope": "orders:write",
          "requestBody": {
            "type": "Payment",
            "schema": {
              "type": {
                "type": "string",
                "enum": ["CREDIT", "CASH", "GIFTCARD", "OTHER"],
                "description": "Payment type"
              },
              "amount": {
                "type": "number",
                "description": "Payment amount in currency"
              },
              "tipAmount": {
                "type": "number",
                "description": "Tip amount"
              },
              "cardType": {
                "type": "string",
                "description": "For credit cards: VISA, MASTERCARD, AMEX, etc."
              },
              "last4Digits": {
                "type": "string",
                "description": "Last 4 digits of card"
              }
            }
          },
          "response": {
            "201": "Payment added successfully"
          }
        },
        "getPayments": {
          "method": "GET",
          "path": "/orders/v2/payments",
          "description": "Retrieve payment information for orders",
          "scope": "orders:read",
          "parameters": {
            "paidBusinessDate": {
              "type": "integer",
              "format": "YYYYMMDD",
              "description": "Business date for paid orders"
            },
            "pageSize": {
              "type": "integer",
              "max": 500
            }
          }
        },
        "updateDelivery": {
          "method": "PATCH",
          "path": "/orders/v2/orders/{guid}/deliveryInfo",
          "description": "Update delivery information for delivery orders",
          "scope": "orders:write",
          "requestBody": {
            "deliveryStatus": {
              "type": "string",
              "enum": ["PENDING", "IN_TRANSIT", "DELIVERED"],
              "description": "Current delivery status"
            },
            "dispatchedDate": {
              "type": "string",
              "format": "ISO 8601",
              "description": "When order was dispatched"
            },
            "deliveredDate": {
              "type": "string",
              "format": "ISO 8601",
              "description": "When order was delivered"
            },
            "deliveryEmployee": {
              "type": "object",
              "description": "Employee assigned to delivery"
            }
          }
        },
        "getDiscounts": {
          "method": "GET",
          "path": "/orders/v2/discounts",
          "description": "Retrieve applicable discounts for orders",
          "scope": "orders:read"
        }
      },
      "dataStructure": {
        "order": {
          "description": "Top-level order container representing entire customer transaction",
          "contains": "One or more checks",
          "keyFields": {
            "guid": "Unique order identifier",
            "entityType": "Always 'Order'",
            "checks": "Array of Check objects",
            "source": "Order source (In Store, Toast Online Ordering, API, etc.)",
            "createdDate": "Order creation timestamp",
            "businessDate": "Business date (YYYYMMDD format)",
            "voidDate": "If voided, timestamp of void",
            "voided": "Boolean indicating if order is voided",
            "approvalStatus": "APPROVED or NEEDS_APPROVAL",
            "diningOption": "Reference to dining option (dine-in, takeout, etc.)",
            "estimatedFulfillmentDate": "When order expected to be ready",
            "numberOfGuests": "Guest count",
            "server": "Server/employee who created order",
            "revenueCenter": "Revenue center reference",
            "deliveryInfo": "Delivery details (if delivery order)",
            "curbsidePickupInfo": "Curbside info (if curbside order)",
            "table": "Table assignment (if dine-in)",
            "duration": "Order duration",
            "excessFood": "Boolean for waste tracking orders",
            "createdInTestMode": "Boolean indicating test mode"
          }
        },
        "check": {
          "description": "Individual bill within order (for split checks)",
          "contains": "Selections (menu items) and payments",
          "keyFields": {
            "guid": "Unique check identifier",
            "entityType": "Always 'Check'",
            "selections": "Array of Selection objects (menu items)",
            "payments": "Array of Payment objects",
            "amount": "Total check amount before tax",
            "taxAmount": "Total tax amount",
            "totalAmount": "Total including tax",
            "appliedDiscounts": "Discounts applied to entire check",
            "appliedServiceCharges": "Service charges on check",
            "voided": "Boolean if check is voided",
            "voidDate": "Void timestamp",
            "tabName": "Name for tab",
            "customer": "Customer information if available"
          }
        },
        "selection": {
          "description": "Individual menu item or modifier in an order",
          "contains": "Item details and nested modifiers",
          "keyFields": {
            "guid": "Unique selection identifier",
            "entityType": "Always 'OrderSelection'",
            "itemId": "Menu item GUID reference",
            "item": "Full MenuItem object",
            "quantity": "Quantity ordered",
            "preDiscountPrice": "Price before discounts",
            "price": "Final price after discounts",
            "tax": "Tax amount for selection",
            "voided": "Boolean if selection is voided",
            "voidReason": "Reason for void",
            "deferred": "Boolean for deferred items (e.g., gift cards)",
            "preModifier": "PreModifier applied",
            "modifiers": "Array of modifier selections",
            "fulfillmentStatus": "READY, SENT_TO_KITCHEN, etc.",
            "selectionType": "NONE, OPEN_ITEM, PORTION_MODIFIER, etc.",
            "salesCategory": "Sales category reference",
            "appliedDiscounts": "Discounts on this selection"
          }
        },
        "payment": {
          "description": "Payment applied to a check",
          "keyFields": {
            "guid": "Unique payment identifier",
            "entityType": "Always 'Payment'",
            "type": "CREDIT, CASH, GIFTCARD, OTHER",
            "amount": "Payment amount",
            "tipAmount": "Tip amount",
            "amountTendered": "Amount given by customer",
            "cardType": "VISA, MASTERCARD, AMEX, DISCOVER, etc.",
            "last4Digits": "Last 4 digits of card",
            "cardEntryMode": "SWIPED, KEYED, CONTACTLESS, etc.",
            "voided": "Boolean if payment is voided",
            "voidDate": "Void timestamp",
            "voidReason": "Reason for void",
            "refund": "Boolean if this is a refund",
            "refundStatus": "Refund processing status",
            "paidDate": "Payment timestamp",
            "otherPayment": "Details for OTHER payment types"
          }
        }
      },
      "orderTypes": {
        "dineIn": {
          "diningOption": "DINE_IN",
          "requiredFields": ["table", "numberOfGuests"],
          "optionalFields": ["server", "revenueCenter"]
        },
        "takeout": {
          "diningOption": "TAKEOUT",
          "requiredFields": ["estimatedFulfillmentDate"],
          "optionalFields": ["customer contact info"]
        },
        "delivery": {
          "diningOption": "DELIVERY",
          "requiredFields": ["deliveryInfo", "estimatedFulfillmentDate"],
          "deliveryInfo": {
            "address": "Complete delivery address",
            "notes": "Delivery instructions",
            "phone": "Contact phone number"
          }
        },
        "curbside": {
          "diningOption": "TAKEOUT",
          "requiredFields": ["curbsidePickupInfo", "estimatedFulfillmentDate"],
          "curbsidePickupInfo": {
            "transportColor": "Vehicle color",
            "transportDescription": "Vehicle make/model"
          }
        }
      },
      "limitations": [
        "Cannot create cash orders via API",
        "Cannot use Toast gift cards in API orders",
        "Toast loyalty not available for API orders (use third-party loyalty)",
        "Orders don't trigger SMS text messages to guests/servers",
        "Maximum 1,000 top-level selections per order",
        "Request body size must be under 1 MB",
        "Only orders created after 2015-12-01 can be retrieved",
        "Tax exempt setting ignored for OTHER payment types"
      ],
      "bestPractices": [
        "Always call /prices endpoint before submitting order",
        "Group identical items to avoid selection limits",
        "Check fulfillmentStatus before sending guest notifications",
        "Handle voided entities appropriately in reporting",
        "Implement pagination for bulk order retrieval",
        "Use webhooks for real-time order updates",
        "Store order GUIDs for future reference",
        "Implement proper error handling for order creation",
        "Validate menu item references before submission",
        "Respect dining option requirements"
      ]
    },
    "menus": {
      "versions": ["v2", "v3"],
      "currentVersion": "v3",
      "baseEndpoint": "/menus/v2 or /menus/v3",
      "description": "Access restaurant menu data including items, groups, modifiers, pricing strategies, and availability schedules",
      "requiredScopes": ["menus:read"],
      "endpoints": {
        "getMenus": {
          "method": "GET",
          "path": "/menus/v2/menus or /menus/v3/menus",
          "description": "Retrieve complete menu structure for a restaurant",
          "scope": "menus:read",
          "response": {
            "200": {
              "description": "Complete menu data",
              "schema": {
                "menus": "Array of Menu objects",
                "menuGroups": "Array of MenuGroup objects",
                "menuItems": "Array of MenuItem objects",
                "modifierGroups": "Array of ModifierGroup objects",
                "modifierOptions": "Array of ModifierOption objects",
                "premodifierGroups": "Array of PremodifierGroup objects",
                "premodifiers": "Array of Premodifier objects"
              }
            }
          },
          "caching": "Cache menu data and only refresh when metadata indicates changes"
        },
        "getMetadata": {
          "method": "GET",
          "path": "/menus/v2/metadata or /menus/v3/metadata",
          "description": "Check if menu data has changed since last retrieval",
          "scope": "menus:read",
          "pollInterval": "Every 1-5 minutes",
          "response": {
            "200": {
              "schema": {
                "lastModified": "Timestamp of last menu change",
                "menusHash": "Hash value for change detection"
              }
            }
          },
          "usage": "Poll regularly to determine when to refresh menu data"
        }
      },
      "menuHierarchy": {
        "menu": {
          "description": "Top-level menu container (e.g., Lunch Menu, Dinner Menu, Brunch)",
          "contains": "MenuGroups only (not MenuItems directly)",
          "fields": {
            "guid": "Unique menu identifier",
            "name": "Menu display name",
            "menuGroups": "Array of MenuGroup references",
            "availability": "When menu is available (time/day restrictions)",
            "visibility": "PUBLIC or LIMITED"
          },
          "availability": {
            "description": "Time-based availability restrictions",
            "fields": {
              "always": "Boolean - available 24/7",
              "dayGroups": "Array of day/time combinations",
              "startTime": "Time menu becomes available",
              "endTime": "Time menu stops being available"
            }
          }
        },
        "menuGroup": {
          "description": "Category of menu items (e.g., Appetizers, Entrees, Desserts, Beverages)",
          "contains": "MenuItems and/or nested MenuGroups",
          "fields": {
            "guid": "Unique group identifier",
            "name": "Group display name",
            "menuItems": "Array of MenuItem references",
            "subgroups": "Array of nested MenuGroup references",
            "optionGroups": "Modifier groups that can be inherited",
            "inheritOptionGroups": "Boolean - inherit from parent group",
            "visibility": "Display visibility setting"
          },
          "inheritance": "Can inherit modifier groups from parent groups"
        },
        "menuItem": {
          "description": "Individual product, dish, or modifier option",
          "fields": {
            "guid": "Unique item identifier",
            "name": "Item display name",
            "description": "Item description",
            "sku": "Stock keeping unit identifier",
            "plu": "Price look-up code",
            "price": "Base price",
            "pricingRules": "Array of pricing rule references",
            "pricingStrategy": "Pricing strategy type",
            "optionGroups": "Array of ModifierGroup references",
            "isDiscountable": "Boolean - can apply discounts",
            "taxInclusion": "INCLUDED or EXCLUDED",
            "calories": "Calorie information",
            "itemTags": "Array of tags (gluten-free, vegetarian, etc.)",
            "visibility": "Display visibility",
            "unitOfMeasure": "NONE, WEIGHT, EACH",
            "eligiblePaymentAssistancePrograms": "EBT programs (e.g., SNAP)",
            "salesCategory": "Sales category reference"
          },
          "pricingStrategies": {
            "BASE_PRICE": "Standard single price",
            "MENU_SPECIFIC": "Different price per menu",
            "SIZE_PRICE": "Price varies by size selection",
            "TIME_SPECIFIC": "Price changes based on time of day",
            "SEQUENCE": "Used for modifier pricing",
            "SIZE_SEQUENCE": "Combination size and sequence pricing",
            "OPEN_PRICE": "Price entered at POS"
          }
        },
        "modifierGroup": {
          "description": "Group of modifier options (e.g., Toppings, Sides, Cook Temperature)",
          "fields": {
            "guid": "Unique modifier group identifier",
            "name": "Group display name",
            "minSelections": "Minimum required selections",
            "maxSelections": "Maximum allowed selections",
            "optionItems": "Array of MenuItem references (modifier options)",
            "pricingMode": "SIZE_SEQUENCE, SEQUENCE, or NONE",
            "pricingRules": "Pricing rules for modifiers"
          },
          "behaviors": {
            "required": "minSelections > 0",
            "optional": "minSelections = 0",
            "singleSelect": "maxSelections = 1",
            "multiSelect": "maxSelections > 1"
          }
        },
        "premodifier": {
          "description": "Additional modifier information displayed before main modifiers",
          "fields": {
            "guid": "Unique premodifier identifier",
            "name": "Premodifier display name",
            "posName": "Button label in Toast POS"
          }
        }
      },
      "importantConcepts": {
        "publishedDataOnly": "Menus API returns only published menu data - changes require menu publish in Toast",
        "menuInheritance": "MenuItems can inherit option groups from parent MenuGroups",
        "multipleParentage": "MenuItems and MenuGroups can appear in multiple locations",
        "arbitraryDepth": "MenuOptionGroups can contain items that reference more option groups (nested modifiers)",
        "infiniteLoops": "Rare menu configurations can cause infinite loops - implement loop detection",
        "availability": "Menus and items can have time-based availability restrictions"
      },
      "changeDetection": {
        "primaryMethod": "Menus webhook (real-time notifications)",
        "fallbackMethod": "Poll /metadata endpoint every 1-5 minutes",
        "implementation": "Use webhook as primary, /metadata as backup to catch missed webhooks"
      },
      "bestPractices": [
        "Cache menu data and only refresh when changes detected",
        "Use menus webhook for real-time updates",
        "Poll /metadata endpoint as backup (every 30 minutes)",
        "Implement infinite loop detection in menu parsing",
        "Respect menu availability times",
        "Display item tags (gluten-free, vegetarian, etc.)",
        "Support time-specific pricing for competitive advantage",
        "Handle menu-specific pricing properly",
        "Support size pricing and modifier sequence pricing",
        "Validate isDiscountable before allowing discounts"
      ]
    },
    "configuration": {
      "version": "1.0",
      "baseEndpoint": "/config/v2",
      "description": "Access restaurant configuration data including payment types, discounts, service charges, dining options, revenue centers, and more",
      "requiredScopes": ["config:read"],
      "endpoints": {
        "getRestaurants": {
          "method": "GET",
          "path": "/config/v2/restaurants",
          "description": "Get list of all restaurants in management group",
          "scope": "config:read"
        },
        "getRevenueCenters": {
          "method": "GET",
          "path": "/config/v2/revenueCenters",
          "description": "Get revenue centers for restaurant",
          "scope": "config:read",
          "usage": "Map orders to revenue centers (Bar, Restaurant, Catering, etc.)"
        },
        "getDiningOptions": {
          "method": "GET",
          "path": "/config/v2/diningOptions",
          "description": "Get dining options (Dine In, Takeout, Delivery, etc.)",
          "scope": "config:read"
        },
        "getPaymentTypes": {
          "method": "GET",
          "path": "/config/v2/alternatePaymentTypes",
          "description": "Get alternative payment types configured",
          "scope": "config:read",
          "usage": "Map OTHER payments to configured types"
        },
        "getDiscounts": {
          "method": "GET",
          "path": "/config/v2/discounts",
          "description": "Get configured discounts",
          "scope": "config:read"
        },
        "getServiceCharges": {
          "method": "GET",
          "path": "/config/v2/serviceCharges",
          "description": "Get service charges (auto-gratuity, delivery fee, etc.)",
          "scope": "config:read"
        },
        "getVoidReasons": {
          "method": "GET",
          "path": "/config/v2/voidReasons",
          "description": "Get configured void reasons",
          "scope": "config:read",
          "usage": "Map void reason codes to descriptions"
        },
        "getPreModifiers": {
          "method": "GET",
          "path": "/config/v2/preModifiers",
          "description": "Get premodifiers configuration",
          "scope": "config:read"
        },
        "getTaxRates": {
          "method": "GET",
          "path": "/config/v2/taxRates",
          "description": "Get tax rates configuration",
          "scope": "config:read"
        },
        "getSalesCategories": {
          "method": "GET",
          "path": "/config/v2/salesCategories",
          "description": "Get sales categories",
          "scope": "config:read",
          "usage": "Categorize items for reporting"
        },
        "getCashDrawers": {
          "method": "GET",
          "path": "/config/v2/cashDrawers",
          "description": "Get cash drawer configuration",
          "scope": "config:read"
        },
        "getBreakTypes": {
          "method": "GET",
          "path": "/config/v2/breakTypes",
          "description": "Get employee break types",
          "scope": "config:read"
        }
      },
      "dataModels": {
        "revenueCenter": {
          "fields": {
            "guid": "Unique identifier",
            "entityType": "RevenueCenter",
            "name": "Revenue center name"
          },
          "examples": ["Bar", "Restaurant", "Patio", "Catering"]
        },
        "diningOption": {
          "fields": {
            "guid": "Unique identifier",
            "name": "Dining option name",
            "behavior": "DINE_IN, TAKEOUT, DELIVERY"
          }
        },
        "alternatePaymentType": {
          "fields": {
            "guid": "Unique identifier",
            "name": "Payment type name",
            "taxExempt": "Boolean"
          },
          "examples": ["House Account", "Employee Meal", "Comp"]
        },
        "discount": {
          "fields": {
            "guid": "Unique identifier",
            "name": "Discount name",
            "type": "PERCENT or FIXED",
            "amount": "Discount amount or percentage"
          }
        },
        "serviceCharge": {
          "fields": {
            "guid": "Unique identifier",
            "name": "Service charge name",
            "type": "PERCENT or FIXED",
            "amount": "Charge amount or percentage",
            "taxable": "Boolean"
          }
        }
      },
      "bestPractices": [
        "Cache configuration data - changes infrequently",
        "Refresh configuration daily or after webhook notifications",
        "Map GUIDs to names for user-friendly displays",
        "Validate payment types before order submission",
        "Use revenue centers for proper order categorization"
      ]
    },
    "labor": {
      "version": "1.0",
      "baseEndpoint": "/labor/v1",
      "description": "Manage employee data, jobs, schedules, time entries, breaks, and labor reporting",
      "requiredScopes": ["labor:read", "labor:write"],
      "endpoints": {
        "getEmployees": {
          "method": "GET",
          "path": "/labor/v1/employees",
          "description": "Get all employees for restaurant",
          "scope": "labor:read",
          "response": {
            "200": {
              "schema": "Array of Employee objects"
            }
          }
        },
        "getEmployee": {
          "method": "GET",
          "path": "/labor/v1/employees/{employeeId}",
          "description": "Get specific employee details",
          "scope": "labor:read",
          "parameters": {
            "employeeId": {
              "type": "string",
              "location": "path",
              "required": true
            }
          }
        },
        "createEmployee": {
          "method": "POST",
          "path": "/labor/v1/employees",
          "description": "Create new employee",
          "scope": "labor:write",
          "requestBody": {
            "schema": {
              "firstName": {
                "type": "string",
                "required": true
              },
              "lastName": {
                "type": "string",
                "required": true
              },
              "email": {
                "type": "string",
                "required": true,
                "description": "Primary key for uniqueness"
              },
              "chosenName": {
                "type": "string",
                "description": "Preferred name"
              },
              "phone": {
                "type": "string"
              },
              "phoneNumberCountryCode": {
                "type": "string",
                "description": "International country code"
              },
              "passcode": {
                "type": "string",
                "description": "POS login passcode - required for POS access"
              },
              "externalEmployeeId": {
                "type": "string",
                "description": "External system ID for mapping"
              },
              "jobs": {
                "type": "array",
                "description": "Array of JobReference objects with wage overrides"
              }
            }
          },
          "response": {
            "201": {
              "description": "Employee created with assigned GUID"
            },
            "400": {
              "description": "Validation error - duplicate email, invalid job reference, etc."
            }
          }
        },
        "updateEmployee": {
          "method": "PATCH",
          "path": "/labor/v1/employees/{employeeId}",
          "description": "Update existing employee",
          "scope": "labor:write",
          "supportedUpdates": [
            "names (first, last, chosen)",
            "email",
            "phone",
            "jobs",
            "wage overrides",
            "passcode",
            "externalEmployeeId"
          ],
          "restrictions": [
            "Cannot update clocked-in employee (except specific fields)",
            "Email must remain unique",
            "Batch changes to same employee into single request to avoid conflicts"
          ]
        },
        "deleteEmployee": {
          "method": "DELETE",
          "path": "/labor/v1/employees/{employeeId}",
          "description": "Delete employee (cannot undo)",
          "scope": "labor:write",
          "restrictions": [
            "Cannot delete clocked-in employee",
            "Check time entries before deletion"
          ],
          "response": {
            "204": "Employee deleted",
            "400": "Cannot delete - employee is clocked in"
          }
        },
        "archiveEmployee": {
          "method": "POST",
          "path": "/labor/v1/employees/{employeeId}/archive",
          "description": "Archive employee (soft delete)",
          "scope": "labor:write"
        },
        "unarchiveEmployee": {
          "method": "POST",
          "path": "/labor/v1/employees/{employeeId}/unarchive",
          "description": "Reactivate archived employee",
          "scope": "labor:write"
        },
        "getJobs": {
          "method": "GET",
          "path": "/labor/v1/jobs",
          "description": "Get all jobs configured for restaurant",
          "scope": "labor:read",
          "response": {
            "200": {
              "schema": "Array of Job objects with wage info and permissions"
            }
          }
        },
        "getTimeEntries": {
          "method": "GET",
          "path": "/labor/v1/timeEntries",
          "description": "Get employee time entries (clock in/out records)",
          "scope": "labor:read",
          "parameters": {
            "businessDate": {
              "type": "integer",
              "format": "YYYYMMDD",
              "description": "Business date for time entries"
            },
            "startDate": {
              "type": "string",
              "format": "ISO 8601",
              "description": "Start of date range"
            },
            "endDate": {
              "type": "string",
              "format": "ISO 8601",
              "description": "End of date range"
            },
            "employeeGuid": {
              "type": "string",
              "description": "Filter by specific employee"
            }
          },
          "response": {
            "200": {
              "schema": {
                "inDate": "Clock in timestamp",
                "outDate": "Clock out timestamp (null if currently clocked in)",
                "regularHours": "Regular hours worked",
                "overtimeHours": "Overtime hours",
                "hourlyWage": "Wage for this entry",
                "breaks": "Array of break periods",
                "shiftReference": "Reference to scheduled shift if applicable"
              }
            }
          }
        },
        "getShifts": {
          "method": "GET",
          "path": "/labor/v1/shifts",
          "description": "Get employee scheduled shifts",
          "scope": "labor:read",
          "parameters": {
            "startDate": {
              "type": "string",
              "format": "ISO 8601"
            },
            "endDate": {
              "type": "string",
              "format": "ISO 8601"
            },
            "employeeGuid": {
              "type": "string"
            }
          }
        }
      },
      "dataModels": {
        "employee": {
          "description": "Restaurant employee record",
          "fields": {
            "guid": "Unique employee identifier",
            "entityType": "RestaurantUser",
            "firstName": "First name",
            "lastName": "Last name",
            "chosenName": "Preferred name",
            "email": "Email address (primary key)",
            "phone": "Phone number",
            "phoneNumberCountryCode": "Country code for phone",
            "passcode": "POS login code",
            "externalEmployeeId": "External system ID",
            "externalId": "Legacy external ID (deprecated)",
            "disabled": "Deprecated - use archived instead",
            "jobs": "Array of assigned jobs with wage overrides"
          }
        },
        "job": {
          "description": "Employee job/role definition",
          "fields": {
            "guid": "Unique job identifier",
            "title": "Job title",
            "wageType": "HOURLY or SALARY",
            "defaultHourlyWage": "Default hourly rate",
            "permissions": "POS permissions for this job"
          }
        },
        "timeEntry": {
          "description": "Employee clock in/out record",
          "fields": {
            "guid": "Unique time entry identifier",
            "employeeReference": "Employee who clocked in",
            "jobReference": "Job worked during this entry",
            "inDate": "Clock in timestamp (ISO 8601)",
            "outDate": "Clock out timestamp (null if currently clocked in)",
            "regularHours": "Regular hours worked (decimal)",
            "overtimeHours": "Overtime hours worked (decimal)",
            "hourlyWage": "Wage for this entry",
            "breaks": "Array of TimeEntryBreak objects",
            "shiftReference": "Reference to scheduled shift if applicable",
            "businessDate": "Business date (YYYYMMDD)",
            "cashSales": "Deprecated - use orders API",
            "nonCashSales": "Deprecated - use orders API",
            "declaredCashTips": "Deprecated - use orders API",
            "nonCashTips": "Deprecated - use orders API"
          }
        },
        "shift": {
          "description": "Scheduled employee shift",
          "fields": {
            "guid": "Unique shift identifier",
            "employeeReference": "Scheduled employee",
            "jobReference": "Job for this shift",
            "inDate": "Scheduled start time",
            "outDate": "Scheduled end time",
            "breaks": "Scheduled breaks"
          }
        },
        "timeEntryBreak": {
          "fields": {
            "guid": "Break identifier",
            "breakType": "Reference to break type config",
            "isPaid": "Boolean indicating if break is paid",
            "inDate": "Break start time",
            "outDate": "Break end time",
            "missedBreak": "Boolean if employee missed scheduled break"
          }
        }
      },
      "businessDateLogic": {
        "description": "Business date changes at closeout hour (default 4:00 AM)",
        "closeoutHour": "Configured per restaurant - get from restaurants API",
        "businessDateCalculation": "Time entries on same business date span across midnight",
        "daylightSavings": "Consider DST when working with closeout hour"
      },
      "importantNotes": [
        "Email is primary key - must be unique per restaurant",
        "Passcode required for POS device login (not Toast Web)",
        "Cannot delete clocked-in employees",
        "Batch employee updates to avoid conflicts",
        "Use orders API for sales/tips data (not time entry fields)",
        "Regular and overtime hours calculated by Toast platform",
        "Overtime factor not exposed by API",
        "Salaried jobs have null hourlyWage on time entries"
      ],
      "bestPractices": [
        "Use externalEmployeeId to map between systems",
        "Check time entries before deleting employees",
        "Create audit trail for employee changes",
        "Load initial employee data when restaurant connects",
        "Poll for employee updates made in Toast platform",
        "Use orders API for accurate sales and tips data",
        "Consider clock-in enforcement and shift references",
        "Handle breaks properly (paid vs unpaid)",
        "Respect business date for reporting"
      ]
    },
    "payments": {
      "description": "Credit card payment processing and authorization",
      "baseEndpoint": "Included in orders API",
      "capabilities": [
        "Encrypt credit card data",
        "Authorize payments",
        "Submit payments with orders",
        "Process refunds",
        "Handle tips"
      ],
      "creditCardFlow": {
        "step1": {
          "action": "Collect card data from guest",
          "methods": ["Manual entry", "Saved card from vault"]
        },
        "step2": {
          "action": "Encrypt card data",
          "endpoint": "Use Toast encryption library",
          "result": "Encrypted card data string"
        },
        "step3": {
          "action": "Authorize payment",
          "endpoint": "POST to credit cards API",
          "requestBody": {
            "encryptedCardData": "Encrypted string from step 2",
            "amount": "Authorization amount",
            "cardNumberOrigin": "END_USER or PARTNER_VAULT",
            "tipAmount": "Optional tip amount"
          }
        },
        "step4": {
          "action": "Submit payment with order",
          "endpoint": "Include in order creation or add to existing order",
          "paymentObject": {
            "type": "CREDIT",
            "amount": "Payment amount",
            "tipAmount": "Tip amount",
            "cardType": "VISA, MASTERCARD, etc.",
            "last4Digits": "Last 4 digits"
          }
        }
      },
      "cardNumberOrigin": {
        "END_USER": "Guest manually entered card information",
        "PARTNER_VAULT": "Card retrieved from external vaulting service",
        "importance": "Critical for fraud detection optimization"
      },
      "refunds": {
        "toastCreditCardsAPI": "Servers can refund via Toast POS",
        "alternativePayments": "Must refund separately outside Toast",
        "documentation": "Provide refund instructions to restaurant staff"
      },
      "bestPractices": [
        "Always use /prices endpoint before authorization",
        "Include tip amount in authorization and payment",
        "Set correct cardNumberOrigin for fraud detection",
        "Use Toast encryption library for PCI compliance",
        "Handle tokenization for saved cards",
        "Provide clear refund procedures"
      ]
    },
    "stock": {
      "version": "1.0",
      "baseEndpoint": "/stock/v1",
      "description": "Manage restaurant inventory including item quantities, stock status, and availability",
      "requiredScopes": ["stock:read", "stock:write"],
      "endpoints": {
        "getAllStock": {
          "method": "GET",
          "path": "/stock/v1/items",
          "description": "Get all inventory information for restaurant",
          "scope": "stock:read",
          "response": {
            "200": {
              "schema": "Array of StockItem objects with quantity and status"
            }
          }
        },
        "getStockByItems": {
          "method": "GET",
          "path": "/stock/v1/items",
          "description": "Get inventory for specific menu items",
          "scope": "stock:read",
          "parameters": {
            "itemGuids": {
              "type": "array",
              "description": "Array of menu item GUIDs"
            }
          }
        },
        "getStockByStatus": {
          "method": "GET",
          "path": "/stock/v1/items",
          "description": "Get items filtered by stock status",
          "scope": "stock:read",
          "parameters": {
            "stockStatus": {
              "type": "string",
              "enum": ["IN_STOCK", "LOW_STOCK", "OUT_OF_STOCK", "EIGHTY_SIX"],
              "description": "Filter by stock status"
            }
          }
        },
        "getStockItem": {
          "method": "GET",
          "path": "/stock/v1/items/{itemGuid}",
          "description": "Get inventory for specific item",
          "scope": "stock:read",
          "parameters": {
            "itemGuid": {
              "type": "string",
              "location": "path",
              "required": true
            }
          }
        },
        "updateStock": {
          "method": "PUT",
          "path": "/stock/v1/items",
          "description": "Update inventory quantities for multiple items",
          "scope": "stock:write",
          "requestBody": {
            "type": "array",
            "description": "Array of StockItem objects with updated quantities"
          }
        },
        "updateStockItem": {
          "method": "PATCH",
          "path": "/stock/v1/items/{itemGuid}",
          "description": "Update single item inventory",
          "scope": "stock:write",
          "requestBody": {
            "quantity": {
              "type": "number",
              "description": "New quantity"
            },
            "stockStatus": {
              "type": "string",
              "enum": ["IN_STOCK", "LOW_STOCK", "OUT_OF_STOCK", "EIGHTY_SIX"]
            }
          }
        }
      },
      "dataModels": {
        "stockItem": {
          "fields": {
            "itemGuid": "Menu item GUID",
            "quantity": "Current quantity in stock",
            "stockStatus": "IN_STOCK, LOW_STOCK, OUT_OF_STOCK, or EIGHTY_SIX",
            "isTracked": "Boolean - is inventory tracking enabled",
            "lastUpdated": "Timestamp of last update"
          }
        },
        "stockStatus": {
          "IN_STOCK": "Item available normally",
          "LOW_STOCK": "Item quantity below threshold",
          "OUT_OF_STOCK": "Item has zero quantity",
          "EIGHTY_SIX": "Item manually marked as unavailable (86'd)"
        }
      },
      "modifierSupport": {
        "description": "Modifiers supported through underlying menu item references",
        "itemReference": "Modifier's item reference tracked separately",
        "usage": "Track modifier inventory independently from parent items"
      },
      "webhook": {
        "event": "stock_updated",
        "description": "Real-time notifications when stock changes",
        "subscribe": "Via webhooks configuration in developer portal"
      },
      "bestPractices": [
        "Subscribe to stock webhook for real-time updates",
        "Batch stock updates to reduce API calls",
        "Sync stock data regularly (hourly or daily)",
        "Handle EIGHTY_SIX status in ordering systems",
        "Display stock status to customers where appropriate",
        "Implement inventory warnings for low stock",
        "Track modifier option inventory separately"
      ]
    },
    "partners": {
      "version": "1.0",
      "baseEndpoint": "/partners/v1",
      "description": "Access list of restaurants connected to partner integration",
      "requiredScopes": ["partners:read"],
      "accountTypeRequired": "Partner API Account only",
      "endpoints": {
        "getRestaurants": {
          "method": "GET",
          "path": "/partners/v1/restaurants",
          "description": "Get all connected restaurants",
          "scope": "partners:read",
          "response": {
            "200": {
              "schema": "Array of restaurant connection objects"
            }
          }
        },
        "getConnectedRestaurants": {
          "method": "GET",
          "path": "/partners/v1/connectedRestaurants",
          "description": "Get connected restaurants with pagination",
          "scope": "partners:read",
          "parameters": {
            "lastModified": {
              "type": "string",
              "format": "ISO 8601 UTC timestamp",
              "description": "Get restaurants added/modified after this time",
              "example": "2020-03-01T00:00:00.000-0000"
            },
            "page": {
              "type": "integer",
              "description": "Page number for pagination"
            },
            "pageSize": {
              "type": "integer",
              "max": 200,
              "description": "Number of results per page"
            }
          },
          "response": {
            "200": {
              "schema": {
                "restaurants": "Array of restaurant objects",
                "lastPageNum": "Total number of pages"
              }
            }
          }
        }
      },
      "restaurantObject": {
        "fields": {
          "restaurantGuid": "Unique restaurant identifier",
          "locationGuid": "Toast location GUID",
          "managementGroupGuid": "Restaurant group identifier",
          "restaurantName": "Restaurant name",
          "locationName": "Specific location name",
          "externalGroupId": "External group identifier (if configured)",
          "externalId": "External location identifier (if configured)",
          "createdDate": "When connection was created",
          "modifiedDate": "When connection was last modified"
        }
      },
      "pollingStrategy": {
        "frequency": "Poll /connectedRestaurants 3-5 times per day",
        "useLastModified": "Use lastModified parameter to get only new/changed connections",
        "webhook": "Use partners webhook as primary method, API as backup"
      },
      "webhook": {
        "event": "partner_updated",
        "triggers": [
          "Restaurant adds integration",
          "Restaurant removes integration",
          "Restaurant updates external IDs"
        ],
        "recommendation": "Primary method for discovering restaurant connections"
      },
      "bestPractices": [
        "Use partners webhook for real-time connection updates",
        "Poll API a few times daily as backup",
        "Store restaurant GUIDs for API authentication headers",
        "Map external IDs to your internal customer accounts",
        "Stop API calls immediately when restaurant disconnects",
        "Monitor connection status regularly",
        "Handle connection removal gracefully"
      ]
    },
    "restaurants": {
      "version": "1.0",
      "baseEndpoint": "/restaurants/v1",
      "description": "Access restaurant business information, settings, and configuration",
      "requiredScopes": ["restaurants:read"],
      "endpoints": {
        "getRestaurant": {
          "method": "GET",
          "path": "/restaurants/v1/restaurants/{restaurantGuid}",
          "description": "Get detailed information for specific restaurant",
          "scope": "restaurants:read",
          "parameters": {
            "restaurantGuid": {
              "type": "string",
              "location": "path",
              "required": true
            },
            "includeArchived": {
              "type": "boolean",
              "description": "Include archived (inactive) restaurants",
              "default": false,
              "recommendation": "Set to true to check if restaurant archived"
            }
          },
          "response": {
            "200": {
              "description": "Complete restaurant information",
              "schema": {
                "general": "General restaurant info",
                "management": "Management details",
                "location": "Physical location info",
                "schedules": "Operating hours",
                "onlineOrdering": "Online ordering configuration",
                "delivery": "Delivery settings",
                "archived": "Boolean if restaurant is archived"
              }
            },
            "404": {
              "description": "Restaurant not found or archived (retry with includeArchived=true)"
            }
          }
        },
        "getGroups": {
          "method": "GET",
          "path": "/restaurants/v1/groups/{managementGroupGuid}",
          "description": "Get all restaurants in management group",
          "scope": "restaurants:read",
          "parameters": {
            "managementGroupGuid": {
              "type": "string",
              "location": "path",
              "required": true
            }
          },
          "usage": "For restaurant management group accounts"
        }
      },
      "restaurantDataStructure": {
        "general": {
          "fields": {
            "name": "Restaurant name",
            "description": "Restaurant description",
            "timeZone": "IANA timezone identifier",
            "closeoutHour": "Business day closeout hour (default 4:00 AM)",
            "currency": "ISO currency code",
            "managementGroupGuid": "Management group identifier"
          }
        },
        "location": {
          "fields": {
            "address1": "Street address",
            "address2": "Address line 2",
            "city": "City",
            "stateCode": "State/province code",
            "zipCode": "Postal code",
            "country": "Country code",
            "phone": "Phone number",
            "latitude": "Latitude coordinate",
            "longitude": "Longitude coordinate"
          }
        },
        "schedules": {
          "description": "Operating hours by day of week",
          "fields": {
            "monday": "Array of time ranges",
            "tuesday": "Array of time ranges",
            "wednesday": "Array of time ranges",
            "thursday": "Array of time ranges",
            "friday": "Array of time ranges",
            "saturday": "Array of time ranges",
            "sunday": "Array of time ranges"
          }
        },
        "onlineOrdering": {
          "fields": {
            "enabled": "Boolean - online ordering enabled",
            "scheduling": "Boolean - allow scheduled orders",
            "specialRequests": "Boolean - allow special requests",
            "specialRequestsMessage": "Message displayed for special requests",
            "paymentOptions": {
              "delivery": {
                "cash": "Accept cash for delivery",
                "ccSameDay": "CC for same-day delivery",
                "ccFuture": "CC for future orders"
              },
              "takeout": {
                "cash": "Accept cash for takeout",
                "ccSameDay": "CC for same-day takeout",
                "ccFuture": "CC for future orders",
                "ccInStore": "Pay in store"
              },
              "ccTip": "Allow CC tips"
            }
          }
        }
      },
      "closeoutHour": {
        "description": "Time when business date changes (typically 4:00 AM local time)",
        "importance": "Critical for business date calculations",
        "usage": "Affects order businessDate, time entries, and reporting",
        "daylightSavings": "Consider DST when working with closeout hour"
      },
      "bestPractices": [
        "Cache restaurant information - changes infrequently",
        "Use closeoutHour for correct business date calculations",
        "Check archived status if receiving 404 errors",
        "Display restaurant timezone for time-based operations",
        "Respect operating hours for order scheduling",
        "Use location data for delivery radius calculations"
      ]
    },
    "cashManagement": {
      "version": "1.0",
      "baseEndpoint": "/cashmgmt/v1",
      "description": "Access cash drawer operations including entries and deposits",
      "requiredScopes": ["cashmgmt:read"],
      "endpoints": {
        "getCashEntries": {
          "method": "GET",
          "path": "/cashmgmt/v1/entries",
          "description": "Get cash drawer entries (cash in/out operations)",
          "scope": "cashmgmt:read",
          "parameters": {
            "businessDate": {
              "type": "integer",
              "format": "YYYYMMDD",
              "description": "Business date for entries"
            },
            "startDate": {
              "type": "string",
              "format": "ISO 8601",
              "description": "Start of date range"
            },
            "endDate": {
              "type": "string",
              "format": "ISO 8601",
              "description": "End of date range"
            }
          },
          "response": {
            "200": {
              "schema": {
                "guid": "Entry identifier",
                "type": "CASH_IN, CASH_OUT, PAY_IN, PAY_OUT, TIP_WITHHOLDING",
                "amount": "Cash amount",
                "reason": "Reason for entry",
                "employee": "Employee who made entry",
                "createdDate": "Entry timestamp",
                "businessDate": "Business date (YYYYMMDD)"
              }
            }
          }
        },
        "getCashDeposits": {
          "method": "GET",
          "path": "/cashmgmt/v1/deposits",
          "description": "Get cash deposit records",
          "scope": "cashmgmt:read",
          "parameters": {
            "businessDate": {
              "type": "integer",
              "format": "YYYYMMDD"
            }
          }
        }
      },
      "entryTypes": {
        "CASH_IN": "Cash added to drawer (non-transaction)",
        "CASH_OUT": "Cash removed from drawer (non-transaction)",
        "PAY_IN": "Restaurant service payment",
        "PAY_OUT": "Cash paid to employee (e.g., tip payouts)",
        "TIP_WITHHOLDING": "Tips withheld for tax purposes"
      },
      "distinctionFromTransactions": {
        "cashEntries": "Operations that add/remove cash separately from customer transactions",
        "cashTransactions": "Customer payments for checks - tracked in orders API",
        "importance": "Cash entries affect overall drawer balance, not individual order payments"
      },
      "bestPractices": [
        "Use for cash drawer reconciliation",
        "Track non-transaction cash movements",
        "Monitor employee cash handling",
        "Implement cash audit trails",
        "Reconcile with orders API cash payments"
      ]
    },
    "kitchen": {
      "version": "1.0",
      "baseEndpoint": "/kitchen/v1",
      "description": "Access kitchen display system (KDS) orders and routing information",
      "requiredScopes": ["kitchen:read"],
      "endpoints": {
        "getKitchenOrders": {
          "method": "GET",
          "path": "/kitchen/v1/orders",
          "description": "Get orders sent to kitchen displays",
          "scope": "kitchen:read",
          "parameters": {
            "startDate": {
              "type": "string",
              "format": "ISO 8601"
            },
            "endDate": {
              "type": "string",
              "format": "ISO 8601"
            }
          }
        }
      },
      "dataModels": {
        "kitchenOrder": {
          "fields": {
            "guid": "Order identifier",
            "items": "Items sent to this kitchen station",
            "station": "Kitchen station/prep area",
            "sentDate": "When order was sent to kitchen",
            "completedDate": "When order was marked complete",
            "status": "Order status in kitchen"
          }
        }
      },
      "usage": [
        "Kitchen display system integrations",
        "Order preparation tracking",
        "Kitchen performance analytics",
        "Food preparation monitoring"
      ]
    },
    "analytics": {
      "description": "Specialized analytics API for performance metrics and historical data",
      "baseEndpoint": "Separate analytics endpoint",
      "documentation": "https://toastprereleaseperformance.redoc.ly",
      "capabilities": [
        "Historical sales data",
        "Performance metrics",
        "Aggregated reporting",
        "Business intelligence"
      ],
      "access": "Analytics API Access credentials via Developer Portal",
      "dataTypes": [
        "Sales aggregates",
        "Performance trends",
        "Customer analytics",
        "Labor analytics"
      ]
    },
    "orderManagementConfiguration": {
      "baseEndpoint": "/orderManagement/v1",
      "description": "Configuration for online ordering schedules and availability",
      "endpoints": {
        "getOrderingSchedule": {
          "method": "GET",
          "path": "/orderManagement/v1/availability",
          "description": "Get ordering availability schedule",
          "response": {
            "200": {
              "schema": {
                "orderingSchedule": "Schedule defining when orders can be placed",
                "timeZoneId": "Timezone for schedule"
              }
            }
          }
        }
      }
    },
    "restaurantAvailability": {
      "description": "Real-time restaurant availability for online ordering",
      "webhook": {
        "event": "restaurant_availability_updated",
        "description": "Notifications when restaurant opens/closes for online ordering"
      }
    },
    "packagingConfiguration": {
      "description": "Packaging preferences and requirements for menu items",
      "webhook": {
        "event": "packaging_configuration_updated",
        "description": "Notifications when packaging configuration changes"
      }
    }
  },
  "outboundApis": {
    "description": "APIs that Toast calls on partner's servers (partner implements server)",
    "giftCards": {
      "specification": "Gift cards integration specification",
      "description": "Allow Toast POS to process gift card transactions using external provider",
      "implementation": "Partner implements REST API that Toast calls",
      "endpoint": "Single endpoint defined by partner",
      "authentication": "Toast includes authentication token in requests",
      "transactionTypes": {
        "GIFTCARD_GET_BALANCE": {
          "description": "Check gift card balance",
          "header": "Toast-Transaction-Type: GIFTCARD_GET_BALANCE"
        },
        "GIFTCARD_ACTIVATE": {
          "description": "Activate and add value to new card",
          "header": "Toast-Transaction-Type: GIFTCARD_ACTIVATE"
        },
        "GIFTCARD_ADD_VALUE": {
          "description": "Add value to existing card",
          "header": "Toast-Transaction-Type: GIFTCARD_ADD_VALUE"
        },
        "GIFTCARD_REDEEM": {
          "description": "Redeem value from card",
          "header": "Toast-Transaction-Type: GIFTCARD_REDEEM",
          "cashOut": "isCashOut field indicates cash-out transaction"
        },
        "GIFTCARD_REVERSE_REDEEM": {
          "description": "Reverse previous redemption",
          "header": "Toast-Transaction-Type: GIFTCARD_REVERSE_REDEEM"
        },
        "GIFTCARD_VOID": {
          "description": "Void gift card transaction",
          "header": "Toast-Transaction-Type: GIFTCARD_VOID"
        }
      },
      "requestObject": "GiftCardTransaction",
      "responseObject": "GiftCardTransactionResponse",
      "responseStatuses": {
        "SUCCESS": "Transaction processed successfully",
        "FAILURE": "Transaction failed",
        "PARTIAL_SUCCESS": "Partial redemption (insufficient balance)"
      },
      "verificationCode": {
        "description": "Optional PIN support for gift cards",
        "implementation": "Partner can choose to support PINs"
      },
      "workflow": {
        "activation": [
          "1. Toast sends GIFTCARD_GET_BALANCE to verify card not active",
          "2. Toast sends GIFTCARD_ACTIVATE to add value"
        ],
        "redemption": [
          "1. Toast sends GIFTCARD_GET_BALANCE to check available balance",
          "2. Toast sends GIFTCARD_REDEEM to deduct value"
        ]
      }
    },
    "loyalty": {
      "specification": "Loyalty integration specification",
      "description": "Allow Toast POS to process loyalty program transactions",
      "implementation": "Partner implements REST API that Toast calls",
      "endpoint": "Single endpoint defined by partner",
      "authentication": "Toast includes authentication token in requests",
      "transactionTypes": {
        "LOYALTY_ACCRUE": "Award loyalty points for purchase",
        "LOYALTY_REDEEM": "Redeem loyalty points/rewards",
        "LOYALTY_INQUIRY": "Check loyalty account status"
      },
      "requestObject": "LoyaltyTransaction",
      "responseObject": "LoyaltyTransactionResponse",
      "customerIdentification": [
        "Phone number",
        "Email",
        "Loyalty account number",
        "QR code scan"
      ]
    },
    "tender": {
      "specification": "Tender integration specification",
      "description": "Process alternative payment types and hotel billing integrations",
      "implementation": "Partner implements REST API that Toast calls",
      "endpoint": "Single endpoint defined by partner",
      "authentication": "Toast includes authentication token in requests",
      "transactionTypes": {
        "TENDER_AUTHORIZE": {
          "description": "Authorize payment",
          "header": "Toast-Transaction-Type: TENDER_AUTHORIZE"
        },
        "TENDER_ADJUST": {
          "description": "Adjust authorization amount (e.g., add tip)",
          "header": "Toast-Transaction-Type: TENDER_ADJUST"
        },
        "TENDER_REVERSE": {
          "description": "Reverse/refund transaction",
          "header": "Toast-Transaction-Type: TENDER_REVERSE"
        },
        "SEARCH_CONFIGURATION": {
          "description": "Search for tender configuration (e.g., room lookup)",
          "header": "Toast-Transaction-Type: SEARCH_CONFIGURATION"
        },
        "GET_CONFIGURATION": {
          "description": "Get specific configuration details",
          "header": "Toast-Transaction-Type: GET_CONFIGURATION"
        }
      },
      "useCases": {
        "hotelPMS": "Direct room billing for hotel restaurants",
        "housAccounts": "Custom house account systems",
        "discounts": "Third-party discount providers"
      },
      "requestObject": "TenderTransaction",
      "responseObject": "TenderTransactionResponse",
      "responseStatuses": {
        "ACCEPT": "Transaction processed successfully",
        "ERROR_ACCOUNT_INVALID": "Invalid account identifier",
        "ERROR_INVALID_RESTAURANT": "Restaurant not recognized",
        "ERROR_INVALID_TOAST_TRANSACTION_TYPE": "Unsupported transaction type",
        "ERROR_INVALID_TOKEN": "Authentication failed",
        "ERROR_TRANSACTION_CANNOT_BE_REVERSED": "Reversal not allowed"
      },
      "performanceRequirements": {
        "averageResponseTime": "500ms",
        "maximumResponseTime": "5 seconds",
        "timeout": "Toast may close socket after 5 seconds and retry"
      },
      "checkObject": {
        "note": "Check object representation changed on 2025-06-23",
        "improvement": "Now mirrors orders API check structure",
        "includes": ["Applied service charges", "Correct total amounts", "Full check details"]
      },
      "headers": {
        "Toast-Alternate-Payment-Type-GUID": {
          "added": "2025-07-07",
          "description": "GUID of alternative payment type used"
        },
        "Accept": {
          "added": "2024-09-19",
          "value": "application/json"
        }
      }
    },
    "authentication": {
      "method": "Token-based authentication",
      "header": "Authorization: Bearer {token}",
      "tokenProvision": "Toast provides authentication token for requests",
      "validation": "Partner validates token on each request"
    },
    "errorHandling": {
      "successResponse": "HTTP 200 with appropriate status in response body",
      "clientError": "HTTP 400 with error status in response body",
      "serverError": "HTTP 500 for internal partner system errors",
      "timeout": "Respond within 5 seconds or request may be retried"
    },
    "bestPractices": [
      "Implement idempotency for transaction requests",
      "Log all requests and responses for debugging",
      "Respond within performance requirements",
      "Handle retry scenarios gracefully",
      "Validate all request data thoroughly",
      "Return appropriate error statuses",
      "Support transaction reversal where applicable",
      "Implement proper authentication validation"
    ]
  },
  "webhooks": {
    "description": "Real-time event notifications from Toast to partner endpoints",
    "architecture": "Toast sends HTTP POST requests to partner webhook URLs",
    "subscriptionManagement": "Configure via Toast Developer Portal",
    "messageFormat": "JSON in request body",
    "authentication": "Message signing with secret key for verification",
    "availableWebhooks": {
      "ordersWebhook": {
        "event": "order_updated and channel_order_updated",
        "description": "Notifications when orders are created or modified",
        "frequency": "Real-time for every order change",
        "payload": {
          "eventCategory": "order_updated or channel_order_updated",
          "eventType": "order_updated or channel_order_updated",
          "guid": "Event GUID",
          "timestamp": "Event timestamp (ISO 8601)",
          "details": {
            "restaurantGuid": "Restaurant GUID",
            "order": "Complete Order object with all nested data"
          }
        },
        "useCases": [
          "Real-time order processing",
          "Kitchen display systems",
          "Delivery management",
          "Order tracking"
        ],
        "note": "New orders are considered updates (always use order_updated event)"
      },
      "menusWebhook": {
        "event": "menus_updated",
        "description": "Notification when menu data changes",
        "frequency": "When restaurant publishes menu changes",
        "payload": {
          "eventCategory": "menus_updated",
          "guid": "Event GUID",
          "timestamp": "Event timestamp",
          "details": {
            "restaurantGuid": "Restaurant GUID"
          }
        },
        "useCases": [
          "Menu synchronization",
          "Online ordering systems",
          "Digital menu boards",
          "Price updates"
        ],
        "recommendation": "Use as primary method, poll /metadata as backup"
      },
      "partnersWebhook": {
        "event": "partner_updated",
        "description": "Notifications when restaurants add/remove integration or update settings",
        "frequency": "When restaurant connection changes",
        "payload": {
          "eventCategory": "partner_updated",
          "guid": "Event GUID",
          "timestamp": "Event timestamp",
          "details": {
            "restaurantGuid": "Restaurant GUID",
            "action": "ADDED or REMOVED",
            "externalGroupId": "External group ID",
            "externalId": "External location ID"
          }
        },
        "useCases": [
          "Restaurant connection management",
          "Integration activation/deactivation",
          "Customer account mapping"
        ],
        "importance": "Critical for partner integrations",
        "action": "Stop API calls immediately when restaurant removes integration"
      },
      "stockWebhook": {
        "event": "stock_updated",
        "description": "Notifications when inventory levels change",
        "frequency": "When stock quantities or status updated",
        "useCases": [
          "Inventory management",
          "Real-time availability updates",
          "Out-of-stock notifications"
        ]
      },
      "restaurantAvailabilityWebhook": {
        "event": "restaurant_availability_updated",
        "description": "Notifications when restaurant opens/closes for online ordering",
        "useCases": [
          "Online ordering platforms",
          "Display restaurant open/closed status",
          "Order scheduling"
        ]
      },
      "restaurantOnlineOrderingScheduleWebhook": {
        "event": "restaurant_online_ordering_schedule_updated",
        "description": "Notifications when online ordering schedule changes",
        "useCases": [
          "Online ordering schedule updates",
          "Operating hours changes"
        ]
      },
      "guestOrderFulfillmentStatusWebhook": {
        "event": "guest_order_fulfillment_status_updated",
        "description": "Notifications when order fulfillment status changes",
        "useCases": [
          "Customer notifications",
          "Order tracking",
          "Delivery status updates"
        ]
      },
      "packagingPreferencesConfigurationWebhook": {
        "event": "packaging_preferences_configuration_updated",
        "description": "Notifications when packaging configuration changes",
        "useCases": [
          "Packaging requirement updates",
          "Sustainability tracking"
        ]
      }
    },
    "webhookConfiguration": {
      "endpointRequirements": {
        "protocol": "HTTPS required",
        "responseTime": "Respond quickly (< 5 seconds recommended)",
        "statusCode": "Return 2xx for successful receipt",
        "processing": "Process webhook asynchronously if needed"
      },
      "subscriptionSetup": {
        "step1": "Create webhook endpoint on your server",
        "step2": "Provide URL to Toast support or configure in Developer Portal",
        "step3": "Implement message signature verification",
        "step4": "Handle webhook events appropriately",
        "step5": "Monitor webhook health and errors"
      },
      "notificationEmail": {
        "purpose": "Receive alerts about webhook issues",
        "configure": "Set in Toast Developer Portal",
        "alerts": ["Outages", "High error rates", "Subscription paused/stopped"]
      }
    },
    "messageSigning": {
      "description": "Verify webhook messages are from Toast",
      "header": "Toast-Signature",
      "algorithm": "HMAC SHA-256",
      "secretKey": "Provided by Toast (shown in Developer Portal)",
      "verification": "Calculate signature of message body using secret key and compare",
      "implementation": "Use HMAC libraries in your language"
    },
    "retryLogic": {
      "errorThreshold": "50+ errors in 5-minute window triggers pause",
      "pauseDuration": "1 minute",
      "pauseThreshold": "9 pauses in 10-minute window stops subscription",
      "resumption": "Contact Toast support to restart stopped subscription",
      "httpCodes": {
        "429": "Too Many Requests - Toast will retry with backoff",
        "5xx": "Server errors - Toast will retry"
      }
    },
    "httpHeaders": {
      "request": {
        "Content-Type": "application/json",
        "Toast-Signature": "HMAC signature for verification",
        "Toast-Webhook-GUID": "Unique webhook event identifier"
      },
      "response": {
        "required": "HTTP 2xx status code",
        "body": "Empty or acknowledgment message"
      }
    },
    "messageSchema": {
      "structure": {
        "eventCategory": "Type of webhook event",
        "eventType": "Specific event type",
        "guid": "Unique event identifier",
        "timestamp": "Event timestamp in ISO 8601 format",
        "details": "Event-specific payload with restaurant and data"
      }
    },
    "bestPractices": [
      "Verify message signatures on all webhooks",
      "Respond with 2xx status immediately",
      "Process webhook data asynchronously",
      "Implement idempotency using event GUID",
      "Log all webhook receipts for debugging",
      "Monitor webhook error rates",
      "Handle retry scenarios gracefully",
      "Set up notification email for alerts",
      "Test webhook endpoint before going live",
      "Implement proper error handling",
      "Use webhooks as primary data source, APIs as backup"
    ]
  },
  "dataFormats": {
    "dates": {
      "iso8601": {
        "format": "YYYY-MM-DDTHH:mm:ss.sssZ",
        "timezone": "UTC",
        "example": "2024-03-28T15:11:01.050Z",
        "usage": "All datetime fields in API requests and responses"
      },
      "businessDate": {
        "format": "YYYYMMDD",
        "type": "integer",
        "example": 20240401,
        "description": "Restaurant business date (changes at closeout hour)",
        "usage": "Order businessDate, time entry businessDate, reporting"
      }
    },
    "identifiers": {
      "guid": {
        "format": "UUID string",
        "example": "4622e7a9-b4be-3fef-9220-b3dad273e0b4",
        "usage": "All Toast entity identifiers",
        "immutable": true
      },
      "externalId": {
        "format": "String (partner defined)",
        "purpose": "Partner's identifier for mapping to Toast entities",
        "optional": true,
        "usage": "Employee externalEmployeeId, restaurant externalId"
      }
    },
    "currency": {
      "format": "Decimal number",
      "precision": "2 decimal places",
      "example": 15.99,
      "currency": "Defined per restaurant (typically USD)"
    },
    "entityType": {
      "purpose": "Identifies type of object in responses",
      "values": ["Order", "Check", "OrderSelection", "Payment", "RestaurantUser", "MenuItem", etc."],
      "usage": "Helps parse polymorphic responses"
    }
  },
  "errorHandling": {
    "httpStatusCodes": {
      "200": {
        "description": "Success",
        "usage": "Successful GET, POST, PUT, PATCH requests"
      },
      "201": {
        "description": "Created",
        "usage": "Resource created successfully"
      },
      "204": {
        "description": "No Content",
        "usage": "Successful DELETE request"
      },
      "400": {
        "description": "Bad Request",
        "causes": [
          "Invalid request parameters",
          "Validation errors",
          "Business rule violations",
          "Malformed JSON",
          "Invalid GUID format",
          "Request exceeds size limits"
        ]
      },
      "401": {
        "description": "Unauthorized",
        "causes": [
          "Missing Authorization header",
          "Invalid access token",
          "Expired access token"
        ],
        "action": "Obtain new access token"
      },
      "403": {
        "description": "Forbidden",
        "causes": [
          "Insufficient scopes",
          "Restaurant access denied",
          "Operation not permitted"
        ]
      },
      "404": {
        "description": "Not Found",
        "causes": [
          "Resource doesn't exist",
          "Invalid GUID",
          "Restaurant archived (try includeArchived=true)"
        ]
      },
      "409": {
        "description": "Conflict",
        "causes": [
          "Configuration changed during paginated request",
          "Resource state conflict"
        ],
        "action": "Restart request from first page"
      },
      "429": {
        "description": "Too Many Requests",
        "cause": "Rate limit exceeded",
        "action": "Implement backoff and retry",
        "headers": ["Retry-After may indicate wait time"]
      },
      "500": {
        "description": "Internal Server Error",
        "cause": "Toast platform error",
        "action": "Retry with exponential backoff, contact support if persistent"
      },
      "503": {
        "description": "Service Unavailable",
        "cause": "Toast platform maintenance or outage",
        "action": "Retry later, check status page"
      }
    },
    "errorMessageObject": {
      "structure": {
        "message": "Human-readable error description",
        "moreInfo": "URL to documentation page",
        "requestId": "Unique request identifier for support",
        "details": "Technical error details",
        "errors": "Array of nested error messages"
      },
      "example": {
        "message": "Invalid menu item reference",
        "moreInfo": "https://doc.toasttab.com/doc/errors/invalid-menu-item",
        "requestId": "abc123-def456-ghi789",
        "details": "Menu item GUID does not exist in restaurant menu"
      }
    },
    "bestPractices": [
      "Log all errors with requestId for support tickets",
      "Implement exponential backoff for retries",
      "Handle rate limits gracefully",
      "Don't retry 400 errors without fixing request",
      "Set error thresholds to halt repeated failures",
      "Monitor error rates for integration health",
      "Provide user-friendly error messages",
      "Include requestId when contacting Toast support"
    ]
  },
  "pagination": {
    "description": "Handle large result sets across multiple requests",
    "methods": {
      "pageToken": {
        "description": "Continuation token pagination",
        "responseHeader": "Toast-Next-Page-Token",
        "requestParameter": "pageToken",
        "usage": "Include token from response header in next request",
        "example": {
          "step1": "GET /orders/v2/orders?pageSize=100",
          "step2": "Response includes Toast-Next-Page-Token: abc123",
          "step3": "GET /orders/v2/orders?pageSize=100&pageToken=abc123"
        }
      },
      "pageNumber": {
        "description": "Page-based pagination",
        "parameters": {
          "page": "Page number (1-based)",
          "pageSize": "Results per page"
        },
        "responseFields": {
          "lastPageNum": "Total number of pages"
        },
        "usage": "Some endpoints like partners API"
      }
    },
    "pageSize": {
      "default": "Varies by endpoint (typically 100)",
      "maximum": "Varies by endpoint (typically 500)",
      "recommendation": "Use maximum for efficiency, but handle large responses"
    },
    "configurationChanges": {
      "issue": "Restaurant configuration changes during pagination can cause errors",
      "errorCode": 409,
      "action": "Restart request from beginning without pageToken"
    },
    "bestPractices": [
      "Always check for pagination tokens",
      "Use maximum pageSize for efficiency",
      "Handle 409 conflicts by restarting",
      "Implement pagination in loops",
      "Set reasonable timeout for paginated requests",
      "Store continuation tokens for long-running operations"
    ]
  },
  "rateLimit": {
    "authentication": {
      "limit": "2 tokens per hour",
      "enforcement": "Hard limit - errors if exceeded",
      "bestPractice": "Request 1-2 tokens per day, reuse for 24 hours"
    },
    "apiCalls": {
      "strategy": "Undocumented per-endpoint limits",
      "monitoring": "Watch for 429 responses",
      "handling": "Implement exponential backoff"
    },
    "webhooks": {
      "backoffRules": {
        "pauseTrigger": "50+ errors in 5 minutes",
        "pauseDuration": "1 minute",
        "stopTrigger": "9 pauses in 10 minutes",
        "resumption": "Contact Toast support"
      }
    },
    "bestPractices": [
      "Cache authentication tokens",
      "Throttle API requests",
      "Use webhooks instead of polling",
      "Implement exponential backoff",
      "Monitor rate limit responses",
      "Batch operations where possible"
    ]
  },
  "securityBestPractices": {
    "authentication": {
      "clientSecret": "Never expose in code, logs, or version control",
      "tokens": "Store securely, never log complete tokens",
      "transmission": "Always use HTTPS",
      "rotation": "Implement token refresh logic"
    },
    "dataHandling": {
      "pci": "Follow PCI DSS for credit card data",
      "encryption": "Use Toast encryption library for card data",
      "pii": "Handle employee and customer PII according to regulations",
      "logging": "Redact sensitive data from logs"
    },
    "webhooks": {
      "verification": "Always verify message signatures",
      "secretKey": "Store webhook secret key securely",
      "replay": "Implement idempotency using event GUIDs"
    },
    "errorHandling": {
      "exposure": "Don't expose internal errors to users",
      "logging": "Log securely, redact sensitive info",
      "monitoring": "Alert on unusual error patterns"
    }
  },
  "integrationPatterns": {
    "onlineOrdering": {
      "description": "Build online ordering platform integrated with Toast",
      "requiredApis": ["Orders", "Menus", "Configuration", "Payments"],
      "optionalApis": ["Stock", "Restaurants"],
      "keySteps": [
        "Subscribe to menus webhook",
        "Retrieve and cache menu data",
        "Display menus respecting availability",
        "Get pricing via /prices endpoint",
        "Create orders via orders API",
        "Process payments (optional - use Toast credit cards API)",
        "Subscribe to orders webhook for status updates",
        "Update delivery info for delivery orders"
      ],
      "bestPractices": [
        "Always use /prices endpoint before order submission",
        "Support time-specific pricing",
        "Display item tags (dietary info)",
        "Handle out-of-stock items gracefully",
        "Respect menu availability times",
        "Provide accurate estimated fulfillment times",
        "Support modifier sequence pricing"
      ]
    },
    "employeeManagement": {
      "description": "Sync employee data between Toast and HR/payroll systems",
      "requiredApis": ["Labor"],
      "keySteps": [
        "Initial employee load when restaurant connects",
        "Map employees using externalEmployeeId",
        "Create employees via POST /employees",
        "Update employees via PATCH /employees",
        "Poll /employees periodically for Toast-side changes",
        "Retrieve time entries for payroll",
        "Get shifts for scheduling sync"
      ],
      "bestPractices": [
        "Use externalEmployeeId for mapping",
        "Batch employee updates",
        "Check for clocked-in status before deletion",
        "Provide audit trail for changes",
        "Handle email uniqueness constraints",
        "Use orders API for tips/sales data"
      ]
    },
    "reporting": {
      "description": "Build sales and operations reporting tools",
      "requiredApis": ["Orders", "Menus", "Configuration", "Labor"],
      "optionalApis": ["Cash Management", "Restaurants"],
      "keySteps": [
        "Retrieve orders via /ordersBulk with businessDate",
        "Get menu data for item names and categories",
        "Get configuration for discounts, service charges, etc.",
        "Calculate sales by category, item, server, etc.",
        "Handle voided items appropriately",
        "Account for deferred items (gift cards)",
        "Get time entries for labor costs",
        "Get cash entries for drawer reconciliation"
      ],
      "bestPractices": [
        "Use businessDate for daily reports",
        "Respect closeout hour in calculations",
        "Filter voided items unless needed",
        "Use sales categories for grouping",
        "Calculate net sales (minus discounts/voids)",
        "Track service charges separately",
        "Use orders API for payment data",
        "Aggregate data for performance"
      ]
    },
    "inventoryManagement": {
      "description": "Track and manage restaurant inventory",
      "requiredApis": ["Stock", "Menus", "Orders"],
      "keySteps": [
        "Subscribe to stock webhook",
        "Retrieve current stock levels",
        "Update stock quantities via PATCH/PUT",
        "Track usage via order selections",
        "Alert on low/out-of-stock items",
        "Sync with external inventory systems"
      ],
      "bestPractices": [
        "Use webhooks for real-time updates",
        "Handle EIGHTY_SIX status",
        "Track modifier option inventory",
        "Implement stock alerts",
        "Batch stock updates"
      ]
    },
    "loyaltyProgram": {
      "description": "Integrate third-party loyalty program",
      "implementationType": "Outbound API (Toast calls partner)",
      "specification": "Loyalty integration specification",
      "keyComponents": [
        "Implement loyalty API on partner server",
        "Handle LOYALTY_ACCRUE transactions",
        "Handle LOYALTY_REDEEM transactions",
        "Handle LOYALTY_INQUIRY requests",
        "Identify customers (phone/email/account)",
        "Return loyalty account status",
        "Apply rewards to checks"
      ],
      "integration": "Configure in Toast platform per restaurant"
    },
    "giftCards": {
      "description": "Integrate gift card provider",
      "implementationType": "Outbound API (Toast calls partner)",
      "specification": "Gift cards integration specification",
      "keyComponents": [
        "Implement gift card API on partner server",
        "Handle balance inquiries",
        "Handle card activation",
        "Handle add value transactions",
        "Handle redemptions",
        "Handle reversals and voids",
        "Support verification codes (optional)"
      ]
    }
  },
  "developmentWorkflow": {
    "gettingStarted": {
      "step1": {
        "action": "Choose integration type",
        "options": ["Partner integration", "Restaurant management group", "Standard API access", "Analytics access"],
        "documentation": "https://doc.toasttab.com/doc/devguide/portalGettingStarted.html"
      },
      "step2": {
        "action": "Register with Toast integrations team",
        "email": "[Contact Toast support]",
        "provide": ["Business information", "Integration description", "Expected restaurants", "Use cases"]
      },
      "step3": {
        "action": "Receive credentials",
        "sandbox": "Credentials for sandbox environment",
        "production": "Separate credentials for production (after certification)"
      },
      "step4": {
        "action": "Access Toast Developer Portal",
        "url": "https://dev.toasttab.com",
        "features": ["View credentials", "Manage scopes", "Configure webhooks", "Monitor connections"]
      },
      "step5": {
        "action": "Download example API requests",
        "tool": "Postman collection",
        "contents": "Example requests for all APIs with auto-authentication"
      },
      "step6": {
        "action": "Build and test integration",
        "environment": "Sandbox first",
        "testing": "Thorough testing with various scenarios"
      },
      "step7": {
        "action": "Integration certification",
        "process": "Work with Toast team to certify",
        "requirements": "Meet integration requirements checklist"
      },
      "step8": {
        "action": "Launch to production",
        "credentials": "Receive production credentials",
        "marketplace": "List in Toast Partner Integrations"
      }
    },
    "testingChecklist": [
      "Test authentication and token refresh",
      "Test all CRUD operations",
      "Test error handling (400, 401, 404, 500)",
      "Test rate limiting scenarios",
      "Test pagination for large datasets",
      "Test webhook receipt and processing",
      "Test message signature verification",
      "Test restaurant connection/disconnection",
      "Test with multiple restaurants",
      "Test voided items and payments",
      "Test timezone and business date logic",
      "Load test with expected volume"
    ],
    "certificationRequirements": {
      "documentation": "Provide integration documentation",
      "errorHandling": "Implement proper error handling",
      "rateLimiting": "Respect rate limits",
      "webhooks": "Use webhooks appropriately",
      "security": "Follow security best practices",
      "support": "Provide customer support",
      "testing": "Complete thorough testing",
      "logging": "Implement proper logging",
      "monitoring": "Set up integration monitoring"
    }
  },
  "commonIssues": {
    "authenticationExpired": {
      "symptom": "401 Unauthorized errors",
      "cause": "Access token expired",
      "solution": "Implement token refresh before expiration",
      "prevention": "Monitor expires_in value and refresh proactively"
    },
    "invalidRestaurantId": {
      "symptom": "403 or 404 errors",
      "cause": "Wrong or missing Toast-Restaurant-External-ID header",
      "solution": "Verify correct restaurant GUID in header",
      "prevention": "Validate restaurant GUIDs from partners API"
    },
    "menuNotFound": {
      "symptom": "400 errors when creating orders with menu items",
      "cause": "Menu item GUID doesn't exist or menu not published",
      "solution": "Refresh menu data and verify item GUIDs",
      "prevention": "Subscribe to menus webhook and refresh when notified"
    },
    "pricingMismatch": {
      "symptom": "Payment amounts don't match order total",
      "cause": "Not using /prices endpoint",
      "solution": "Always call /prices before order submission",
      "prevention": "Make /prices endpoint mandatory in order flow"
    },
    "rateLimitErrors": {
      "symptom": "429 Too Many Requests",
      "cause": "Exceeding API rate limits",
      "solution": "Implement exponential backoff and retry",
      "prevention": "Throttle requests, use webhooks instead of polling"
    },
    "webhookNotReceived": {
      "symptom": "Missing webhook notifications",
      "cause": "Webhook endpoint down or subscription paused",
      "solution": "Check webhook health in Developer Portal",
      "prevention": "Monitor webhook endpoint uptime, implement fallback polling"
    },
    "employeeEmailConflict": {
      "symptom": "400 error when creating employee",
      "cause": "Email already exists for another employee",
      "solution": "Use unique email or update existing employee",
      "prevention": "Check existing employees before creation"
    },
    "clockedInEmployee": {
      "symptom": "Cannot delete or update employee",
      "cause": "Employee currently clocked in",
      "solution": "Wait for clock out or check time entries first",
      "prevention": "Query time entries before employee operations"
    }
  },
  "resources": {
    "documentation": {
      "developerGuide": "https://doc.toasttab.com/doc/devguide/index.html",
      "apiReference": "https://toastintegrations.redoc.ly/",
      "analyticsReference": "https://toastprereleaseperformance.redoc.ly/",
      "cookbook": "https://doc.toasttab.com/doc/cookbook/index.html",
      "platformGuide": "https://doc.toasttab.com/doc/platformguide/index.html"
    },
    "tools": {
      "developerPortal": "https://dev.toasttab.com",
      "postmanCollection": "Available in developer documentation",
      "statusPage": "https://status.toasttab.com"
    },
    "support": {
      "communityForum": "Toast Integrations Community Forum",
      "email": "[Contact Toast support for integration team email]",
      "documentation": "Comprehensive docs at https://doc.toasttab.com"
    }
  },
  "versionHistory": {
    "3.0.0": {
      "date": "2025-10-07",
      "changes": "Complete comprehensive documentation with all endpoints and schemas"
    }
  }
}
