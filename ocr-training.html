<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, viewport-fit=cover">
  <title>OCR Training System - Jayna Gyro</title>

  <link rel="apple-touch-icon" href="https://static.spotapps.co/website_images/ab_websites/229800_website_v1/logo.png">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#00A8E1">

  <!-- External Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    // Configure PDF.js worker (MUST be done before using pdfjsLib)
    if (typeof pdfjsLib !== 'undefined') {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }
  </script>

  <style>
    /* Jayna Brand Design - Sky Blue & Grayscale */
    :root {
      --primary-blue: #00A8E1;
      --secondary-blue: #0094D6;
      --light-blue: #E3F4FC;
      --accent-blue: #0081C6;
      --gray-900: #212121;
      --gray-700: #424242;
      --gray-600: #616161;
      --gray-500: #757575;
      --gray-400: #BDBDBD;
      --gray-300: #E0E0E0;
      --gray-100: #F5F5F5;
      --success: #00C853;
      --warning: #FFB300;
      --error: #D32F2F;
      --white: #FFFFFF;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      font-family: 'Aptos', 'Segoe UI Variable', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background: var(--white);
      min-height: 100vh;
      padding: 0;
      overflow-x: hidden;
      overflow-y: auto;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      background: linear-gradient(135deg, var(--primary-blue), var(--secondary-blue));
      color: var(--white);
      padding: 24px;
      border-radius: 0;
      margin-bottom: 20px;
      text-align: center;
    }

    .header h1 {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .header p {
      opacity: 0.9;
      font-size: 13px;
      font-weight: 500;
    }

    .stats-bar {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin-bottom: 20px;
    }

    .stat-card {
      background: var(--gray-100);
      border: 2px solid var(--gray-300);
      padding: 16px;
      text-align: center;
    }

    .stat-value {
      font-size: 28px;
      font-weight: 700;
      color: var(--primary-blue);
      margin-bottom: 4px;
    }

    .stat-label {
      font-size: 11px;
      font-weight: 700;
      color: var(--gray-600);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    @media (max-width: 900px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: var(--white);
      border: 2px solid var(--gray-300);
      padding: 20px;
    }

    .panel-header {
      font-size: 14px;
      font-weight: 700;
      color: var(--gray-900);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 2px solid var(--gray-300);
    }

    .upload-zone {
      border: 3px dashed var(--gray-300);
      padding: 40px 20px;
      text-align: center;
      margin-bottom: 20px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .upload-zone:hover {
      border-color: var(--primary-blue);
      background: var(--light-blue);
    }

    .upload-zone.active {
      border-color: var(--primary-blue);
      background: var(--light-blue);
    }

    .upload-icon {
      font-size: 48px;
      color: var(--gray-400);
      margin-bottom: 12px;
    }

    .btn {
      padding: 12px 24px;
      border: 2px solid var(--gray-300);
      background: var(--gray-100);
      color: var(--gray-900);
      font-size: 13px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      cursor: pointer;
      transition: all 0.15s ease;
      display: inline-block;
      margin: 4px;
    }

    .btn:hover {
      background: var(--gray-300);
      transform: translateY(-1px);
    }

    .btn-primary {
      background: var(--primary-blue);
      border-color: var(--primary-blue);
      color: var(--white);
    }

    .btn-primary:hover {
      background: var(--secondary-blue);
      border-color: var(--secondary-blue);
    }

    .btn-success {
      background: var(--success);
      border-color: var(--success);
      color: var(--white);
    }

    .btn-success:hover {
      background: #00A843;
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-label {
      display: block;
      font-size: 11px;
      font-weight: 700;
      color: var(--gray-700);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }

    .form-input, .form-select {
      width: 100%;
      padding: 12px;
      border: 2px solid var(--gray-300);
      background: var(--white);
      font-size: 14px;
      font-weight: 400;
    }

    .form-input:focus, .form-select:focus {
      outline: none;
      border-color: var(--primary-blue);
    }

    .item-card {
      background: var(--gray-100);
      border: 2px solid var(--gray-300);
      padding: 16px;
      margin-bottom: 12px;
      position: relative;
    }

    .item-card.corrected {
      border-color: var(--success);
      background: #E8F5E9;
    }

    .item-card.needs-review {
      border-color: var(--warning);
      background: #FFF8E1;
    }

    .confidence-badge {
      position: absolute;
      top: 12px;
      right: 12px;
      padding: 4px 10px;
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-radius: 0;
    }

    .confidence-high {
      background: var(--success);
      color: var(--white);
    }

    .confidence-medium {
      background: var(--warning);
      color: var(--gray-900);
    }

    .confidence-low {
      background: var(--error);
      color: var(--white);
    }

    .item-grid {
      display: grid;
      grid-template-columns: 2fr 1fr 1fr 1fr;
      gap: 12px;
      margin-bottom: 12px;
    }

    @media (max-width: 600px) {
      .item-grid {
        grid-template-columns: 1fr;
      }
    }

    .learned-pattern {
      background: var(--light-blue);
      border: 1px solid var(--primary-blue);
      padding: 12px;
      margin-bottom: 8px;
      font-size: 12px;
    }

    .learned-pattern strong {
      color: var(--primary-blue);
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: var(--gray-600);
    }

    .spinner {
      border: 3px solid var(--gray-300);
      border-top: 3px solid var(--primary-blue);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 16px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .preview-image {
      max-width: 100%;
      border: 2px solid var(--gray-300);
      margin-bottom: 16px;
    }

    .ocr-text {
      background: var(--gray-100);
      border: 1px solid var(--gray-300);
      padding: 12px;
      font-family: monospace;
      font-size: 11px;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
      margin-bottom: 16px;
    }

    .success-message {
      background: #E8F5E9;
      border: 2px solid var(--success);
      color: #1B5E20;
      padding: 16px;
      margin-bottom: 20px;
      font-weight: 600;
    }

    .error-message {
      background: #FFEBEE;
      border: 2px solid var(--error);
      color: #B71C1C;
      padding: 16px;
      margin-bottom: 20px;
      font-weight: 600;
    }

    .match-suggestion {
      background: var(--light-blue);
      border-left: 4px solid var(--primary-blue);
      padding: 8px 12px;
      margin-top: 8px;
      font-size: 12px;
    }

    .match-suggestion a {
      color: var(--primary-blue);
      font-weight: 700;
      cursor: pointer;
      text-decoration: underline;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>

<div class="container">
  <!-- Header -->
  <div class="header">
    <h1>OCR Training System</h1>
    <p>Train the system to recognize invoices and orders more accurately</p>
  </div>

  <!-- Stats Bar -->
  <div class="stats-bar">
    <div class="stat-card">
      <div class="stat-value" id="statSessions">0</div>
      <div class="stat-label">Training Sessions</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="statCorrections">0</div>
      <div class="stat-label">Corrections Made</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="statPatterns">0</div>
      <div class="stat-label">Patterns Learned</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="statVendors">0</div>
      <div class="stat-label">Vendor Templates</div>
    </div>
  </div>

  <!-- Main Grid -->
  <div class="main-grid">
    <!-- Left Panel: Upload & OCR -->
    <div class="panel">
      <div class="panel-header">1. Upload Invoice/Order</div>

      <div class="upload-zone" id="uploadZone">
        <div class="upload-icon">ðŸ“„</div>
        <p style="font-size: 14px; font-weight: 600; margin-bottom: 8px;">
          Click to upload or drag & drop
        </p>
        <p style="font-size: 12px; color: var(--gray-600);">
          Supports: JPG, PNG, PDF
        </p>
        <input type="file" id="fileInput" accept="image/*,application/pdf" style="display: none;">
      </div>

      <div class="form-group">
        <label class="form-label">Vendor (optional - will auto-detect)</label>
        <select class="form-select" id="vendorSelect">
          <option value="">Auto-detect from items...</option>
        </select>
      </div>

      <div class="form-group">
        <label class="form-label">Document Type</label>
        <select class="form-select" id="docTypeSelect">
          <option value="invoice">Invoice</option>
          <option value="order">Order</option>
        </select>
      </div>

      <div class="form-group">
        <label class="form-label">Document Date (optional)</label>
        <input type="date" class="form-input" id="docDate">
      </div>

      <button class="btn btn-primary" id="processBtn" disabled>
        Process with OCR
      </button>

      <!-- Preview -->
      <div id="previewSection" class="hidden">
        <div class="panel-header" style="margin-top: 20px;">Image Preview</div>
        <img id="previewImage" class="preview-image" alt="Preview">

        <div class="panel-header">Raw OCR Text</div>
        <div class="ocr-text" id="ocrText"></div>
      </div>
    </div>

    <!-- Right Panel: Detected Items -->
    <div class="panel">
      <div class="panel-header">2. Review & Correct Items</div>

      <div id="loadingSection" class="hidden">
        <div class="loading">
          <div class="spinner"></div>
          <p>Processing with OCR...</p>
        </div>
      </div>

      <div id="itemsSection" class="hidden">
        <p style="margin-bottom: 16px; font-size: 13px; color: var(--gray-600);">
          <strong id="itemCount">0</strong> items detected.
          Review and correct as needed.
        </p>
        <div id="itemsList"></div>

        <button class="btn btn-success" id="saveTrainingBtn" style="width: 100%; margin-top: 20px;">
          Save Training Data
        </button>
      </div>

      <div id="emptyState" style="text-align: center; padding: 60px 20px; color: var(--gray-500);">
        <div style="font-size: 64px; margin-bottom: 16px;">ðŸŽ“</div>
        <p style="font-size: 14px; font-weight: 600;">Upload an invoice to start training</p>
      </div>
    </div>
  </div>

  <!-- Learned Patterns Panel -->
  <div class="panel">
    <div class="panel-header">Learned Patterns (Real-Time Feedback)</div>
    <div id="learnedPatternsList">
      <p style="color: var(--gray-600); font-size: 13px;">
        No patterns learned yet. Start training to see what the system learns!
      </p>
    </div>
  </div>
</div>

<script>
// ============================================
// CONFIGURATION
// ============================================
const SUPABASE_URL = 'https://gaawtbqpnnbbnsyswqwv.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdhYXd0YnFwbm5iYm5zeXN3cXd2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDE1NTAsImV4cCI6MjA3MjA3NzU1MH0.F-y7AIQTWaUe7DRT4OnIZVn94mhXxfhpBbng2aJ8nXg';

// Initialize Supabase
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// ============================================
// STATE
// ============================================
const state = {
  currentSession: null,
  currentImage: null,
  ocrResult: null,
  detectedItems: [],
  inventoryItems: [],
  vendors: [],
  corrections: [],
  sessionStartTime: null
};

// ============================================
// INITIALIZATION
// ============================================
document.addEventListener('DOMContentLoaded', async () => {
  console.log('OCR Training System initialized');

  await loadInventoryItems();
  await loadVendors();
  await loadStats();

  setupEventListeners();
});

async function loadInventoryItems() {
  try {
    const { data, error } = await supabase
      .from('inventory_items')
      .select('id, item_name, vendor, unit, par_level')
      .order('item_name');

    if (error) throw error;

    state.inventoryItems = data || [];
    console.log(`Loaded ${state.inventoryItems.length} inventory items`);
  } catch (error) {
    console.error('Error loading inventory:', error);
  }
}

async function loadVendors() {
  const uniqueVendors = [...new Set(state.inventoryItems.map(item => item.vendor))];
  state.vendors = uniqueVendors.filter(v => v).sort();

  const vendorSelect = document.getElementById('vendorSelect');
  state.vendors.forEach(vendor => {
    const option = document.createElement('option');
    option.value = vendor;
    option.textContent = vendor;
    vendorSelect.appendChild(option);
  });

  console.log(`Loaded ${state.vendors.length} vendors (ALL vendors selectable)`);
  console.log(`Auto-detection limited to: Greenleaf, Mani Imports, Performance`);
}

async function loadStats() {
  try {
    // Load session count
    const { count: sessions } = await supabase
      .from('ocr_training_sessions')
      .select('*', { count: 'exact', head: true });

    // Load correction count
    const { count: corrections } = await supabase
      .from('ocr_training_corrections')
      .select('*', { count: 'exact', head: true });

    // Load pattern count
    const { count: patterns } = await supabase
      .from('ocr_learned_patterns')
      .select('*', { count: 'exact', head: true })
      .eq('is_active', true);

    // Load vendor template count
    const { count: vendors } = await supabase
      .from('ocr_vendor_templates')
      .select('*', { count: 'exact', head: true });

    document.getElementById('statSessions').textContent = sessions || 0;
    document.getElementById('statCorrections').textContent = corrections || 0;
    document.getElementById('statPatterns').textContent = patterns || 0;
    document.getElementById('statVendors').textContent = vendors || 0;
  } catch (error) {
    console.error('Error loading stats:', error);
  }
}

// ============================================
// EVENT LISTENERS
// ============================================
function setupEventListeners() {
  const uploadZone = document.getElementById('uploadZone');
  const fileInput = document.getElementById('fileInput');
  const processBtn = document.getElementById('processBtn');
  const saveTrainingBtn = document.getElementById('saveTrainingBtn');

  // Upload zone click
  uploadZone.addEventListener('click', () => fileInput.click());

  // File selection
  fileInput.addEventListener('change', handleFileSelect);

  // Drag and drop
  uploadZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    uploadZone.classList.add('active');
  });

  uploadZone.addEventListener('dragleave', () => {
    uploadZone.classList.remove('active');
  });

  uploadZone.addEventListener('drop', (e) => {
    e.preventDefault();
    uploadZone.classList.remove('active');

    if (e.dataTransfer.files.length > 0) {
      fileInput.files = e.dataTransfer.files;
      handleFileSelect({ target: fileInput });
    }
  });

  // Process button
  processBtn.addEventListener('click', processWithOCR);

  // Save training button
  saveTrainingBtn.addEventListener('click', saveTrainingData);
}

// ============================================
// FILE HANDLING
// ============================================
function handleFileSelect(event) {
  const file = event.target.files[0];
  if (!file) return;

  console.log('File selected:', file.name);

  const reader = new FileReader();
  reader.onload = (e) => {
    state.currentImage = e.target.result;
    document.getElementById('previewImage').src = state.currentImage;
    document.getElementById('previewSection').classList.remove('hidden');
    document.getElementById('processBtn').disabled = false;
  };
  reader.readAsDataURL(file);
}

// ============================================
// PDF TO IMAGE CONVERSION (SAME AS INDEX.HTML)
// ============================================
async function convertPdfToImages(pdfDataUrl) {
  console.log('ðŸ“„ Converting PDF to images...');

  // Extract base64 data
  const base64Data = pdfDataUrl.split(',')[1];
  const binaryData = atob(base64Data);
  const uint8Array = new Uint8Array(binaryData.length);
  for (let i = 0; i < binaryData.length; i++) {
    uint8Array[i] = binaryData.charCodeAt(i);
  }

  // Load PDF with PDF.js
  const loadingTask = pdfjsLib.getDocument({ data: uint8Array });
  const pdf = await loadingTask.promise;

  console.log(`ðŸ“„ PDF loaded: ${pdf.numPages} page(s)`);

  const images = [];

  // Process ALL pages
  for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
    console.log(`ðŸ“„ Processing page ${pageNum}/${pdf.numPages}...`);

    const page = await pdf.getPage(pageNum);

    // Set scale for good quality (2 = 2x resolution)
    const scale = 2.0;
    const viewport = page.getViewport({ scale });

    // Create canvas for this page
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = viewport.width;
    canvas.height = viewport.height;

    // Render PDF page to canvas
    await page.render({
      canvasContext: context,
      viewport: viewport
    }).promise;

    console.log(`âœ… Page ${pageNum} rendered:`, canvas.width, 'x', canvas.height);

    // Convert canvas to image data URL
    const imageDataUrl = canvas.toDataURL('image/png');
    images.push(imageDataUrl);
  }

  console.log(`âœ… All ${pdf.numPages} pages converted to images`);

  return images;
}

// ============================================
// OCR PROCESSING (MATCHES INDEX.HTML EXACTLY)
// ============================================
async function processWithOCR() {
  if (!state.currentImage) return;

  state.sessionStartTime = Date.now();

  // Show loading
  document.getElementById('loadingSection').classList.remove('hidden');
  document.getElementById('emptyState').classList.add('hidden');
  document.getElementById('itemsSection').classList.add('hidden');

  try {
    console.log('Starting OCR processing...');

    // Check if this is a PDF file (SAME AS INDEX.HTML)
    const isPDF = state.currentImage.startsWith('data:application/pdf');
    let extractedText = '';
    let avgConfidence = 0;

    if (isPDF) {
      console.log('ðŸ“„ PDF detected - converting to images and processing all pages...');

      // Check if PDF.js is loaded
      if (typeof pdfjsLib === 'undefined') {
        throw new Error('PDF.js library not loaded. Please refresh the page.');
      }

      // Convert PDF to multiple images (one per page)
      const images = await convertPdfToImages(state.currentImage);
      console.log('âœ… PDF converted to', images.length, 'image(s)');

      // Process each page with OCR
      let totalConfidence = 0;
      for (let i = 0; i < images.length; i++) {
        const pageNum = i + 1;
        console.log(`ðŸ” OCR processing page ${pageNum}/${images.length}...`);

        const result = await Tesseract.recognize(
          images[i],
          'eng',
          {
            logger: (m) => {
              if (m.status === 'recognizing text') {
                const progress = Math.round(m.progress * 100);
                console.log(`Page ${pageNum}/${images.length}: ${progress}%`);
              }
            }
          }
        );

        const pageText = result?.data?.text || '';
        const pageConfidence = result?.data?.confidence || 0;
        totalConfidence += pageConfidence;

        console.log(`âœ… Page ${pageNum} OCR completed: ${pageText.length} characters, ${pageConfidence.toFixed(1)}% confidence`);

        // Combine text from all pages
        extractedText += pageText + '\n\n'; // Add spacing between pages
      }

      avgConfidence = images.length > 0 ? totalConfidence / images.length : 0;
      console.log('âœ… All pages processed. Total text length:', extractedText.length);

      // Store the first page result for compatibility
      state.ocrResult = { data: { text: extractedText, confidence: avgConfidence } };

    } else {
      // Process single image (SAME AS INDEX.HTML)
      console.log('ðŸ–¼ï¸ Image detected - processing with OCR...');

      const result = await Tesseract.recognize(
        state.currentImage,
        'eng',
        {
          logger: m => {
            if (m.status === 'recognizing text') {
              console.log(`OCR Progress: ${Math.round(m.progress * 100)}%`);
            }
          }
        }
      );

      state.ocrResult = result;
      extractedText = result.data.text;
      avgConfidence = result.data.confidence;
    }

    console.log(`OCR Complete! Confidence: ${avgConfidence.toFixed(1)}%`);
    console.log('Extracted text length:', extractedText.length);

    // Display OCR text
    document.getElementById('ocrText').textContent = extractedText;

    // Extract items from OCR text
    const extractedItems = extractItemsFromOCR(extractedText, avgConfidence);

    console.log(`Extracted ${extractedItems.length} items`);

    // Auto-match items to inventory
    await autoMatchItems(extractedItems);

    // Detect vendor from matched items
    detectVendor(extractedItems);

    // Create training session
    await createTrainingSession(ocrText, avgConfidence, extractedItems.length);

    // Display items for review
    displayItems(extractedItems);

    // Hide loading, show items
    document.getElementById('loadingSection').classList.add('hidden');
    document.getElementById('itemsSection').classList.remove('hidden');

  } catch (error) {
    console.error('OCR Error:', error);
    alert('OCR processing failed: ' + error.message);
    document.getElementById('loadingSection').classList.add('hidden');
  }
}

// ============================================
// ITEM EXTRACTION (Reuse from index.html)
// ============================================
function extractItemsFromOCR(ocrText, avgConfidence) {
  const items = [];
  const lines = ocrText.split('\n').map(l => l.trim()).filter(l => l.length > 0);

  console.log(`Processing ${lines.length} OCR lines`);

  // Enhanced pattern to catch unit in the line
  const itemWithUnitPattern = /^[\s]*([0-9]+\.?[0-9]*)\s+(.+?)\s+(CS|EA|LB|KG|OZ|GAL|BT|CASE|EACH|POUND)\s+([0-9]+\.[0-9]{2})[\s]*$/i;
  const itemPattern = /^[\s]*([0-9]+\.?[0-9]*)\s+(.+?)\s+([0-9]+\.[0-9]{2})[\s]*$/;

  let patternMatchCount = 0;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmed = line.trim();
    if (trimmed.length < 5) continue;

    // Try unit-aware pattern first
    let match = trimmed.match(itemWithUnitPattern);
    let detectedUnit = null;

    if (match) {
      const quantity = parseFloat(match[1]);
      const name = match[2].trim();
      detectedUnit = match[3].toUpperCase();
      const price = parseFloat(match[4]);

      // Normalize unit names
      if (detectedUnit === 'CASE') detectedUnit = 'CS';
      if (detectedUnit === 'EACH') detectedUnit = 'EA';
      if (detectedUnit === 'POUND') detectedUnit = 'LB';

      if (quantity >= 0.25 && quantity <= 1000 && name.length > 2) {
        items.push({
          id: Date.now() + Math.random() + i,
          detectedName: name,
          detectedQuantity: quantity,
          detectedQuantityShipped: null,
          detectedUnit: detectedUnit,
          detectedPrice: price,
          detectedLineNumber: i,
          detectedConfidence: avgConfidence,
          rawOcrLine: line,
          matchedInventoryId: null,
          matchConfidence: 0,
          matchedItemName: null,
          matchedVendor: null,
          correctedName: null,
          correctedQuantity: null,
          correctedPrice: null,
          correctedUnit: null
        });
        patternMatchCount++;
        continue;
      }
    }

    // Try standard pattern (no unit in line)
    match = trimmed.match(itemPattern);
    if (match) {
      const quantity = parseFloat(match[1]);
      const name = match[2].trim();
      const price = parseFloat(match[3]);

      if (quantity >= 0.25 && quantity <= 1000 && name.length > 2) {
        items.push({
          id: Date.now() + Math.random() + i,
          detectedName: name,
          detectedQuantity: quantity,
          detectedQuantityShipped: null,
          detectedUnit: null,
          detectedPrice: price,
          detectedLineNumber: i,
          detectedConfidence: avgConfidence,
          rawOcrLine: line,
          matchedInventoryId: null,
          matchConfidence: 0,
          matchedItemName: null,
          matchedVendor: null,
          correctedName: null,
          correctedQuantity: null,
          correctedPrice: null,
          correctedUnit: null
        });
        patternMatchCount++;
      }
    }
  }

  console.log(`Pattern matching found ${patternMatchCount} items`);

  // If pattern matching found very few items, show all lines for manual matching
  if (patternMatchCount < 3 && lines.length > patternMatchCount) {
    console.log('Low pattern match count, showing all lines for manual review');

    for (let i = 0; i < lines.length; i++) {
      const trimmed = lines[i].trim();
      if (trimmed.length < 3) continue;
      if (items.find(item => item.rawOcrLine === lines[i])) continue;

      items.push({
        id: Date.now() + Math.random() + i,
        detectedName: trimmed,
        detectedQuantity: 1,
        detectedQuantityShipped: null,
        detectedUnit: null,
        detectedPrice: null,
        detectedLineNumber: i,
        detectedConfidence: avgConfidence,
        rawOcrLine: lines[i],
        matchedInventoryId: null,
        matchConfidence: 0,
        matchedItemName: null,
        matchedVendor: null,
        correctedName: null,
        correctedQuantity: null,
        correctedPrice: null,
        correctedUnit: null
      });
    }
  }

  state.detectedItems = items;
  return items;
}

// ============================================
// AUTO-MATCHING (with fuzzy logic)
// ============================================
async function autoMatchItems(items) {
  console.log('Starting auto-match process...');

  // RESTRICT AUTO-MATCHING TO KEY VENDORS ONLY (Greenleaf, Mani Imports, Performance)
  const KEY_VENDORS = ['Greenleaf', 'Mani Imports', 'Performance'];
  const filteredInventory = state.inventoryItems.filter(item =>
    KEY_VENDORS.includes(item.vendor)
  );

  console.log(`Auto-matching against ${filteredInventory.length} items from ${KEY_VENDORS.join(', ')}`);
  console.log(`(All ${state.inventoryItems.length} items still selectable manually)`);

  for (const item of items) {
    const bestMatch = findBestMatch(item.detectedName, filteredInventory);

    if (bestMatch && bestMatch.confidence >= 0.4) {
      item.matchedInventoryId = bestMatch.id;
      item.matchConfidence = bestMatch.confidence;
      item.matchedItemName = bestMatch.itemName;
      item.matchedVendor = bestMatch.vendor;

      // If unit wasn't detected, use inventory item's unit
      if (!item.detectedUnit && bestMatch.unit) {
        item.detectedUnit = bestMatch.unit;
      }

      console.log(`  âœ“ Matched "${item.detectedName}" â†’ "${bestMatch.itemName}" (${(bestMatch.confidence * 100).toFixed(0)}%)`);
    } else {
      console.log(`  âš ï¸ No match for "${item.detectedName}"`);
    }
  }
}

function findBestMatch(detectedName, inventoryItems) {
  let bestMatch = null;
  let highestConfidence = 0;

  const normalizedDetected = detectedName.toLowerCase().trim();

  for (const item of inventoryItems) {
    const normalizedInventory = item.item_name.toLowerCase().trim();

    // Exact match
    if (normalizedDetected === normalizedInventory) {
      return {
        id: item.id,
        itemName: item.item_name,
        vendor: item.vendor,
        unit: item.unit,
        confidence: 1.0
      };
    }

    // Contains match
    if (normalizedInventory.includes(normalizedDetected) || normalizedDetected.includes(normalizedInventory)) {
      const confidence = 0.85;
      if (confidence > highestConfidence) {
        highestConfidence = confidence;
        bestMatch = {
          id: item.id,
          itemName: item.item_name,
          vendor: item.vendor,
          unit: item.unit,
          confidence
        };
      }
    }

    // Fuzzy match (simple word overlap)
    const detectedWords = normalizedDetected.split(/\s+/);
    const inventoryWords = normalizedInventory.split(/\s+/);
    const matchingWords = detectedWords.filter(w => inventoryWords.some(iw => iw.includes(w) || w.includes(iw)));

    if (matchingWords.length > 0) {
      const confidence = matchingWords.length / Math.max(detectedWords.length, inventoryWords.length);
      if (confidence > highestConfidence && confidence >= 0.4) {
        highestConfidence = confidence;
        bestMatch = {
          id: item.id,
          itemName: item.item_name,
          vendor: item.vendor,
          unit: item.unit,
          confidence
        };
      }
    }
  }

  return bestMatch;
}

// ============================================
// VENDOR DETECTION (RESTRICTED TO KEY VENDORS)
// ============================================
function detectVendor(items) {
  const KEY_VENDORS = ['Greenleaf', 'Mani Imports', 'Performance'];
  const vendorCounts = {};

  items.forEach(item => {
    // ONLY count vendors from the KEY_VENDORS list
    if (item.matchedVendor && KEY_VENDORS.includes(item.matchedVendor)) {
      vendorCounts[item.matchedVendor] = (vendorCounts[item.matchedVendor] || 0) + 1;
    }
  });

  let determinedVendor = null;
  let maxCount = 0;

  for (const [vendor, count] of Object.entries(vendorCounts)) {
    if (count > maxCount) {
      maxCount = count;
      determinedVendor = vendor;
    }
  }

  if (determinedVendor) {
    console.log(`ðŸ¢ Vendor auto-detected: ${determinedVendor} (${maxCount}/${items.length} items matched)`);
    console.log(`âœ… Only Greenleaf, Mani Imports, Performance considered for auto-detection`);
    document.getElementById('vendorSelect').value = determinedVendor;
  } else {
    console.log(`âš ï¸ No vendor auto-detected (only Greenleaf, Mani Imports, Performance considered)`);
  }
}

// ============================================
// DISPLAY ITEMS (ENHANCED WITH SKIP & POSITION LEARNING)
// ============================================
function displayItems(items) {
  const itemsList = document.getElementById('itemsList');
  itemsList.innerHTML = '';

  document.getElementById('itemCount').textContent = items.length;

  items.forEach((item, index) => {
    // Skip if marked as skipped
    if (item.skipped) return;

    const card = document.createElement('div');
    card.className = 'item-card';
    card.id = `item-card-${index}`;

    // Add status class
    if (item.skipped) {
      card.style.display = 'none';
      return;
    } else if (item.matchConfidence >= 0.7) {
      card.classList.add('corrected');
    } else if (item.matchConfidence < 0.5) {
      card.classList.add('needs-review');
    }

    // Confidence badge
    const badge = document.createElement('div');
    badge.className = 'confidence-badge';
    if (item.matchConfidence >= 0.7) {
      badge.className += ' confidence-high';
      badge.textContent = `${(item.matchConfidence * 100).toFixed(0)}% Match`;
    } else if (item.matchConfidence >= 0.5) {
      badge.className += ' confidence-medium';
      badge.textContent = `${(item.matchConfidence * 100).toFixed(0)}% Match`;
    } else {
      badge.className += ' confidence-low';
      badge.textContent = 'Manual Review';
    }
    card.appendChild(badge);

    // RAW OCR LINE (for context)
    const rawLine = document.createElement('div');
    rawLine.style.cssText = 'background: var(--gray-200); padding: 8px; margin-bottom: 12px; font-family: monospace; font-size: 11px; border-left: 3px solid var(--primary-blue);';
    rawLine.innerHTML = `<strong>OCR Text:</strong> ${item.rawOcrLine}`;
    card.appendChild(rawLine);

    // Item content - ALL FIELDS EDITABLE
    const itemGrid = document.createElement('div');
    itemGrid.className = 'item-grid';
    itemGrid.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 1fr'; // Added column for Qty Shipped

    // Name field
    const nameGroup = createEditableField('Name (detected)', item.detectedName, (value) => {
      item.correctedName = value;
    });

    // Quantity ORDERED field
    const qtyOrderedGroup = createEditableField('Qty Ordered', item.detectedQuantity, (value) => {
      item.correctedQuantity = parseFloat(value) || null;
    }, 'number');

    // Quantity SHIPPED field (NEW!)
    const qtyShippedGroup = createEditableField('Qty Shipped', item.detectedQuantityShipped || '', (value) => {
      item.correctedQuantityShipped = parseFloat(value) || null;
    }, 'number');

    // Unit field
    const unitGroup = createEditableField('Unit', item.detectedUnit || '', (value) => {
      item.correctedUnit = value;
    });

    // Price field
    const priceGroup = createEditableField('Price', item.detectedPrice || '', (value) => {
      item.correctedPrice = parseFloat(value) || null;
    }, 'number');

    itemGrid.appendChild(nameGroup);
    itemGrid.appendChild(qtyOrderedGroup);
    itemGrid.appendChild(qtyShippedGroup);
    itemGrid.appendChild(unitGroup);
    itemGrid.appendChild(priceGroup);

    card.appendChild(itemGrid);

    // INVENTORY MATCHING SECTION (ALWAYS SHOW - even for auto-matched)
    const matchingSection = document.createElement('div');
    matchingSection.style.cssText = 'margin-top: 16px; padding-top: 16px; border-top: 2px solid var(--gray-300);';

    const matchLabel = document.createElement('label');
    matchLabel.className = 'form-label';
    matchLabel.textContent = item.matchedItemName ? 'Auto-matched to (you can change):' : 'Match to inventory item:';
    matchLabel.style.marginBottom = '8px';

    const matchSelect = document.createElement('select');
    matchSelect.className = 'form-select';
    matchSelect.style.marginBottom = '8px';

    // Add options
    const skipOption = document.createElement('option');
    skipOption.value = '__SKIP__';
    skipOption.textContent = '-- Skip this item (not important) --';
    matchSelect.appendChild(skipOption);

    const noneOption = document.createElement('option');
    noneOption.value = '';
    noneOption.textContent = '-- Select inventory item --';
    matchSelect.appendChild(noneOption);

    state.inventoryItems.forEach(invItem => {
      const option = document.createElement('option');
      option.value = invItem.id;
      option.textContent = `${invItem.item_name} (${invItem.vendor}) - ${invItem.unit}`;

      // Pre-select if auto-matched
      if (item.matchedInventoryId === invItem.id) {
        option.selected = true;
      }

      matchSelect.appendChild(option);
    });

    matchSelect.addEventListener('change', (e) => {
      if (e.target.value === '__SKIP__') {
        // Skip this item
        item.skipped = true;
        card.style.display = 'none';
        console.log(`Skipped item: "${item.detectedName}"`);

        // Update count
        const visibleItems = state.detectedItems.filter(i => !i.skipped);
        document.getElementById('itemCount').textContent = visibleItems.length;
      } else {
        const selectedId = parseInt(e.target.value);
        if (selectedId) {
          const invItem = state.inventoryItems.find(i => i.id === selectedId);
          if (invItem) {
            item.matchedInventoryId = invItem.id;
            item.matchedItemName = invItem.item_name;
            item.matchedVendor = invItem.vendor;
            item.matchConfidence = 1.0;
            console.log(`Manual match: "${item.detectedName}" â†’ "${invItem.item_name}"`);

            // Update badge
            badge.className = 'confidence-badge confidence-high';
            badge.textContent = '100% Match';
            card.classList.remove('needs-review');
            card.classList.add('corrected');
          }
        } else {
          // Cleared selection
          item.matchedInventoryId = null;
          item.matchedItemName = null;
          item.matchedVendor = null;
          item.matchConfidence = 0;
        }
      }
    });

    matchingSection.appendChild(matchLabel);
    matchingSection.appendChild(matchSelect);

    // FIELD POSITION LEARNING SECTION (ADVANCED)
    const positionSection = document.createElement('details');
    positionSection.style.cssText = 'margin-top: 12px; padding: 12px; background: var(--light-blue); border: 1px solid var(--primary-blue);';

    const positionSummary = document.createElement('summary');
    positionSummary.style.cssText = 'cursor: pointer; font-size: 11px; font-weight: 700; color: var(--primary-blue); text-transform: uppercase; letter-spacing: 0.5px;';
    positionSummary.textContent = 'Teach Field Positions (Advanced)';

    const positionContent = document.createElement('div');
    positionContent.style.cssText = 'margin-top: 12px; font-size: 12px;';
    positionContent.innerHTML = `
      <p style="margin-bottom: 8px; color: var(--gray-700);">
        Help the system learn WHERE to find each field in future invoices:
      </p>
      <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 8px; font-size: 11px;">
        <strong>Name position:</strong> <input type="text" placeholder="e.g., 'start of line'" value="${item.namePosition || ''}" onchange="state.detectedItems[${index}].namePosition = this.value" style="padding: 4px; border: 1px solid var(--gray-300);">
        <strong>Qty position:</strong> <input type="text" placeholder="e.g., 'before name'" value="${item.qtyPosition || ''}" onchange="state.detectedItems[${index}].qtyPosition = this.value" style="padding: 4px; border: 1px solid var(--gray-300);">
        <strong>Unit position:</strong> <input type="text" placeholder="e.g., 'after name'" value="${item.unitPosition || ''}" onchange="state.detectedItems[${index}].unitPosition = this.value" style="padding: 4px; border: 1px solid var(--gray-300);">
        <strong>Price position:</strong> <input type="text" placeholder="e.g., 'end of line'" value="${item.pricePosition || ''}" onchange="state.detectedItems[${index}].pricePosition = this.value" style="padding: 4px; border: 1px solid var(--gray-300);">
      </div>
      <p style="margin-top: 8px; font-size: 10px; color: var(--gray-600); font-style: italic;">
        Examples: "start of line", "before name", "after qty", "end of line", "column 3"
      </p>
    `;

    positionSection.appendChild(positionSummary);
    positionSection.appendChild(positionContent);
    matchingSection.appendChild(positionSection);

    card.appendChild(matchingSection);

    // ACTION BUTTONS
    const actionButtons = document.createElement('div');
    actionButtons.style.cssText = 'display: flex; gap: 8px; margin-top: 12px; justify-content: flex-end;';

    const skipBtn = document.createElement('button');
    skipBtn.className = 'btn';
    skipBtn.textContent = 'Skip Item';
    skipBtn.style.cssText = 'background: var(--gray-300); border-color: var(--gray-400); font-size: 11px; padding: 8px 16px;';
    skipBtn.onclick = () => {
      item.skipped = true;
      card.style.display = 'none';
      console.log(`Skipped item: "${item.detectedName}"`);

      // Update count
      const visibleItems = state.detectedItems.filter(i => !i.skipped);
      document.getElementById('itemCount').textContent = visibleItems.length;
    };

    actionButtons.appendChild(skipBtn);
    card.appendChild(actionButtons);

    itemsList.appendChild(card);
  });

  // Update visible count
  const visibleItems = items.filter(i => !i.skipped);
  document.getElementById('itemCount').textContent = visibleItems.length;
}

function createEditableField(label, value, onChange, type = 'text') {
  const group = document.createElement('div');
  group.className = 'form-group';

  const labelEl = document.createElement('label');
  labelEl.className = 'form-label';
  labelEl.textContent = label;

  const input = document.createElement('input');
  input.type = type;
  input.className = 'form-input';
  input.value = value || '';
  input.style.fontSize = '13px';
  input.style.padding = '8px';

  input.addEventListener('change', (e) => onChange(e.target.value));

  group.appendChild(labelEl);
  group.appendChild(input);

  return group;
}

window.acceptMatch = function(index) {
  const item = state.detectedItems[index];
  // Already matched in state, just re-render to show as accepted
  displayItems(state.detectedItems);
};

// ============================================
// CREATE TRAINING SESSION
// ============================================
async function createTrainingSession(ocrText, avgConfidence, itemsDetected) {
  try {
    const vendor = document.getElementById('vendorSelect').value || null;
    const docType = document.getElementById('docTypeSelect').value;
    const docDate = document.getElementById('docDate').value || null;

    const imageMetadata = {
      fileSize: state.currentImage.length,
      timestamp: new Date().toISOString()
    };

    const { data, error } = await supabase
      .from('ocr_training_sessions')
      .insert({
        vendor,
        document_type: docType,
        document_date: docDate,
        image_metadata: imageMetadata,
        raw_ocr_text: ocrText,
        ocr_confidence: avgConfidence,
        items_detected: itemsDetected,
        status: 'in_progress'
      })
      .select()
      .single();

    if (error) throw error;

    state.currentSession = data;
    console.log('Training session created:', data.id);

  } catch (error) {
    console.error('Error creating session:', error);
  }
}

// ============================================
// SAVE TRAINING DATA (THE LEARNING ENGINE!)
// ============================================
async function saveTrainingData() {
  if (!state.currentSession) {
    alert('No active training session!');
    return;
  }

  try {
    console.log('Saving training data...');

    const corrections = [];
    const learnedPatterns = [];

    const vendor = document.getElementById('vendorSelect').value;

    // Process each item
    for (const item of state.detectedItems) {
      // Determine what was corrected
      const nameCorrected = item.correctedName && item.correctedName !== item.detectedName;
      const qtyCorrected = item.correctedQuantity !== null && item.correctedQuantity !== item.detectedQuantity;
      const priceCorrected = item.correctedPrice !== null && item.correctedPrice !== item.detectedPrice;
      const unitCorrected = item.correctedUnit && item.correctedUnit !== item.detectedUnit;

      let correctionType = 'no_change';
      if (nameCorrected && qtyCorrected && priceCorrected) {
        correctionType = 'full_match';
      } else if (nameCorrected) {
        correctionType = 'name_only';
      } else if (qtyCorrected) {
        correctionType = 'quantity_only';
      } else if (priceCorrected) {
        correctionType = 'price_only';
      } else if (unitCorrected) {
        correctionType = 'unit_only';
      }

      // Get context (lines before/after)
      const ocrLines = state.ocrResult.data.text.split('\n');
      const lineNum = item.detectedLineNumber;
      const contextBefore = ocrLines.slice(Math.max(0, lineNum - 2), lineNum).join('\n');
      const contextAfter = ocrLines.slice(lineNum + 1, Math.min(ocrLines.length, lineNum + 3)).join('\n');

      // Skip if item was skipped
      if (item.skipped) {
        console.log(`Skipping: "${item.detectedName}" (marked as skipped)`);
        continue;
      }

      // Create correction record
      const correction = {
        session_id: state.currentSession.id,
        detected_name: item.detectedName,
        // OLD fields (keep for backward compatibility)
        detected_quantity: item.detectedQuantity,
        corrected_quantity: item.correctedQuantity !== null ? item.correctedQuantity : item.detectedQuantity,
        // NEW fields (QTY ORDERED vs QTY RECEIVED)
        detected_quantity_ordered: item.detectedQuantity,
        detected_quantity_received: item.detectedQuantityShipped || item.detectedQuantity,
        corrected_quantity_ordered: item.correctedQuantity !== null ? item.correctedQuantity : item.detectedQuantity,
        corrected_quantity_received: item.correctedQuantityShipped !== null ? item.correctedQuantityShipped : (item.detectedQuantityShipped || item.detectedQuantity),
        detected_price: item.detectedPrice,
        detected_unit: item.detectedUnit,
        detected_line_number: item.detectedLineNumber,
        detected_confidence: item.detectedConfidence,
        corrected_name: item.correctedName || item.detectedName,
        corrected_price: item.correctedPrice !== null ? item.correctedPrice : item.detectedPrice,
        corrected_unit: item.correctedUnit || item.detectedUnit,
        matched_inventory_id: item.matchedInventoryId,
        correction_type: correctionType,
        vendor: vendor,
        raw_ocr_line: item.rawOcrLine,
        context_before: contextBefore,
        context_after: contextAfter,
        line_position: lineNum / ocrLines.length,
        was_auto_matched: item.matchConfidence > 0,
        user_time_spent_ms: Date.now() - state.sessionStartTime,
        metadata: {
          // POSITION LEARNING DATA
          namePosition: item.namePosition || null,
          qtyPosition: item.qtyPosition || null,
          unitPosition: item.unitPosition || null,
          pricePosition: item.pricePosition || null,
          // Additional context for learning
          rawLineLength: item.rawOcrLine.length,
          lineIndex: lineNum,
          totalLines: ocrLines.length
        }
      };

      corrections.push(correction);

      // LEARNING: Extract patterns from corrections
      // Learn from BOTH auto-matches AND manual name edits
      if (item.matchedInventoryId) {
        let ocrVariation = null;
        let learnedFrom = null;

        // Case 1: Auto-matched with different detected name (existing logic)
        if (item.detectedName !== item.matchedItemName) {
          ocrVariation = item.detectedName;
          learnedFrom = 'auto-match';
        }
        // Case 2: User manually edited the name field (NEW!)
        else if (item.correctedName && item.correctedName !== item.detectedName) {
          ocrVariation = item.detectedName; // Original OCR text
          learnedFrom = 'manual-edit';
        }

        if (ocrVariation) {
          const pattern = {
            vendor: vendor,
            pattern_type: 'item_alias',
            pattern_text: `"${ocrVariation}" should be "${item.matchedItemName}"`,
            ocr_variation: ocrVariation,
            canonical_name: item.matchedItemName,
            inventory_item_id: item.matchedInventoryId,
            times_seen: 1,
            times_successful: 1,
            times_failed: 0,
            metadata: {
              first_seen: new Date().toISOString(),
              context: item.rawOcrLine,
              learned_from: learnedFrom // Track how this was learned
            }
          };

          learnedPatterns.push(pattern);
          console.log(`ðŸ“š Learned pattern (${learnedFrom}): "${ocrVariation}" â†’ "${item.matchedItemName}"`);
        }
      }
    }

    // Save corrections to database
    if (corrections.length > 0) {
      const { data: savedCorrections, error: corrError } = await supabase
        .from('ocr_training_corrections')
        .insert(corrections)
        .select();

      if (corrError) throw corrError;

      console.log(`âœ… Saved ${savedCorrections.length} corrections`);
    }

    // Save learned patterns
    for (const pattern of learnedPatterns) {
      // Check if this pattern already exists
      const { data: existing } = await supabase
        .from('ocr_learned_patterns')
        .select('*')
        .eq('vendor', pattern.vendor)
        .eq('ocr_variation', pattern.ocr_variation)
        .eq('canonical_name', pattern.canonical_name)
        .single();

      if (existing) {
        // Pattern exists - update statistics
        await supabase
          .from('ocr_learned_patterns')
          .update({
            times_seen: existing.times_seen + 1,
            times_successful: existing.times_successful + 1,
            updated_at: new Date().toISOString()
          })
          .eq('id', existing.id);

        console.log(`ðŸ“ˆ Updated existing pattern (seen ${existing.times_seen + 1} times)`);
      } else {
        // New pattern - insert
        const { error: patternError } = await supabase
          .from('ocr_learned_patterns')
          .insert(pattern);

        if (patternError) {
          console.error('Error saving pattern:', patternError);
        } else {
          console.log(`âœ¨ Created new pattern`);
        }
      }
    }

    // Update session status
    await supabase
      .from('ocr_training_sessions')
      .update({
        status: 'completed',
        completed_at: new Date().toISOString(),
        items_corrected: corrections.length,
        processing_time_ms: Date.now() - state.sessionStartTime
      })
      .eq('id', state.currentSession.id);

    // Refresh stats
    await loadStats();

    // Show success message
    const itemsList = document.getElementById('itemsList');
    itemsList.innerHTML = `
      <div class="success-message">
        <strong>Training data saved successfully!</strong><br>
        ${corrections.length} corrections saved<br>
        ${learnedPatterns.length} new patterns learned<br><br>
        The system will use this data to improve future OCR accuracy!
      </div>
      <button class="btn btn-primary" onclick="location.reload()">
        Train Another Invoice
      </button>
    `;

    // Display learned patterns
    displayLearnedPatterns(learnedPatterns);

  } catch (error) {
    console.error('Error saving training data:', error);
    alert('Failed to save training data: ' + error.message);
  }
}

// ============================================
// DISPLAY LEARNED PATTERNS
// ============================================
function displayLearnedPatterns(patterns) {
  const container = document.getElementById('learnedPatternsList');

  if (patterns.length === 0) {
    container.innerHTML = '<p style="color: var(--gray-600); font-size: 13px;">No new patterns learned in this session.</p>';
    return;
  }

  container.innerHTML = '<p style="font-size: 13px; font-weight: 600; margin-bottom: 12px; color: var(--primary-blue);">New patterns learned this session:</p>';

  patterns.forEach(pattern => {
    const patternDiv = document.createElement('div');
    patternDiv.className = 'learned-pattern';
    patternDiv.innerHTML = `
      <strong>Item Alias:</strong> "${pattern.ocr_variation}" â†’ "${pattern.canonical_name}"<br>
      <small>Vendor: ${pattern.vendor} | Type: ${pattern.pattern_type}</small>
    `;
    container.appendChild(patternDiv);
  });
}

</script>

</body>
</html>
