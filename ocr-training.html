<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, viewport-fit=cover">
  <title>OCR Training System - Jayna Gyro</title>

  <link rel="apple-touch-icon" href="https://static.spotapps.co/website_images/ab_websites/229800_website_v1/logo.png">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#00A8E1">

  <!-- External Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>

  <style>
    /* Jayna Brand Design - Sky Blue & Grayscale */
    :root {
      --primary-blue: #00A8E1;
      --secondary-blue: #0094D6;
      --light-blue: #E3F4FC;
      --accent-blue: #0081C6;
      --gray-900: #212121;
      --gray-700: #424242;
      --gray-600: #616161;
      --gray-500: #757575;
      --gray-400: #BDBDBD;
      --gray-300: #E0E0E0;
      --gray-100: #F5F5F5;
      --success: #00C853;
      --warning: #FFB300;
      --error: #D32F2F;
      --white: #FFFFFF;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      font-family: 'Aptos', 'Segoe UI Variable', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background: var(--white);
      min-height: 100vh;
      padding: 0;
      overflow-x: hidden;
      overflow-y: auto;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      background: linear-gradient(135deg, var(--primary-blue), var(--secondary-blue));
      color: var(--white);
      padding: 24px;
      border-radius: 0;
      margin-bottom: 20px;
      text-align: center;
    }

    .header h1 {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .header p {
      opacity: 0.9;
      font-size: 13px;
      font-weight: 500;
    }

    .stats-bar {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin-bottom: 20px;
    }

    .stat-card {
      background: var(--gray-100);
      border: 2px solid var(--gray-300);
      padding: 16px;
      text-align: center;
    }

    .stat-value {
      font-size: 28px;
      font-weight: 700;
      color: var(--primary-blue);
      margin-bottom: 4px;
    }

    .stat-label {
      font-size: 11px;
      font-weight: 700;
      color: var(--gray-600);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    @media (max-width: 900px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: var(--white);
      border: 2px solid var(--gray-300);
      padding: 20px;
    }

    .panel-header {
      font-size: 14px;
      font-weight: 700;
      color: var(--gray-900);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 2px solid var(--gray-300);
    }

    .upload-zone {
      border: 3px dashed var(--gray-300);
      padding: 40px 20px;
      text-align: center;
      margin-bottom: 20px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .upload-zone:hover {
      border-color: var(--primary-blue);
      background: var(--light-blue);
    }

    .upload-zone.active {
      border-color: var(--primary-blue);
      background: var(--light-blue);
    }

    .upload-icon {
      font-size: 48px;
      color: var(--gray-400);
      margin-bottom: 12px;
    }

    .btn {
      padding: 12px 24px;
      border: 2px solid var(--gray-300);
      background: var(--gray-100);
      color: var(--gray-900);
      font-size: 13px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      cursor: pointer;
      transition: all 0.15s ease;
      display: inline-block;
      margin: 4px;
    }

    .btn:hover {
      background: var(--gray-300);
      transform: translateY(-1px);
    }

    .btn-primary {
      background: var(--primary-blue);
      border-color: var(--primary-blue);
      color: var(--white);
    }

    .btn-primary:hover {
      background: var(--secondary-blue);
      border-color: var(--secondary-blue);
    }

    .btn-success {
      background: var(--success);
      border-color: var(--success);
      color: var(--white);
    }

    .btn-success:hover {
      background: #00A843;
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-label {
      display: block;
      font-size: 11px;
      font-weight: 700;
      color: var(--gray-700);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }

    .form-input, .form-select {
      width: 100%;
      padding: 12px;
      border: 2px solid var(--gray-300);
      background: var(--white);
      font-size: 14px;
      font-weight: 400;
    }

    .form-input:focus, .form-select:focus {
      outline: none;
      border-color: var(--primary-blue);
    }

    .item-card {
      background: var(--gray-100);
      border: 2px solid var(--gray-300);
      padding: 16px;
      margin-bottom: 12px;
      position: relative;
    }

    .item-card.corrected {
      border-color: var(--success);
      background: #E8F5E9;
    }

    .item-card.needs-review {
      border-color: var(--warning);
      background: #FFF8E1;
    }

    .confidence-badge {
      position: absolute;
      top: 12px;
      right: 12px;
      padding: 4px 10px;
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-radius: 0;
    }

    .confidence-high {
      background: var(--success);
      color: var(--white);
    }

    .confidence-medium {
      background: var(--warning);
      color: var(--gray-900);
    }

    .confidence-low {
      background: var(--error);
      color: var(--white);
    }

    .item-grid {
      display: grid;
      grid-template-columns: 2fr 1fr 1fr 1fr;
      gap: 12px;
      margin-bottom: 12px;
    }

    @media (max-width: 600px) {
      .item-grid {
        grid-template-columns: 1fr;
      }
    }

    .learned-pattern {
      background: var(--light-blue);
      border: 1px solid var(--primary-blue);
      padding: 12px;
      margin-bottom: 8px;
      font-size: 12px;
    }

    .learned-pattern strong {
      color: var(--primary-blue);
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: var(--gray-600);
    }

    .spinner {
      border: 3px solid var(--gray-300);
      border-top: 3px solid var(--primary-blue);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 16px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .preview-image {
      max-width: 100%;
      border: 2px solid var(--gray-300);
      margin-bottom: 16px;
    }

    .ocr-text {
      background: var(--gray-100);
      border: 1px solid var(--gray-300);
      padding: 12px;
      font-family: monospace;
      font-size: 11px;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
      margin-bottom: 16px;
    }

    .success-message {
      background: #E8F5E9;
      border: 2px solid var(--success);
      color: #1B5E20;
      padding: 16px;
      margin-bottom: 20px;
      font-weight: 600;
    }

    .error-message {
      background: #FFEBEE;
      border: 2px solid var(--error);
      color: #B71C1C;
      padding: 16px;
      margin-bottom: 20px;
      font-weight: 600;
    }

    .match-suggestion {
      background: var(--light-blue);
      border-left: 4px solid var(--primary-blue);
      padding: 8px 12px;
      margin-top: 8px;
      font-size: 12px;
    }

    .match-suggestion a {
      color: var(--primary-blue);
      font-weight: 700;
      cursor: pointer;
      text-decoration: underline;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>

<div class="container">
  <!-- Header -->
  <div class="header">
    <h1>OCR Training System</h1>
    <p>Train the system to recognize invoices and orders more accurately</p>
  </div>

  <!-- Stats Bar -->
  <div class="stats-bar">
    <div class="stat-card">
      <div class="stat-value" id="statSessions">0</div>
      <div class="stat-label">Training Sessions</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="statCorrections">0</div>
      <div class="stat-label">Corrections Made</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="statPatterns">0</div>
      <div class="stat-label">Patterns Learned</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="statVendors">0</div>
      <div class="stat-label">Vendor Templates</div>
    </div>
  </div>

  <!-- Main Grid -->
  <div class="main-grid">
    <!-- Left Panel: Upload & OCR -->
    <div class="panel">
      <div class="panel-header">1. Upload Invoice/Order</div>

      <div class="upload-zone" id="uploadZone">
        <div class="upload-icon">ðŸ“„</div>
        <p style="font-size: 14px; font-weight: 600; margin-bottom: 8px;">
          Click to upload or drag & drop
        </p>
        <p style="font-size: 12px; color: var(--gray-600);">
          Supports: JPG, PNG, PDF
        </p>
        <input type="file" id="fileInput" accept="image/*,application/pdf" style="display: none;">
      </div>

      <div class="form-group">
        <label class="form-label">Vendor (optional - will auto-detect)</label>
        <select class="form-select" id="vendorSelect">
          <option value="">Auto-detect from items...</option>
        </select>
      </div>

      <div class="form-group">
        <label class="form-label">Document Type</label>
        <select class="form-select" id="docTypeSelect">
          <option value="invoice">Invoice</option>
          <option value="order">Order</option>
        </select>
      </div>

      <div class="form-group">
        <label class="form-label">Document Date (optional)</label>
        <input type="date" class="form-input" id="docDate">
      </div>

      <button class="btn btn-primary" id="processBtn" disabled>
        Process with OCR
      </button>

      <!-- Preview -->
      <div id="previewSection" class="hidden">
        <div class="panel-header" style="margin-top: 20px;">Image Preview</div>
        <img id="previewImage" class="preview-image" alt="Preview">

        <div class="panel-header">Raw OCR Text</div>
        <div class="ocr-text" id="ocrText"></div>
      </div>
    </div>

    <!-- Right Panel: Detected Items -->
    <div class="panel">
      <div class="panel-header">2. Review & Correct Items</div>

      <div id="loadingSection" class="hidden">
        <div class="loading">
          <div class="spinner"></div>
          <p>Processing with OCR...</p>
        </div>
      </div>

      <div id="itemsSection" class="hidden">
        <p style="margin-bottom: 16px; font-size: 13px; color: var(--gray-600);">
          <strong id="itemCount">0</strong> items detected.
          Review and correct as needed.
        </p>
        <div id="itemsList"></div>

        <button class="btn btn-success" id="saveTrainingBtn" style="width: 100%; margin-top: 20px;">
          Save Training Data
        </button>
      </div>

      <div id="emptyState" style="text-align: center; padding: 60px 20px; color: var(--gray-500);">
        <div style="font-size: 64px; margin-bottom: 16px;">ðŸŽ“</div>
        <p style="font-size: 14px; font-weight: 600;">Upload an invoice to start training</p>
      </div>
    </div>
  </div>

  <!-- Learned Patterns Panel -->
  <div class="panel">
    <div class="panel-header">Learned Patterns (Real-Time Feedback)</div>
    <div id="learnedPatternsList">
      <p style="color: var(--gray-600); font-size: 13px;">
        No patterns learned yet. Start training to see what the system learns!
      </p>
    </div>
  </div>
</div>

<script>
// ============================================
// CONFIGURATION
// ============================================
const SUPABASE_URL = 'https://gaawtbqpnnbbnsyswqwv.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdhYXd0YnFwbm5iYm5zeXN3cXd2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDE1NTAsImV4cCI6MjA3MjA3NzU1MH0.F-y7AIQTWaUe7DRT4OnIZVn94mhXxfhpBbng2aJ8nXg';

// Initialize Supabase
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// ============================================
// STATE
// ============================================
const state = {
  currentSession: null,
  currentImage: null,
  ocrResult: null,
  detectedItems: [],
  inventoryItems: [],
  vendors: [],
  corrections: [],
  sessionStartTime: null
};

// ============================================
// INITIALIZATION
// ============================================
document.addEventListener('DOMContentLoaded', async () => {
  console.log('OCR Training System initialized');

  await loadInventoryItems();
  await loadVendors();
  await loadStats();

  setupEventListeners();
});

async function loadInventoryItems() {
  try {
    const { data, error } = await supabase
      .from('inventory_items')
      .select('id, item_name, vendor, unit, par_level')
      .order('item_name');

    if (error) throw error;

    state.inventoryItems = data || [];
    console.log(`Loaded ${state.inventoryItems.length} inventory items`);
  } catch (error) {
    console.error('Error loading inventory:', error);
  }
}

async function loadVendors() {
  const uniqueVendors = [...new Set(state.inventoryItems.map(item => item.vendor))];
  state.vendors = uniqueVendors.filter(v => v).sort();

  const vendorSelect = document.getElementById('vendorSelect');
  state.vendors.forEach(vendor => {
    const option = document.createElement('option');
    option.value = vendor;
    option.textContent = vendor;
    vendorSelect.appendChild(option);
  });

  console.log(`Loaded ${state.vendors.length} vendors`);
}

async function loadStats() {
  try {
    // Load session count
    const { count: sessions } = await supabase
      .from('ocr_training_sessions')
      .select('*', { count: 'exact', head: true });

    // Load correction count
    const { count: corrections } = await supabase
      .from('ocr_training_corrections')
      .select('*', { count: 'exact', head: true });

    // Load pattern count
    const { count: patterns } = await supabase
      .from('ocr_learned_patterns')
      .select('*', { count: 'exact', head: true })
      .eq('is_active', true);

    // Load vendor template count
    const { count: vendors } = await supabase
      .from('ocr_vendor_templates')
      .select('*', { count: 'exact', head: true });

    document.getElementById('statSessions').textContent = sessions || 0;
    document.getElementById('statCorrections').textContent = corrections || 0;
    document.getElementById('statPatterns').textContent = patterns || 0;
    document.getElementById('statVendors').textContent = vendors || 0;
  } catch (error) {
    console.error('Error loading stats:', error);
  }
}

// ============================================
// EVENT LISTENERS
// ============================================
function setupEventListeners() {
  const uploadZone = document.getElementById('uploadZone');
  const fileInput = document.getElementById('fileInput');
  const processBtn = document.getElementById('processBtn');
  const saveTrainingBtn = document.getElementById('saveTrainingBtn');

  // Upload zone click
  uploadZone.addEventListener('click', () => fileInput.click());

  // File selection
  fileInput.addEventListener('change', handleFileSelect);

  // Drag and drop
  uploadZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    uploadZone.classList.add('active');
  });

  uploadZone.addEventListener('dragleave', () => {
    uploadZone.classList.remove('active');
  });

  uploadZone.addEventListener('drop', (e) => {
    e.preventDefault();
    uploadZone.classList.remove('active');

    if (e.dataTransfer.files.length > 0) {
      fileInput.files = e.dataTransfer.files;
      handleFileSelect({ target: fileInput });
    }
  });

  // Process button
  processBtn.addEventListener('click', processWithOCR);

  // Save training button
  saveTrainingBtn.addEventListener('click', saveTrainingData);
}

// ============================================
// FILE HANDLING
// ============================================
function handleFileSelect(event) {
  const file = event.target.files[0];
  if (!file) return;

  console.log('File selected:', file.name);

  const reader = new FileReader();
  reader.onload = (e) => {
    state.currentImage = e.target.result;
    document.getElementById('previewImage').src = state.currentImage;
    document.getElementById('previewSection').classList.remove('hidden');
    document.getElementById('processBtn').disabled = false;
  };
  reader.readAsDataURL(file);
}

// ============================================
// OCR PROCESSING
// ============================================
async function processWithOCR() {
  if (!state.currentImage) return;

  state.sessionStartTime = Date.now();

  // Show loading
  document.getElementById('loadingSection').classList.remove('hidden');
  document.getElementById('emptyState').classList.add('hidden');
  document.getElementById('itemsSection').classList.add('hidden');

  try {
    console.log('Starting OCR processing...');

    const result = await Tesseract.recognize(
      state.currentImage,
      'eng',
      {
        logger: m => {
          if (m.status === 'recognizing text') {
            console.log(`OCR Progress: ${Math.round(m.progress * 100)}%`);
          }
        }
      }
    );

    state.ocrResult = result;
    const ocrText = result.data.text;
    const avgConfidence = result.data.confidence;

    console.log(`OCR Complete! Confidence: ${avgConfidence.toFixed(1)}%`);
    console.log('Extracted text length:', ocrText.length);

    // Display OCR text
    document.getElementById('ocrText').textContent = ocrText;

    // Extract items from OCR text
    const extractedItems = extractItemsFromOCR(ocrText, avgConfidence);

    console.log(`Extracted ${extractedItems.length} items`);

    // Auto-match items to inventory
    await autoMatchItems(extractedItems);

    // Detect vendor from matched items
    detectVendor(extractedItems);

    // Create training session
    await createTrainingSession(ocrText, avgConfidence, extractedItems.length);

    // Display items for review
    displayItems(extractedItems);

    // Hide loading, show items
    document.getElementById('loadingSection').classList.add('hidden');
    document.getElementById('itemsSection').classList.remove('hidden');

  } catch (error) {
    console.error('OCR Error:', error);
    alert('OCR processing failed: ' + error.message);
    document.getElementById('loadingSection').classList.add('hidden');
  }
}

// ============================================
// ITEM EXTRACTION (Reuse from index.html)
// ============================================
function extractItemsFromOCR(ocrText, avgConfidence) {
  const items = [];
  const lines = ocrText.split('\n').map(l => l.trim()).filter(l => l.length > 0);

  console.log(`Processing ${lines.length} OCR lines`);

  // Enhanced pattern to catch unit in the line
  const itemWithUnitPattern = /^[\s]*([0-9]+\.?[0-9]*)\s+(.+?)\s+(CS|EA|LB|KG|OZ|GAL|BT|CASE|EACH|POUND)\s+([0-9]+\.[0-9]{2})[\s]*$/i;
  const itemPattern = /^[\s]*([0-9]+\.?[0-9]*)\s+(.+?)\s+([0-9]+\.[0-9]{2})[\s]*$/;

  let patternMatchCount = 0;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmed = line.trim();
    if (trimmed.length < 5) continue;

    // Try unit-aware pattern first
    let match = trimmed.match(itemWithUnitPattern);
    let detectedUnit = null;

    if (match) {
      const quantity = parseFloat(match[1]);
      const name = match[2].trim();
      detectedUnit = match[3].toUpperCase();
      const price = parseFloat(match[4]);

      // Normalize unit names
      if (detectedUnit === 'CASE') detectedUnit = 'CS';
      if (detectedUnit === 'EACH') detectedUnit = 'EA';
      if (detectedUnit === 'POUND') detectedUnit = 'LB';

      if (quantity >= 0.25 && quantity <= 1000 && name.length > 2) {
        items.push({
          id: Date.now() + Math.random() + i,
          detectedName: name,
          detectedQuantity: quantity,
          detectedQuantityShipped: null,
          detectedUnit: detectedUnit,
          detectedPrice: price,
          detectedLineNumber: i,
          detectedConfidence: avgConfidence,
          rawOcrLine: line,
          matchedInventoryId: null,
          matchConfidence: 0,
          matchedItemName: null,
          matchedVendor: null,
          correctedName: null,
          correctedQuantity: null,
          correctedPrice: null,
          correctedUnit: null
        });
        patternMatchCount++;
        continue;
      }
    }

    // Try standard pattern (no unit in line)
    match = trimmed.match(itemPattern);
    if (match) {
      const quantity = parseFloat(match[1]);
      const name = match[2].trim();
      const price = parseFloat(match[3]);

      if (quantity >= 0.25 && quantity <= 1000 && name.length > 2) {
        items.push({
          id: Date.now() + Math.random() + i,
          detectedName: name,
          detectedQuantity: quantity,
          detectedQuantityShipped: null,
          detectedUnit: null,
          detectedPrice: price,
          detectedLineNumber: i,
          detectedConfidence: avgConfidence,
          rawOcrLine: line,
          matchedInventoryId: null,
          matchConfidence: 0,
          matchedItemName: null,
          matchedVendor: null,
          correctedName: null,
          correctedQuantity: null,
          correctedPrice: null,
          correctedUnit: null
        });
        patternMatchCount++;
      }
    }
  }

  console.log(`Pattern matching found ${patternMatchCount} items`);

  // If pattern matching found very few items, show all lines for manual matching
  if (patternMatchCount < 3 && lines.length > patternMatchCount) {
    console.log('Low pattern match count, showing all lines for manual review');

    for (let i = 0; i < lines.length; i++) {
      const trimmed = lines[i].trim();
      if (trimmed.length < 3) continue;
      if (items.find(item => item.rawOcrLine === lines[i])) continue;

      items.push({
        id: Date.now() + Math.random() + i,
        detectedName: trimmed,
        detectedQuantity: 1,
        detectedQuantityShipped: null,
        detectedUnit: null,
        detectedPrice: null,
        detectedLineNumber: i,
        detectedConfidence: avgConfidence,
        rawOcrLine: lines[i],
        matchedInventoryId: null,
        matchConfidence: 0,
        matchedItemName: null,
        matchedVendor: null,
        correctedName: null,
        correctedQuantity: null,
        correctedPrice: null,
        correctedUnit: null
      });
    }
  }

  state.detectedItems = items;
  return items;
}

// ============================================
// AUTO-MATCHING (with fuzzy logic)
// ============================================
async function autoMatchItems(items) {
  console.log('Starting auto-match process...');

  for (const item of items) {
    const bestMatch = findBestMatch(item.detectedName, state.inventoryItems);

    if (bestMatch && bestMatch.confidence >= 0.4) {
      item.matchedInventoryId = bestMatch.id;
      item.matchConfidence = bestMatch.confidence;
      item.matchedItemName = bestMatch.itemName;
      item.matchedVendor = bestMatch.vendor;

      // If unit wasn't detected, use inventory item's unit
      if (!item.detectedUnit && bestMatch.unit) {
        item.detectedUnit = bestMatch.unit;
      }

      console.log(`  âœ“ Matched "${item.detectedName}" â†’ "${bestMatch.itemName}" (${(bestMatch.confidence * 100).toFixed(0)}%)`);
    } else {
      console.log(`  âš ï¸ No match for "${item.detectedName}"`);
    }
  }
}

function findBestMatch(detectedName, inventoryItems) {
  let bestMatch = null;
  let highestConfidence = 0;

  const normalizedDetected = detectedName.toLowerCase().trim();

  for (const item of inventoryItems) {
    const normalizedInventory = item.item_name.toLowerCase().trim();

    // Exact match
    if (normalizedDetected === normalizedInventory) {
      return {
        id: item.id,
        itemName: item.item_name,
        vendor: item.vendor,
        unit: item.unit,
        confidence: 1.0
      };
    }

    // Contains match
    if (normalizedInventory.includes(normalizedDetected) || normalizedDetected.includes(normalizedInventory)) {
      const confidence = 0.85;
      if (confidence > highestConfidence) {
        highestConfidence = confidence;
        bestMatch = {
          id: item.id,
          itemName: item.item_name,
          vendor: item.vendor,
          unit: item.unit,
          confidence
        };
      }
    }

    // Fuzzy match (simple word overlap)
    const detectedWords = normalizedDetected.split(/\s+/);
    const inventoryWords = normalizedInventory.split(/\s+/);
    const matchingWords = detectedWords.filter(w => inventoryWords.some(iw => iw.includes(w) || w.includes(iw)));

    if (matchingWords.length > 0) {
      const confidence = matchingWords.length / Math.max(detectedWords.length, inventoryWords.length);
      if (confidence > highestConfidence && confidence >= 0.4) {
        highestConfidence = confidence;
        bestMatch = {
          id: item.id,
          itemName: item.item_name,
          vendor: item.vendor,
          unit: item.unit,
          confidence
        };
      }
    }
  }

  return bestMatch;
}

// ============================================
// VENDOR DETECTION
// ============================================
function detectVendor(items) {
  const vendorCounts = {};

  items.forEach(item => {
    if (item.matchedVendor) {
      vendorCounts[item.matchedVendor] = (vendorCounts[item.matchedVendor] || 0) + 1;
    }
  });

  let determinedVendor = null;
  let maxCount = 0;

  for (const [vendor, count] of Object.entries(vendorCounts)) {
    if (count > maxCount) {
      maxCount = count;
      determinedVendor = vendor;
    }
  }

  if (determinedVendor) {
    console.log(`ðŸ¢ Vendor auto-detected: ${determinedVendor} (${maxCount}/${items.length} items matched)`);
    document.getElementById('vendorSelect').value = determinedVendor;
  }
}

// ============================================
// DISPLAY ITEMS
// ============================================
function displayItems(items) {
  const itemsList = document.getElementById('itemsList');
  itemsList.innerHTML = '';

  document.getElementById('itemCount').textContent = items.length;

  items.forEach((item, index) => {
    const card = document.createElement('div');
    card.className = 'item-card';

    // Add status class
    if (item.matchConfidence >= 0.7) {
      card.classList.add('corrected');
    } else if (item.matchConfidence < 0.5) {
      card.classList.add('needs-review');
    }

    // Confidence badge
    const badge = document.createElement('div');
    badge.className = 'confidence-badge';
    if (item.matchConfidence >= 0.7) {
      badge.className += ' confidence-high';
      badge.textContent = `${(item.matchConfidence * 100).toFixed(0)}% Match`;
    } else if (item.matchConfidence >= 0.5) {
      badge.className += ' confidence-medium';
      badge.textContent = `${(item.matchConfidence * 100).toFixed(0)}% Match`;
    } else {
      badge.className += ' confidence-low';
      badge.textContent = 'Manual Review';
    }
    card.appendChild(badge);

    // Item content
    const itemGrid = document.createElement('div');
    itemGrid.className = 'item-grid';

    // Name field
    const nameGroup = createEditableField('Name', item.detectedName, (value) => {
      item.correctedName = value;
    });

    // Quantity field
    const qtyGroup = createEditableField('Qty', item.detectedQuantity, (value) => {
      item.correctedQuantity = parseFloat(value) || null;
    }, 'number');

    // Unit field
    const unitGroup = createEditableField('Unit', item.detectedUnit || '', (value) => {
      item.correctedUnit = value;
    });

    // Price field
    const priceGroup = createEditableField('Price', item.detectedPrice || '', (value) => {
      item.correctedPrice = parseFloat(value) || null;
    }, 'number');

    itemGrid.appendChild(nameGroup);
    itemGrid.appendChild(qtyGroup);
    itemGrid.appendChild(unitGroup);
    itemGrid.appendChild(priceGroup);

    card.appendChild(itemGrid);

    // Match suggestion
    if (item.matchedItemName) {
      const suggestion = document.createElement('div');
      suggestion.className = 'match-suggestion';
      suggestion.innerHTML = `
        Suggested match: <strong>${item.matchedItemName}</strong> (${item.matchedVendor})
        <a onclick="acceptMatch(${index})">Accept</a>
      `;
      card.appendChild(suggestion);
    } else {
      // Search inventory
      const searchGroup = document.createElement('div');
      searchGroup.className = 'form-group';
      searchGroup.style.marginTop = '12px';

      const label = document.createElement('label');
      label.className = 'form-label';
      label.textContent = 'Match to inventory item:';

      const select = document.createElement('select');
      select.className = 'form-select';

      const defaultOption = document.createElement('option');
      defaultOption.value = '';
      defaultOption.textContent = '-- Select inventory item --';
      select.appendChild(defaultOption);

      state.inventoryItems.forEach(invItem => {
        const option = document.createElement('option');
        option.value = invItem.id;
        option.textContent = `${invItem.item_name} (${invItem.vendor}) - ${invItem.unit}`;
        select.appendChild(option);
      });

      select.addEventListener('change', (e) => {
        const selectedId = parseInt(e.target.value);
        if (selectedId) {
          const invItem = state.inventoryItems.find(i => i.id === selectedId);
          if (invItem) {
            item.matchedInventoryId = invItem.id;
            item.matchedItemName = invItem.item_name;
            item.matchedVendor = invItem.vendor;
            item.matchConfidence = 1.0;
            console.log(`Manual match: "${item.detectedName}" â†’ "${invItem.item_name}"`);
          }
        }
      });

      searchGroup.appendChild(label);
      searchGroup.appendChild(select);
      card.appendChild(searchGroup);
    }

    itemsList.appendChild(card);
  });
}

function createEditableField(label, value, onChange, type = 'text') {
  const group = document.createElement('div');
  group.className = 'form-group';

  const labelEl = document.createElement('label');
  labelEl.className = 'form-label';
  labelEl.textContent = label;

  const input = document.createElement('input');
  input.type = type;
  input.className = 'form-input';
  input.value = value || '';
  input.style.fontSize = '13px';
  input.style.padding = '8px';

  input.addEventListener('change', (e) => onChange(e.target.value));

  group.appendChild(labelEl);
  group.appendChild(input);

  return group;
}

window.acceptMatch = function(index) {
  const item = state.detectedItems[index];
  // Already matched in state, just re-render to show as accepted
  displayItems(state.detectedItems);
};

// ============================================
// CREATE TRAINING SESSION
// ============================================
async function createTrainingSession(ocrText, avgConfidence, itemsDetected) {
  try {
    const vendor = document.getElementById('vendorSelect').value || null;
    const docType = document.getElementById('docTypeSelect').value;
    const docDate = document.getElementById('docDate').value || null;

    const imageMetadata = {
      fileSize: state.currentImage.length,
      timestamp: new Date().toISOString()
    };

    const { data, error } = await supabase
      .from('ocr_training_sessions')
      .insert({
        vendor,
        document_type: docType,
        document_date: docDate,
        image_metadata: imageMetadata,
        raw_ocr_text: ocrText,
        ocr_confidence: avgConfidence,
        items_detected: itemsDetected,
        status: 'in_progress'
      })
      .select()
      .single();

    if (error) throw error;

    state.currentSession = data;
    console.log('Training session created:', data.id);

  } catch (error) {
    console.error('Error creating session:', error);
  }
}

// ============================================
// SAVE TRAINING DATA (THE LEARNING ENGINE!)
// ============================================
async function saveTrainingData() {
  if (!state.currentSession) {
    alert('No active training session!');
    return;
  }

  try {
    console.log('Saving training data...');

    const corrections = [];
    const learnedPatterns = [];

    const vendor = document.getElementById('vendorSelect').value;

    // Process each item
    for (const item of state.detectedItems) {
      // Determine what was corrected
      const nameCorrected = item.correctedName && item.correctedName !== item.detectedName;
      const qtyCorrected = item.correctedQuantity !== null && item.correctedQuantity !== item.detectedQuantity;
      const priceCorrected = item.correctedPrice !== null && item.correctedPrice !== item.detectedPrice;
      const unitCorrected = item.correctedUnit && item.correctedUnit !== item.detectedUnit;

      let correctionType = 'no_change';
      if (nameCorrected && qtyCorrected && priceCorrected) {
        correctionType = 'full_match';
      } else if (nameCorrected) {
        correctionType = 'name_only';
      } else if (qtyCorrected) {
        correctionType = 'quantity_only';
      } else if (priceCorrected) {
        correctionType = 'price_only';
      } else if (unitCorrected) {
        correctionType = 'unit_only';
      }

      // Get context (lines before/after)
      const ocrLines = state.ocrResult.data.text.split('\n');
      const lineNum = item.detectedLineNumber;
      const contextBefore = ocrLines.slice(Math.max(0, lineNum - 2), lineNum).join('\n');
      const contextAfter = ocrLines.slice(lineNum + 1, Math.min(ocrLines.length, lineNum + 3)).join('\n');

      // Create correction record
      const correction = {
        session_id: state.currentSession.id,
        detected_name: item.detectedName,
        detected_quantity: item.detectedQuantity,
        detected_price: item.detectedPrice,
        detected_unit: item.detectedUnit,
        detected_line_number: item.detectedLineNumber,
        detected_confidence: item.detectedConfidence,
        corrected_name: item.correctedName || item.detectedName,
        corrected_quantity: item.correctedQuantity !== null ? item.correctedQuantity : item.detectedQuantity,
        corrected_price: item.correctedPrice !== null ? item.correctedPrice : item.detectedPrice,
        corrected_unit: item.correctedUnit || item.detectedUnit,
        matched_inventory_id: item.matchedInventoryId,
        correction_type: correctionType,
        vendor: vendor,
        raw_ocr_line: item.rawOcrLine,
        context_before: contextBefore,
        context_after: contextAfter,
        line_position: lineNum / ocrLines.length,
        was_auto_matched: item.matchConfidence > 0,
        user_time_spent_ms: Date.now() - state.sessionStartTime
      };

      corrections.push(correction);

      // LEARNING: Extract patterns from corrections
      if (item.matchedInventoryId && item.detectedName !== item.matchedItemName) {
        // This is a name alias pattern!
        const pattern = {
          vendor: vendor,
          pattern_type: 'item_alias',
          pattern_text: `"${item.detectedName}" should be "${item.matchedItemName}"`,
          ocr_variation: item.detectedName,
          canonical_name: item.matchedItemName,
          inventory_item_id: item.matchedInventoryId,
          times_seen: 1,
          times_successful: 1,
          times_failed: 0,
          metadata: {
            first_seen: new Date().toISOString(),
            context: item.rawOcrLine
          }
        };

        learnedPatterns.push(pattern);
        console.log(`ðŸ“š Learned pattern: "${item.detectedName}" â†’ "${item.matchedItemName}"`);
      }
    }

    // Save corrections to database
    if (corrections.length > 0) {
      const { data: savedCorrections, error: corrError } = await supabase
        .from('ocr_training_corrections')
        .insert(corrections)
        .select();

      if (corrError) throw corrError;

      console.log(`âœ… Saved ${savedCorrections.length} corrections`);
    }

    // Save learned patterns
    for (const pattern of learnedPatterns) {
      // Check if this pattern already exists
      const { data: existing } = await supabase
        .from('ocr_learned_patterns')
        .select('*')
        .eq('vendor', pattern.vendor)
        .eq('ocr_variation', pattern.ocr_variation)
        .eq('canonical_name', pattern.canonical_name)
        .single();

      if (existing) {
        // Pattern exists - update statistics
        await supabase
          .from('ocr_learned_patterns')
          .update({
            times_seen: existing.times_seen + 1,
            times_successful: existing.times_successful + 1,
            updated_at: new Date().toISOString()
          })
          .eq('id', existing.id);

        console.log(`ðŸ“ˆ Updated existing pattern (seen ${existing.times_seen + 1} times)`);
      } else {
        // New pattern - insert
        const { error: patternError } = await supabase
          .from('ocr_learned_patterns')
          .insert(pattern);

        if (patternError) {
          console.error('Error saving pattern:', patternError);
        } else {
          console.log(`âœ¨ Created new pattern`);
        }
      }
    }

    // Update session status
    await supabase
      .from('ocr_training_sessions')
      .update({
        status: 'completed',
        completed_at: new Date().toISOString(),
        items_corrected: corrections.length,
        processing_time_ms: Date.now() - state.sessionStartTime
      })
      .eq('id', state.currentSession.id);

    // Refresh stats
    await loadStats();

    // Show success message
    const itemsList = document.getElementById('itemsList');
    itemsList.innerHTML = `
      <div class="success-message">
        <strong>Training data saved successfully!</strong><br>
        ${corrections.length} corrections saved<br>
        ${learnedPatterns.length} new patterns learned<br><br>
        The system will use this data to improve future OCR accuracy!
      </div>
      <button class="btn btn-primary" onclick="location.reload()">
        Train Another Invoice
      </button>
    `;

    // Display learned patterns
    displayLearnedPatterns(learnedPatterns);

  } catch (error) {
    console.error('Error saving training data:', error);
    alert('Failed to save training data: ' + error.message);
  }
}

// ============================================
// DISPLAY LEARNED PATTERNS
// ============================================
function displayLearnedPatterns(patterns) {
  const container = document.getElementById('learnedPatternsList');

  if (patterns.length === 0) {
    container.innerHTML = '<p style="color: var(--gray-600); font-size: 13px;">No new patterns learned in this session.</p>';
    return;
  }

  container.innerHTML = '<p style="font-size: 13px; font-weight: 600; margin-bottom: 12px; color: var(--primary-blue);">New patterns learned this session:</p>';

  patterns.forEach(pattern => {
    const patternDiv = document.createElement('div');
    patternDiv.className = 'learned-pattern';
    patternDiv.innerHTML = `
      <strong>Item Alias:</strong> "${pattern.ocr_variation}" â†’ "${pattern.canonical_name}"<br>
      <small>Vendor: ${pattern.vendor} | Type: ${pattern.pattern_type}</small>
    `;
    container.appendChild(patternDiv);
  });
}

</script>

</body>
</html>
