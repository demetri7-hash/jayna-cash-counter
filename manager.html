<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, viewport-fit=cover">
  <title>Jayna Gyro Manager Portal</title>
  
  <link rel="apple-touch-icon" href="https://static.spotapps.co/website_images/ab_websites/229800_website_v1/logo.png">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#667eea">
  
  <!-- Chart.js for SalesChart component -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <!-- API Integration - Uses Vercel endpoints like index.html -->
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
      min-height: 100vh; 
      padding: 5px;
      overflow-x: hidden;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    .container { 
      max-width: 1200px; 
      margin: 0 auto; 
      background: white; 
      border-radius: 20px; 
      overflow: visible;
      box-shadow: 0 20px 40px rgba(0,0,0,0.1);
      min-height: auto;
      max-height: none;
    }
    
    .header { 
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); 
      color: white; 
      text-align: center; 
      padding: 20px; 
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .header h1 { 
      font-size: 24px; 
      font-weight: 700; 
      margin-bottom: 5px; 
    }
    
    .header p { 
      opacity: 0.9; 
      font-size: 14px; 
    }
    
    .header-info {
      text-align: left;
      flex: 1;
    }
    
    .nav-links {
      display: flex;
      gap: 15px;
      align-items: center;
    }
    
    .nav-link {
      color: white;
      text-decoration: none;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s ease;
      background: rgba(255,255,255,0.1);
    }
    
    .nav-link:hover {
      background: rgba(255,255,255,0.2);
      transform: translateY(-1px);
    }
    
    .content { 
      padding: 20px; 
      max-height: none;
      overflow: visible;
    }
    
    /* Component Cards */
    .dashboard-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }
    
    @media (min-width: 768px) {
      .dashboard-grid {
        grid-template-columns: 1fr 1fr;
      }
    }
    
    @media (min-width: 1024px) {
      .dashboard-grid {
        grid-template-columns: 2fr 1fr;
      }
    }
    
    .component-card {
      background: white;
      border-radius: 15px;
      border: 2px solid #e0e0e0;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      overflow: hidden;
      transition: all 0.3s ease;
    }
    
    .component-card:hover {
      border-color: #667eea;
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    }
    
    .card-header {
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      padding: 15px 20px;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .card-title {
      font-size: 18px;
      font-weight: 600;
      color: #333;
      margin: 0;
    }
    
    .card-subtitle {
      font-size: 12px;
      color: #666;
      margin: 0;
    }
    
    .card-body {
      padding: 20px;
    }
    
    .status-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: #666;
    }
    
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #22c55e;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    /* LiveMetrics Styles */
    .metrics-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }
    
    @media (min-width: 768px) {
      .metrics-grid {
        grid-template-columns: 1fr 1fr 1fr 1fr;
      }
    }
    
    .metric-card {
      padding: 15px;
      border-radius: 10px;
      border: 2px solid #e0e0e0;
      text-align: center;
      transition: all 0.3s ease;
    }
    
    .metric-card.normal { border-color: #3b82f6; background: #eff6ff; }
    .metric-card.good { border-color: #22c55e; background: #f0fdf4; }
    .metric-card.warning { border-color: #f59e0b; background: #fffbeb; }
    .metric-card.error { border-color: #ef4444; background: #fef2f2; }
    
    .metric-value {
      font-size: 24px;
      font-weight: bold;
      color: #333;
      margin-bottom: 5px;
    }
    
    .metric-label {
      font-size: 14px;
      font-weight: 600;
      color: #555;
      margin-bottom: 5px;
    }
    
    .metric-detail {
      font-size: 12px;
      color: #666;
    }
    
    /* StatsCards Styles */
    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }
    
    @media (min-width: 768px) {
      .stats-grid {
        grid-template-columns: 1fr 1fr 1fr 1fr;
      }
    }
    
    .stat-card {
      padding: 15px;
      border-radius: 10px;
      background: #f8f9fa;
      border: 1px solid #e9ecef;
      text-align: center;
    }
    
    .stat-value {
      font-size: 20px;
      font-weight: bold;
      color: #333;
      margin-bottom: 5px;
    }
    
    .stat-label {
      font-size: 12px;
      font-weight: 600;
      color: #555;
      margin-bottom: 5px;
    }
    
    .stat-change {
      font-size: 11px;
      font-weight: 500;
    }
    
    .stat-change.positive { color: #22c55e; }
    .stat-change.negative { color: #ef4444; }
    
    /* Chart Styles */
    .chart-container {
      position: relative;
      height: 300px;
      width: 100%;
    }
    
    .chart-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      justify-content: center;
    }
    
    .chart-btn {
      padding: 6px 12px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      background: white;
      color: #374151;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .chart-btn.active {
      background: #667eea;
      color: white;
      border-color: #667eea;
    }
    
    .chart-btn:hover {
      border-color: #667eea;
    }
    
    /* TopItems Styles */
    .items-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .item-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid #f0f0f0;
    }
    
    .item-row:last-child {
      border-bottom: none;
    }
    
    .item-info {
      flex: 1;
    }
    
    .item-name {
      font-weight: 600;
      color: #333;
      font-size: 14px;
    }
    
    .item-stats {
      font-size: 12px;
      color: #666;
    }
    
    .item-trend {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 12px;
    }
    
    .trend-up { color: #22c55e; }
    .trend-down { color: #ef4444; }
    .trend-stable { color: #6b7280; }
    
    /* RecentOrders Styles */
    .order-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid #f0f0f0;
      transition: background-color 0.2s ease;
    }
    
    .order-row:hover {
      background-color: #fafafa;
    }
    
    .order-row:last-child {
      border-bottom: none;
    }
    
    .order-info {
      flex: 1;
      min-width: 0;
    }
    
    .order-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
      flex-wrap: wrap;
    }
    
    .order-number {
      font-weight: 700;
      color: #333;
      font-size: 14px;
    }
    
    .order-customer {
      font-weight: 600;
      color: #555;
      font-size: 13px;
    }
    
    .order-time {
      font-size: 11px;
      color: #888;
      margin-left: auto;
    }
    
    .order-items {
      font-size: 12px;
      color: #666;
      margin-bottom: 4px;
      line-height: 1.4;
    }
    
    .order-details {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      color: #777;
    }
    
    .order-payment {
      background: #f3f4f6;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 500;
    }
    
    .order-notes {
      font-style: italic;
      color: #f59e0b;
    }
    
    .order-summary {
      text-align: right;
      min-width: 80px;
    }
    
    .order-total {
      font-weight: 700;
      color: #333;
      font-size: 16px;
      margin-bottom: 4px;
    }
    
    .order-status {
      font-size: 11px;
      font-weight: 600;
      padding: 3px 8px;
      border-radius: 4px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .order-status.open { color: #3b82f6; background: #eff6ff; }
    .order-status.processing { color: #f59e0b; background: #fffbeb; }
    .order-status.ready { color: #22c55e; background: #f0fdf4; }
    .order-status.completed { color: #6b7280; background: #f9fafb; }
    .order-status.voided { color: #ef4444; background: #fef2f2; }
    .order-status.cancelled { color: #ef4444; background: #fef2f2; }
    .order-status.unknown { color: #6b7280; background: #f3f4f6; }
    
    .no-orders {
      text-align: center;
      padding: 40px 20px;
      color: #9ca3af;
      font-style: italic;
    }

    /* Labor Analytics Dashboard Styles */
    .labor-analytics {
      grid-column: 1 / -1; /* Full width */
    }
    
    .labor-period-selector {
      display: flex;
      gap: 5px;
    }
    
    .period-btn {
      padding: 4px 12px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      background: white;
      color: #374151;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .period-btn.active {
      background: #667eea;
      color: white;
      border-color: #667eea;
    }
    
    .period-btn:hover {
      border-color: #667eea;
    }
    
    .labor-summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 25px;
    }
    
    .labor-summary-card {
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      padding: 15px;
      text-align: center;
      transition: all 0.3s ease;
    }
    
    .labor-summary-card:hover {
      border-color: #667eea;
      transform: translateY(-2px);
    }
    
    .labor-summary-card.warning {
      border-color: #f59e0b;
      background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
    }
    
    .labor-summary-card.success {
      border-color: #22c55e;
      background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
    }
    
    .labor-summary-card.danger {
      border-color: #ef4444;
      background: linear-gradient(135deg, #fef2f2 0%, #fecaca 100%);
    }
    
    .labor-summary-value {
      font-size: 24px;
      font-weight: bold;
      color: #333;
      margin-bottom: 5px;
    }
    
    .labor-summary-label {
      font-size: 12px;
      font-weight: 600;
      color: #555;
      margin-bottom: 5px;
    }
    
    .labor-summary-detail {
      font-size: 11px;
      color: #666;
    }
    
    .labor-chart-section {
      margin: 25px 0;
    }
    
    .section-title {
      font-size: 16px;
      font-weight: 600;
      color: #333;
      margin-bottom: 15px;
      border-bottom: 2px solid #e0e0e0;
      padding-bottom: 8px;
    }
    
    .staff-performance-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin: 25px 0;
    }
    
    .performance-card {
      background: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 10px;
      padding: 15px;
    }
    
    .performance-title {
      font-size: 14px;
      font-weight: 600;
      color: #333;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid #e0e0e0;
    }
    
    .role-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid #f0f0f0;
    }
    
    .role-item:last-child {
      border-bottom: none;
    }
    
    .role-name {
      font-weight: 600;
      color: #333;
      font-size: 13px;
    }
    
    .role-hours {
      font-size: 12px;
      color: #666;
    }
    
    .role-cost {
      font-weight: 600;
      color: #555;
      font-size: 13px;
    }
    
    .on-time-indicator {
      text-align: center;
      margin-bottom: 15px;
    }
    
    .on-time-percentage {
      font-size: 32px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .on-time-percentage.good { color: #22c55e; }
    .on-time-percentage.warning { color: #f59e0b; }
    .on-time-percentage.poor { color: #ef4444; }
    
    .on-time-breakdown {
      display: flex;
      justify-content: space-around;
      text-align: center;
      font-size: 11px;
    }
    
    .on-time-stat {
      color: #666;
    }
    
    .exception-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
      border-bottom: 1px solid #f0f0f0;
      font-size: 12px;
    }
    
    .exception-item:last-child {
      border-bottom: none;
    }
    
    .exception-staff {
      font-weight: 600;
      color: #333;
    }
    
    .exception-detail {
      color: #666;
      font-size: 11px;
    }
    
    .exception-time {
      font-size: 10px;
      color: #888;
    }
    
    .exception-early { border-left: 3px solid #22c55e; padding-left: 8px; }
    .exception-late { border-left: 3px solid #ef4444; padding-left: 8px; }
    
    .labor-efficiency-section {
      margin-top: 25px;
    }
    
    .efficiency-metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 15px;
    }
    
    .efficiency-metric {
      background: white;
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      padding: 15px;
      text-align: center;
      transition: all 0.3s ease;
    }
    
    .efficiency-metric:hover {
      border-color: #667eea;
      transform: translateY(-2px);
    }
    
    .efficiency-value {
      font-size: 20px;
      font-weight: bold;
      color: #333;
      margin-bottom: 5px;
    }
    
    .efficiency-label {
      font-size: 11px;
      font-weight: 600;
      color: #555;
      margin-bottom: 3px;
    }
    
    .efficiency-trend {
      font-size: 10px;
      font-weight: 500;
    }
    
    .efficiency-trend.positive { color: #22c55e; }
    .efficiency-trend.negative { color: #ef4444; }
    
    .loading-sm {
      text-align: center;
      padding: 20px;
      font-size: 12px;
      color: #666;
    }

    /* Responsive Design for Labor Analytics */
    @media (max-width: 768px) {
      .labor-period-selector {
        flex-wrap: wrap;
        justify-content: center;
      }
      
      .staff-performance-grid {
        grid-template-columns: 1fr;
      }
      
      .efficiency-metrics-grid {
        grid-template-columns: 1fr 1fr;
      }
    }

    /* Loading Styles */
    .loading {
      text-align: center;
      padding: 40px 20px;
      color: #666;
    }
    
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Error Styles */
    .error {
      text-align: center;
      padding: 20px;
      color: #ef4444;
      background: #fef2f2;
      border-radius: 8px;
      border: 1px solid #fecaca;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .header {
        flex-direction: column;
        gap: 15px;
        text-align: center;
      }
      
      .nav-links {
        flex-wrap: wrap;
        justify-content: center;
      }
      
      .dashboard-grid {
        grid-template-columns: 1fr;
      }
      
      .metrics-grid {
        grid-template-columns: 1fr 1fr;
      }
      
      .stats-grid {
        grid-template-columns: 1fr 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <div class="header-info">
        <h1>Manager Portal</h1>
        <p>Real-time analytics & labor management</p>
      </div>
      <div class="nav-links">
        <a href="index.html" class="nav-link">‚Üê Tip Calculator</a>
        <a href="#" class="nav-link" onclick="refreshAllData()">üîÑ Refresh</a>
      </div>
    </div>

    <!-- Content -->
    <div class="content">
      <!-- Live Metrics Row -->
      <div class="component-card">
        <div class="card-header">
          <div>
            <h2 class="card-title">Live Metrics</h2>
            <p class="card-subtitle">Real-time operational status</p>
          </div>
          <div class="status-indicator">
            <div class="status-dot"></div>
            <span id="live-metrics-status">Updated 30s ago</span>
          </div>
        </div>
        <div class="card-body">
          <div class="metrics-grid" id="live-metrics-grid">
            <div class="loading">
              <div class="loading-spinner"></div>
              Loading live metrics...
            </div>
          </div>
        </div>
      </div>

      <!-- Stats Cards & Top Items Row -->
      <div class="dashboard-grid">
        <!-- Stats Cards -->
        <div class="component-card">
          <div class="card-header">
            <div>
              <h2 class="card-title">Revenue Analytics</h2>
              <p class="card-subtitle">Today's performance metrics</p>
            </div>
          </div>
          <div class="card-body">
            <div class="stats-grid" id="stats-cards-grid">
              <div class="loading">
                <div class="loading-spinner"></div>
                Loading revenue data...
              </div>
            </div>
          </div>
        </div>

        <!-- Top Items -->
        <div class="component-card">
          <div class="card-header">
            <div>
              <h2 class="card-title">Best Sellers</h2>
              <p class="card-subtitle">Top performing menu items</p>
            </div>
          </div>
          <div class="card-body">
            <div class="items-list" id="top-items-list">
              <div class="loading">
                <div class="loading-spinner"></div>
                Loading top items...
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Sales Chart -->
      <div class="component-card">
        <div class="card-header">
          <div>
            <h2 class="card-title">Sales Trends</h2>
            <p class="card-subtitle">Revenue analysis over time</p>
          </div>
        </div>
        <div class="card-body">
          <div class="chart-controls">
            <button class="chart-btn active" onclick="changePeriod('day')">24 Hours</button>
            <button class="chart-btn" onclick="changePeriod('week')">7 Days</button>
            <button class="chart-btn" onclick="changePeriod('month')">30 Days</button>
          </div>
          <div class="chart-container">
            <canvas id="sales-chart"></canvas>
          </div>
        </div>
      </div>

      <!-- Recent Orders -->
      <div class="component-card">
        <div class="card-header">
          <div>
            <h2 class="card-title">Recent Orders</h2>
            <p class="card-subtitle">Live order feed & status</p>
          </div>
        </div>
        <div class="card-body">
          <div id="recent-orders-list">
            <div class="loading">
              <div class="loading-spinner"></div>
              Loading recent orders...
            </div>
          </div>
        </div>
      </div>

      <!-- Advanced Labor Analytics Dashboard -->
      <div class="component-card labor-analytics">
        <div class="card-header">
          <div>
            <h2 class="card-title">Labor Analytics</h2>
            <p class="card-subtitle">Homebase + Toast comprehensive workforce intelligence</p>
          </div>
          <div class="labor-period-selector">
            <button class="period-btn active" onclick="changeLaborPeriod('today')">Today</button>
            <button class="period-btn" onclick="changeLaborPeriod('week')">This Week</button>
            <button class="period-btn" onclick="changeLaborPeriod('month')">This Month</button>
          </div>
        </div>
        <div class="card-body">
          
          <!-- Labor Summary Cards -->
          <div class="labor-summary-grid" id="labor-summary-cards">
            <div class="loading">
              <div class="loading-spinner"></div>
              Loading labor analytics...
            </div>
          </div>

          <!-- Scheduled vs Actual Hours Chart -->
          <div class="labor-chart-section">
            <h3 class="section-title">Scheduled vs Actual Hours</h3>
            <div class="chart-container">
              <canvas id="labor-hours-chart"></canvas>
            </div>
          </div>

          <!-- Staff Performance Grid -->
          <div class="staff-performance-grid">
            
            <!-- Labor by Role -->
            <div class="performance-card">
              <h4 class="performance-title">Labor by Role</h4>
              <div id="labor-by-role-list">
                <div class="loading-sm">Loading roles...</div>
              </div>
            </div>

            <!-- On-Time Performance -->
            <div class="performance-card">
              <h4 class="performance-title">On-Time Rate</h4>
              <div id="on-time-performance">
                <div class="loading-sm">Loading performance...</div>
              </div>
            </div>

            <!-- Staff Exceptions -->
            <div class="performance-card">
              <h4 class="performance-title">Today's Exceptions</h4>
              <div id="staff-exceptions-list">
                <div class="loading-sm">Loading exceptions...</div>
              </div>
            </div>

          </div>

          <!-- Labor Efficiency Metrics -->
          <div class="labor-efficiency-section">
            <h3 class="section-title">Labor Efficiency vs Sales</h3>
            <div class="efficiency-metrics-grid" id="efficiency-metrics">
              <div class="loading">
                <div class="loading-spinner"></div>
                Loading efficiency metrics...
              </div>
            </div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <script>
    // Configuration (Note: All API credentials are securely stored in Vercel environment variables)
    const CONFIG = {
      HOMEBASE_LOCATION_UUID: '0b6c1af3-4904-4b84-ae5f-d1172d77de27',
      // API Endpoints (uses Vercel functions like index.html)
      API_BASE: '/api'
    };

    // Global state
    let toastToken = null;
    let tokenExpiry = null;
    let salesChart = null;
    let laborChart = null;
    let currentPeriod = 'day';
    let currentLaborPeriod = 'today';

    // Pacific timezone date helper (same as working index.html)
    function getPacificDate() {
      const now = new Date();
      const pacific = new Date(now.toLocaleString("en-US", {timeZone: "America/Los_Angeles"}));
      const year = pacific.getFullYear();
      const month = String(pacific.getMonth() + 1).padStart(2, '0');
      const day = String(pacific.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    // Initialize the manager portal
    async function initManagerPortal() {
      console.log('üöÄ Initializing Manager Portal with Homebase environment variables...');
      
      try {
        // Get Toast authentication token
        await getToastToken();
        
        // Load all components
        await Promise.all([
          loadLiveMetrics(),
          loadStatsCards(),
          loadTopItems(),
          loadSalesChart(),
          loadRecentOrders(),
          loadLaborAnalytics()
        ]);
        
        console.log('‚úÖ Manager Portal initialized successfully');
        
        // Set up auto-refresh every 30 seconds
        setInterval(refreshLiveData, 30000);
        
      } catch (error) {
        console.error('‚ùå Error initializing Manager Portal:', error);
        showError('Failed to initialize Manager Portal. Please refresh the page.');
      }
    }

    // Toast Authentication - Using Vercel API like index.html
    async function getToastToken() {
      try {
        // Check if we have a valid cached token
        if (toastToken && tokenExpiry && Date.now() < tokenExpiry) {
          return toastToken;
        }
        
        console.log('üîê Authenticating with Toast API via Vercel endpoint...');
        
        const response = await fetch('/api/toast-auth', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error(`Authentication failed: ${response.status}`);
        }

        const authData = await response.json();
        
        if (authData.success && authData.data && authData.data.accessToken) {
          toastToken = authData.data.accessToken;
          // Tokens typically expire in 1 hour
          tokenExpiry = Date.now() + (50 * 60 * 1000); // 50 minutes for safety
          console.log('‚úÖ Toast authentication successful');
          return toastToken;
        } else {
          throw new Error('Invalid authentication response');
        }
      } catch (error) {
        console.error('‚ùå Toast authentication failed:', error);
        throw error;
      }
    }

    // Homebase API Helper - Using Vercel API
    async function callHomebaseAPI(endpoint) {
      try {
        await rateLimitedDelay();
        console.log('üè† Calling Homebase API via Vercel:', endpoint);
        
        const response = await fetch('/api/homebase-proxy', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            endpoint: endpoint
          })
        });

        if (!response.ok) {
          throw new Error(`Homebase API error: ${response.status}`);
        }

        const result = await response.json();
        if (!result.success) {
          throw new Error(result.error || 'Homebase API request failed');
        }

        return result.data;
      } catch (error) {
        console.error('‚ùå Homebase API error:', error);
        throw error;
      }
    }

    // Rate limiting for API calls
    let lastApiCall = 0;
    const API_DELAY = 200; // 200ms between calls to prevent 429 errors
    
    async function rateLimitedDelay() {
      const now = Date.now();
      const timeSinceLastCall = now - lastApiCall;
      if (timeSinceLastCall < API_DELAY) {
        await new Promise(resolve => setTimeout(resolve, API_DELAY - timeSinceLastCall));
      }
      lastApiCall = Date.now();
    }

    // Toast API Helper - Using Vercel API
    async function callToastAPI(endpoint) {
      try {
        await rateLimitedDelay();
        await getToastToken();
        
        console.log('üçû Calling Toast API via Vercel:', endpoint);
        
        // Use different endpoints based on the API call
        let apiEndpoint;
        let requestBody = { accessToken: toastToken };
        
        let response;
        
        if (endpoint.includes('/orders/v2/orders') || endpoint.includes('/orders/v2/ordersBulk')) {
          apiEndpoint = '/api/toast-orders-flexible';
          
          // Extract date parameters from endpoint
          const urlParams = new URLSearchParams(endpoint.split('?')[1] || '');
          let startDate = urlParams.get('startDate');
          let endDate = urlParams.get('endDate');
          const businessDate = urlParams.get('businessDate');
          const pageSize = urlParams.get('pageSize') || '100';
          
          // Handle businessDate parameter (for single-day queries)
          if (businessDate && !startDate && !endDate) {
            startDate = businessDate;
            endDate = businessDate;
          }
          
          // Keep dates in ISO-8601 format (YYYY-MM-DD) for Toast orders API
          // The backend toast-orders-flexible.js will convert YYYYMMDD to proper ISO-8601 with timezone
          const formatDateToYYYYMMDD = (dateStr) => {
            if (!dateStr) return null;
            return dateStr.replace(/-/g, ''); // Convert YYYY-MM-DD to YYYYMMDD for backend processing
          };
          
          // Build URL with query parameters - backend expects YYYYMMDD for conversion to ISO-8601
          const queryParams = new URLSearchParams({
            accessToken: toastToken,
            startDate: formatDateToYYYYMMDD(startDate),
            endDate: formatDateToYYYYMMDD(endDate),
            pageSize: pageSize
          });
          
          apiEndpoint += `?${queryParams.toString()}`;
          
          response = await fetch(apiEndpoint, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json'
            }
          });

        } else if (endpoint.includes('/restaurants/v1/restaurants')) {
          apiEndpoint = '/api/toast-restaurant';
          
          response = await fetch(apiEndpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ accessToken: toastToken })
          });
        } else if (endpoint.includes('/menus/v2/menus')) {
          apiEndpoint = '/api/toast-menus';
          
          response = await fetch(apiEndpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ accessToken: toastToken })
          });
        } else {
          throw new Error(`Unsupported Toast API endpoint: ${endpoint}`);
        }

        if (!response.ok) {
          throw new Error(`Toast API error: ${response.status}`);
        }

        const result = await response.json();
        if (!result.success) {
          throw new Error(result.error || 'Toast API request failed');
        }

        return result.data;
      } catch (error) {
        console.error('‚ùå Toast API error:', error);
        throw error;
      }
    }

    // LiveMetrics Implementation - Real Toast + Homebase Data
    async function loadLiveMetrics() {
      console.log('üìä Loading Live Metrics with real Toast + Homebase data...');
      
      try {
        // Fetch data from both APIs in parallel
        const [toastData, homebaseData] = await Promise.all([
          getToastLiveData(),
          getHomebaseLiveData()
        ]);
        
        // Calculate live metrics
        const metrics = calculateLiveMetrics(toastData, homebaseData);
        
        // Render metrics
        const metricsHTML = `
          <div class="metric-card ${metrics.ordersQueue.status}">
            <div class="metric-value">${metrics.ordersQueue.value}</div>
            <div class="metric-label">Orders in Queue</div>
            <div class="metric-detail">${metrics.ordersQueue.detail}</div>
          </div>
          <div class="metric-card ${metrics.staffOnDuty.status}">
            <div class="metric-value">${metrics.staffOnDuty.value}</div>
            <div class="metric-label">Staff On Duty</div>
            <div class="metric-detail">${metrics.staffOnDuty.detail}</div>
          </div>
          <div class="metric-card ${metrics.revenueToday.status}">
            <div class="metric-value">${metrics.revenueToday.value}</div>
            <div class="metric-label">Revenue Today</div>
            <div class="metric-detail">${metrics.revenueToday.detail}</div>
          </div>
          <div class="metric-card ${metrics.laborEfficiency.status}">
            <div class="metric-value">${metrics.laborEfficiency.value}</div>
            <div class="metric-label">Labor Efficiency</div>
            <div class="metric-detail">${metrics.laborEfficiency.detail}</div>
          </div>
        `;
        
        document.getElementById('live-metrics-grid').innerHTML = metricsHTML;
        console.log('‚úÖ Live Metrics loaded with real data:', metrics);
        
      } catch (error) {
        console.error('‚ùå Error loading Live Metrics:', error);
        document.getElementById('live-metrics-grid').innerHTML = '<div class="error">Failed to load live metrics: ' + error.message + '</div>';
      }
    }

    // Get real-time data from Toast API (using proven payments API pattern like index.html)
    async function getToastLiveData() {
      try {
        const today = getPacificDate(); // Use Pacific timezone instead of UTC
        const businessDate = today.replace(/-/g, ''); // Convert to YYYYMMDD format
        
        // First authenticate with Toast (same pattern as index.html)
        const authResponse = await fetch('/api/toast-auth', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });
        
        if (!authResponse.ok) {
          throw new Error('Failed to authenticate with Toast API');
        }
        
        const authData = await authResponse.json();
        if (!authData.success || !authData.data?.accessToken) {
          throw new Error('Toast authentication failed');
        }
        
        // Get cash revenue using proven payments API (same as index.html)
        const paymentsUrl = `/api/toast-payments?businessDate=${businessDate}&token=${encodeURIComponent(authData.data.accessToken)}`;
        const paymentsResponse = await fetch(paymentsUrl);
        
        if (!paymentsResponse.ok) {
          throw new Error('Failed to fetch Toast payments data');
        }
        
        const paymentsData = await paymentsResponse.json();
        if (!paymentsData.success) {
          throw new Error(paymentsData.error || 'Toast payments API returned an error');
        }
        
        // Get restaurant info for operational status (uses environment variable in API)
        const restaurantResponse = await callToastAPI('/restaurants/v1/restaurants');
        
        // Use the proven revenue from payments API
        const todayRevenue = paymentsData.totalCashAmount || 0;
        const totalOrders = paymentsData.totalCashPayments || 0;
        
        // For queue analysis, we still need some order data but can use a simpler call
        let activeOrders = [];
        try {
          const ordersResponse = await callToastAPI(`/orders/v2/ordersBulk?businessDate=${businessDate}&pageSize=20`);
          if (Array.isArray(ordersResponse)) {
            activeOrders = ordersResponse.filter(order => 
              !order.voided && !order.deleted && 
              order.state && !['CLOSED', 'VOIDED', 'CANCELLED'].includes(order.state)
            );
          }
        } catch (orderError) {
          console.warn('Could not fetch order queue data:', orderError.message);
        }
        
        // Calculate average preparation time
        const avgPrepTime = activeOrders.length > 0 ? 15 : 10; // Simple estimation
        
        return {
          revenue: todayRevenue,
          ordersCount: totalOrders,
          queueLength: activeOrders.length,
          avgPrepTime: avgPrepTime,
          restaurant: restaurantResponse,
          activeOrders: activeOrders
        };
        
      } catch (error) {
        console.error('‚ùå Toast API error:', error);
        throw new Error('Toast API connection failed');
      }
    }

    // Get real-time data from Homebase API
    async function getHomebaseLiveData() {
      try {
        const today = getPacificDate(); // Use Pacific timezone instead of UTC
        
        // Get current employees and today's data
        const [employeesResponse, timecardsResponse, shiftsResponse, todayLaborByEmployee, todayLaborByRole] = await Promise.all([
          callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/employees`),
          callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/timecards?start_date=${today}&end_date=${today}`),
          callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/shifts?start_date=${today}&end_date=${today}`),
          callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/labor/by_employee?start_date=${today}&end_date=${today}`),
          callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/labor/by_role?start_date=${today}&end_date=${today}`)
        ]);
        
        // Calculate who's currently on duty (clocked in)
        const currentlyWorking = timecardsResponse.filter(timecard => 
          timecard.clock_in && !timecard.clock_out
        );
        
        // Calculate labor costs using aggregated data if available
        const laborCosts = todayLaborByEmployee.length > 0 ? 
          calculateLaborCostsFromAggregated(todayLaborByEmployee) :
          calculateLaborCosts(timecardsResponse, employeesResponse);
        
        return {
          employees: employeesResponse,
          timecards: timecardsResponse,
          shifts: shiftsResponse,
          currentlyWorking: currentlyWorking,
          laborCosts: laborCosts,
          laborByEmployee: todayLaborByEmployee,
          laborByRole: todayLaborByRole
        };
        
      } catch (error) {
        console.error('‚ùå Homebase API error:', error);
        throw new Error('Homebase API connection failed');
      }
    }

    // Calculate live metrics from Toast + Homebase data
    function calculateLiveMetrics(toastData, homebaseData) {
      // Orders Queue Analysis
      const ordersQueue = {
        value: toastData.activeOrders.length,
        status: toastData.activeOrders.length > 15 ? 'warning' : 
                toastData.activeOrders.length > 25 ? 'error' : 'good',
        detail: `Avg prep: ${Math.round(toastData.avgPrepTime)} min`
      };
      
      // Staff On Duty Analysis
      const staffCount = homebaseData.currentlyWorking.length;
      const scheduledCount = homebaseData.shifts.length;
      const staffOnDuty = {
        value: `${staffCount}/${scheduledCount}`,
        status: staffCount < scheduledCount * 0.8 ? 'warning' : 
                staffCount > scheduledCount * 1.2 ? 'error' : 'good',
        detail: getStaffBreakdown(homebaseData.currentlyWorking)
      };
      
      // Revenue Today Analysis
      const revenueToday = {
        value: `$${(toastData.revenue || 0).toFixed(0)}`,
        status: 'good', // TODO: Compare with historical averages
        detail: `${toastData.ordersCount || 0} orders today`
      };
      
      // Labor Efficiency Analysis (Revenue per labor hour)
      const totalLaborHours = calculateTotalLaborHours(homebaseData.timecards);
      const revenuePerHour = totalLaborHours > 0 ? (toastData.revenue || 0) / totalLaborHours : 0;
      const laborEfficiency = {
        value: `$${revenuePerHour.toFixed(0)}/hr`,
        status: revenuePerHour > 50 ? 'good' : 
                revenuePerHour > 30 ? 'normal' : 'warning',
        detail: `${totalLaborHours.toFixed(1)} labor hrs today`
      };
      
      return {
        ordersQueue,
        staffOnDuty,
        revenueToday,
        laborEfficiency
      };
    }

    // Helper Functions
    function calculateAveragePreparationTime(orders) {
      const completedOrders = orders.filter(order => 
        order.openedDate && order.closedDate
      );
      
      if (completedOrders.length === 0) return 15; // Default fallback
      
      const totalPrepTime = completedOrders.reduce((sum, order) => {
        const opened = new Date(order.openedDate);
        const closed = new Date(order.closedDate);
        return sum + (closed - opened);
      }, 0);
      
      return (totalPrepTime / completedOrders.length) / (1000 * 60); // Convert to minutes
    }

    function getStaffBreakdown(currentlyWorking) {
      // TODO: Categorize by role if available in Homebase data
      return `${currentlyWorking.length} staff active`;
    }

    function calculateTotalLaborHours(timecards) {
      return timecards.reduce((total, timecard) => {
        if (timecard.clock_in) {
          const clockIn = new Date(timecard.clock_in);
          const clockOut = timecard.clock_out ? new Date(timecard.clock_out) : new Date();
          const hours = (clockOut - clockIn) / (1000 * 60 * 60);
          return total + Math.max(0, hours);
        }
        return total;
      }, 0);
    }

    function calculateLaborCosts(timecards, employees) {
      // TODO: Calculate actual labor costs if hourly rates are available
      return timecards.length * 15; // Placeholder: $15/hour average
    }

    // Calculate labor costs from Homebase aggregated labor data
    function calculateLaborCostsFromAggregated(laborByEmployee) {
      if (!Array.isArray(laborByEmployee)) return 0;
      
      return laborByEmployee.reduce((total, employee) => {
        if (employee.labor && employee.labor.costs) {
          return total + employee.labor.costs;
        }
        return total;
      }, 0);
    }

    // StatsCards Implementation - Real Toast Analytics Data
    async function loadStatsCards() {
      console.log('üìà Loading Stats Cards with real Toast analytics...');
      
      try {
        // Get comprehensive Toast analytics data
        const analyticsData = await getToastAnalyticsData();
        
        // Calculate trend comparisons
        const stats = calculateStatsWithTrends(analyticsData);
        
        // Render stats cards
        const statsHTML = `
          <div class="stat-card">
            <div class="stat-value">${stats.revenue.value}</div>
            <div class="stat-label">Today's Revenue</div>
            <div class="stat-change ${stats.revenue.changeType}">${stats.revenue.change}</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${stats.orders.value}</div>
            <div class="stat-label">Orders Today</div>
            <div class="stat-change ${stats.orders.changeType}">${stats.orders.change}</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${stats.avgOrder.value}</div>
            <div class="stat-label">Avg Order Value</div>
            <div class="stat-change ${stats.avgOrder.changeType}">${stats.avgOrder.change}</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${stats.menuItems.value}</div>
            <div class="stat-label">Active Items</div>
            <div class="stat-change ${stats.menuItems.changeType}">${stats.menuItems.change}</div>
          </div>
        `;
        
        document.getElementById('stats-cards-grid').innerHTML = statsHTML;
        console.log('‚úÖ Stats Cards loaded with real analytics:', stats);
        
      } catch (error) {
        console.error('‚ùå Error loading Stats Cards:', error);
        document.getElementById('stats-cards-grid').innerHTML = '<div class="error">Failed to load revenue stats: ' + error.message + '</div>';
      }
    }

    // Get comprehensive Toast analytics data
    async function getToastAnalyticsData() {
      try {
        // Use Pacific timezone for all date calculations
        const todayStr = getPacificDate();
        
        // Calculate yesterday and last week in Pacific timezone
        const today = new Date(todayStr + 'T12:00:00'); // Use noon to avoid timezone issues
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);
        const lastWeek = new Date(today);
        lastWeek.setDate(lastWeek.getDate() - 7);
        
        // Format dates for Toast API (businessDate format YYYYMMDD)
        const yesterdayStr = yesterday.toISOString().split('T')[0];
        const lastWeekStr = lastWeek.toISOString().split('T')[0];
        const todayBusinessDate = todayStr.replace(/-/g, '');
        const yesterdayBusinessDate = yesterdayStr.replace(/-/g, '');
        const lastWeekBusinessDate = lastWeekStr.replace(/-/g, '');
        
        // Fetch data in parallel using proper ordersBulk endpoint
        const [todayOrders, yesterdayOrders, lastWeekOrders, menuItems] = await Promise.all([
          callToastAPI(`/orders/v2/ordersBulk?businessDate=${todayBusinessDate}&pageSize=200`),
          callToastAPI(`/orders/v2/ordersBulk?businessDate=${yesterdayBusinessDate}&pageSize=200`),
          callToastAPI(`/orders/v2/ordersBulk?businessDate=${lastWeekBusinessDate}&pageSize=200`),
          callToastAPI('/menus/v2/menus')
        ]);
        
        return {
          today: analyzeOrders(todayOrders),
          yesterday: analyzeOrders(yesterdayOrders),
          lastWeek: analyzeOrders(lastWeekOrders),
          menuItems: analyzeMenuItems(menuItems)
        };
        
      } catch (error) {
        console.error('‚ùå Toast analytics error:', error);
        throw new Error('Failed to fetch Toast analytics data');
      }
    }

    // Analyze orders data for revenue and metrics (using payment analysis like toast-orders.js)
    function analyzeOrders(orders) {
      if (!Array.isArray(orders)) return { count: 0, revenue: 0, avgOrderValue: 0, rawOrders: [] };
      
      const validOrders = orders.filter(order => 
        !order.voided && !order.deleted // Use proper voided/deleted checks
      );
      
      let totalRevenue = 0;
      
      // Calculate revenue from actual payments (like toast-orders.js pattern)
      validOrders.forEach(order => {
        if (order.checks && Array.isArray(order.checks)) {
          order.checks.forEach(check => {
            if (check.payments && Array.isArray(check.payments)) {
              check.payments.forEach(payment => {
                if (payment.amount && payment.paymentStatus !== 'VOIDED') {
                  totalRevenue += (payment.amount || 0);
                }
              });
            }
          });
        }
      });
      
      totalRevenue = totalRevenue / 100; // Convert from cents to dollars
      const avgOrderValue = validOrders.length > 0 ? totalRevenue / validOrders.length : 0;
      
      return {
        count: validOrders.length,
        revenue: totalRevenue,
        avgOrderValue: avgOrderValue,
        rawOrders: validOrders
      };
    }

    // Analyze menu items for active count
    function analyzeMenuItems(menuData) {
      if (!menuData || !Array.isArray(menuData)) {
        return { activeCount: 0, totalCount: 0 };
      }
      
      let activeCount = 0;
      let totalCount = 0;
      
      menuData.forEach(menu => {
        if (menu.items && Array.isArray(menu.items)) {
          menu.items.forEach(item => {
            totalCount++;
            if (item.visibility === 'VISIBLE' || item.visibility === 'AVAILABLE') {
              activeCount++;
            }
          });
        }
      });
      
      return { activeCount, totalCount };
    }

    // Calculate stats with trend comparisons
    function calculateStatsWithTrends(analyticsData) {
      // Revenue comparison
      const revenueChange = calculatePercentChange(analyticsData.today.revenue, analyticsData.yesterday.revenue);
      const revenue = {
        value: `$${analyticsData.today.revenue.toFixed(2)}`,
        change: `${revenueChange >= 0 ? '+' : ''}${revenueChange.toFixed(1)}% vs yesterday`,
        changeType: revenueChange >= 0 ? 'positive' : 'negative'
      };
      
      // Orders comparison
      const ordersChange = calculatePercentChange(analyticsData.today.count, analyticsData.yesterday.count);
      const orders = {
        value: analyticsData.today.count.toString(),
        change: `${ordersChange >= 0 ? '+' : ''}${ordersChange.toFixed(1)}% vs yesterday`,
        changeType: ordersChange >= 0 ? 'positive' : 'negative'
      };
      
      // Average order value comparison (vs last week for more stable comparison)
      const avgOrderChange = calculatePercentChange(analyticsData.today.avgOrderValue, analyticsData.lastWeek.avgOrderValue);
      const avgOrder = {
        value: `$${analyticsData.today.avgOrderValue.toFixed(2)}`,
        change: `${avgOrderChange >= 0 ? '+' : ''}${avgOrderChange.toFixed(1)}% vs last week`,
        changeType: avgOrderChange >= 0 ? 'positive' : 'negative'
      };
      
      // Menu items status
      const menuItems = {
        value: analyticsData.menuItems.activeCount.toString(),
        change: `of ${analyticsData.menuItems.totalCount} total items`,
        changeType: 'positive' // Neutral display
      };
      
      return { revenue, orders, avgOrder, menuItems };
    }

    // Calculate percentage change between two values
    function calculatePercentChange(current, previous) {
      if (previous === 0) return current > 0 ? 100 : 0;
      return ((current - previous) / previous) * 100;
    }

    // TopItems Implementation - Real Toast Menu Analytics
    async function loadTopItems() {
      console.log('üèÜ Loading Top Items with real Toast menu analytics...');
      
      try {
        // Get comprehensive menu performance data
        const menuAnalytics = await getToastMenuAnalytics();
        
        // Analyze and rank top items
        const topItems = analyzeTopSellingItems(menuAnalytics);
        
        // Render top items list
        const itemsHTML = topItems.map(item => `
          <div class="item-row">
            <div class="item-info">
              <div class="item-name">${item.name}</div>
              <div class="item-stats">${item.orders} orders ‚Ä¢ $${item.revenue.toFixed(2)}</div>
            </div>
            <div class="item-trend ${item.trend.class}">${item.trend.icon} ${item.trend.text}</div>
          </div>
        `).join('');
        
        document.getElementById('top-items-list').innerHTML = itemsHTML;
        console.log('‚úÖ Top Items loaded with real menu analytics:', topItems);
        
      } catch (error) {
        console.error('‚ùå Error loading Top Items:', error);
        document.getElementById('top-items-list').innerHTML = '<div class="error">Failed to load top items: ' + error.message + '</div>';
      }
    }

    // Get Toast menu analytics with order performance
    async function getToastMenuAnalytics() {
      try {
        // Use Pacific timezone for all date calculations
        const todayStr = getPacificDate();
        
        // Calculate week ago and two weeks ago in Pacific timezone
        const today = new Date(todayStr + 'T12:00:00'); // Use noon to avoid timezone issues
        const weekAgo = new Date(today);
        weekAgo.setDate(weekAgo.getDate() - 7);
        const twoWeeksAgo = new Date(today);
        twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);
        
        // Format dates
        const weekAgoStr = weekAgo.toISOString().split('T')[0];
        const twoWeeksAgoStr = twoWeeksAgo.toISOString().split('T')[0];
        
        // Fetch menu data and recent orders with selections
        const [menuData, recentOrders, previousWeekOrders] = await Promise.all([
          callToastAPI('/menus/v2/menus'),
          callToastAPI(`/orders/v2/orders?startDate=${weekAgoStr}&endDate=${todayStr}&pageSize=500`),
          callToastAPI(`/orders/v2/orders?startDate=${twoWeeksAgoStr}&endDate=${weekAgoStr}&pageSize=500`)
        ]);
        
        return {
          menus: menuData,
          recentOrders: recentOrders,
          previousWeekOrders: previousWeekOrders
        };
        
      } catch (error) {
        console.error('‚ùå Toast menu analytics error:', error);
        throw new Error('Failed to fetch menu analytics data');
      }
    }

    // Analyze top-selling items from orders data
    function analyzeTopSellingItems(analytics) {
      // Create menu item lookup map
      const menuItemMap = createMenuItemMap(analytics.menus);
      
      // Analyze recent week performance
      const recentPerformance = analyzeOrderItems(analytics.recentOrders, menuItemMap);
      
      // Analyze previous week for trend comparison
      const previousPerformance = analyzeOrderItems(analytics.previousWeekOrders, menuItemMap);
      
      // Create top items with trends
      const topItems = Object.values(recentPerformance)
        .sort((a, b) => b.orders - a.orders) // Sort by order count
        .slice(0, 5) // Top 5 items
        .map(item => {
          const previousItem = previousPerformance[item.guid] || { orders: 0, revenue: 0 };
          const trend = calculateItemTrend(item, previousItem);
          
          return {
            ...item,
            trend
          };
        });
      
      return topItems;
    }

    // Create menu item lookup map from Toast menu data
    function createMenuItemMap(menuData) {
      const itemMap = {};
      
      if (!menuData || !Array.isArray(menuData)) return itemMap;
      
      menuData.forEach(menu => {
        if (menu.items && Array.isArray(menu.items)) {
          menu.items.forEach(item => {
            itemMap[item.guid] = {
              guid: item.guid,
              name: item.name || 'Unknown Item',
              price: item.price || 0,
              category: menu.name || 'Uncategorized'
            };
          });
        }
      });
      
      return itemMap;
    }

    // Analyze items from orders data
    function analyzeOrderItems(orders, menuItemMap) {
      const itemPerformance = {};
      
      orders.forEach(order => {
        if (order.selections && Array.isArray(order.selections)) {
          order.selections.forEach(selection => {
            if (selection.item && selection.item.guid) {
              const itemGuid = selection.item.guid;
              const menuItem = menuItemMap[itemGuid];
              
              if (menuItem) {
                if (!itemPerformance[itemGuid]) {
                  itemPerformance[itemGuid] = {
                    guid: itemGuid,
                    name: menuItem.name,
                    category: menuItem.category,
                    orders: 0,
                    revenue: 0,
                    quantity: 0
                  };
                }
                
                const quantity = selection.quantity || 1;
                const price = (selection.price || menuItem.price || 0) / 100; // Toast prices in cents
                
                itemPerformance[itemGuid].orders += 1;
                itemPerformance[itemGuid].quantity += quantity;
                itemPerformance[itemGuid].revenue += price * quantity;
              }
            }
          });
        }
      });
      
      return itemPerformance;
    }

    // Calculate trend for an item compared to previous period
    function calculateItemTrend(currentItem, previousItem) {
      const currentOrders = currentItem.orders;
      const previousOrders = previousItem.orders;
      
      if (previousOrders === 0) {
        return currentOrders > 0 ? 
          { class: 'trend-up', icon: '‚ÜóÔ∏è', text: 'NEW!' } :
          { class: 'trend-stable', icon: '‚Üí', text: '0%' };
      }
      
      const changePercent = ((currentOrders - previousOrders) / previousOrders) * 100;
      
      if (changePercent > 10) {
        return { class: 'trend-up', icon: '‚ÜóÔ∏è', text: `+${changePercent.toFixed(0)}%` };
      } else if (changePercent < -10) {
        return { class: 'trend-down', icon: '‚ÜòÔ∏è', text: `${changePercent.toFixed(0)}%` };
      } else {
        return { class: 'trend-stable', icon: '‚Üí', text: `${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(0)}%` };
      }
    }

    // SalesChart Implementation - Real Toast + Homebase Analytics with Chart.js
    async function loadSalesChart() {
      console.log('üìä Loading Sales Chart with comprehensive Toast + Homebase analytics...');
      
      try {
        // Get comprehensive analytics data for current period
        const chartAnalytics = await getSalesChartData(currentPeriod);
        
        // Create or update the chart
        if (salesChart) {
          salesChart.destroy();
        }
        
        const ctx = document.getElementById('sales-chart').getContext('2d');
        salesChart = createSalesChart(ctx, chartAnalytics);
        
        console.log('‚úÖ Sales Chart loaded with real analytics:', chartAnalytics);
        
      } catch (error) {
        console.error('‚ùå Error loading Sales Chart:', error);
        const ctx = document.getElementById('sales-chart').getContext('2d');
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.fillStyle = '#ef4444';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Failed to load sales chart: ' + error.message, ctx.canvas.width/2, ctx.canvas.height/2);
      }
    }

    // Get comprehensive sales chart data with labor correlation
    async function getSalesChartData(period) {
      try {
        const dateRange = calculateDateRange(period);
        
        // Fetch Toast sales data and Homebase labor data in parallel
        const [salesData, laborData] = await Promise.all([
          getToastSalesData(dateRange),
          getHomebaseLaborData(dateRange)
        ]);
        
        // Combine and analyze data
        const combinedAnalytics = combineToastHomebaseData(salesData, laborData, period);
        
        return combinedAnalytics;
        
      } catch (error) {
        console.error('‚ùå Sales chart data error:', error);
        throw new Error('Failed to fetch comprehensive sales analytics');
      }
    }

    // Calculate date range based on period selection
    function calculateDateRange(period) {
      const endDate = new Date();
      const startDate = new Date();
      
      switch (period) {
        case 'day':
          // Last 24 hours by hour
          startDate.setDate(startDate.getDate() - 1);
          return { startDate, endDate, granularity: 'hour' };
        case 'week':
          // Last 7 days by day
          startDate.setDate(startDate.getDate() - 7);
          return { startDate, endDate, granularity: 'day' };
        case 'month':
          // Last 30 days by day
          startDate.setDate(startDate.getDate() - 30);
          return { startDate, endDate, granularity: 'day' };
        default:
          startDate.setDate(startDate.getDate() - 7);
          return { startDate, endDate, granularity: 'day' };
      }
    }

    // Get Toast sales data for the date range
    async function getToastSalesData(dateRange) {
      const startDateStr = dateRange.startDate.toISOString().split('T')[0];
      const endDateStr = dateRange.endDate.toISOString().split('T')[0];
      
      // Get all orders in the date range
      const orders = await callToastAPI(`/orders/v2/orders?startDate=${startDateStr}&endDate=${endDateStr}&pageSize=1000`);
      
      // Group orders by time period
      const salesByPeriod = groupOrdersByPeriod(orders, dateRange.granularity);
      
      return salesByPeriod;
    }

    // Get Homebase labor data for the date range
    async function getHomebaseLaborData(dateRange) {
      try {
        const startDateStr = dateRange.startDate.toISOString().split('T')[0];
        const endDateStr = dateRange.endDate.toISOString().split('T')[0];
        
        // Get both detailed timecards/shifts and aggregated labor data
        const [timecards, shifts, laborByEmployee, laborByRole, aggregateLabor] = await Promise.all([
          callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/timecards?start_date=${startDateStr}&end_date=${endDateStr}`),
          callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/shifts?start_date=${startDateStr}&end_date=${endDateStr}`),
          callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/labor/by_employee?start_date=${startDateStr}&end_date=${endDateStr}`),
          callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/labor/by_role?start_date=${startDateStr}&end_date=${endDateStr}`),
          callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/labor?start_date=${startDateStr}&end_date=${endDateStr}&group_by=${dateRange.granularity === 'hour' ? 'hour' : 'day'}`)
        ]);
        
        // Group labor data by time period using both detailed and aggregated data
        const laborByPeriod = groupLaborByPeriod(timecards, shifts, dateRange.granularity);
        
        // Add aggregated labor insights
        laborByPeriod.aggregatedData = {
          byEmployee: laborByEmployee,
          byRole: laborByRole,
          aggregate: aggregateLabor
        };
        
        return laborByPeriod;
        
      } catch (error) {
        console.error('‚ùå Homebase labor data error:', error);
        return {}; // Return empty object if Homebase fails
      }
    }

    // Group orders by time period (hour/day)
    function groupOrdersByPeriod(orders, granularity) {
      const grouped = {};
      
      orders.forEach(order => {
        if (order.openedDate && order.status && !['VOIDED', 'CANCELLED'].includes(order.status)) {
          const orderDate = new Date(order.openedDate);
          const periodKey = granularity === 'hour' ? 
            `${orderDate.getFullYear()}-${String(orderDate.getMonth() + 1).padStart(2, '0')}-${String(orderDate.getDate()).padStart(2, '0')} ${String(orderDate.getHours()).padStart(2, '0')}:00` :
            `${orderDate.getFullYear()}-${String(orderDate.getMonth() + 1).padStart(2, '0')}-${String(orderDate.getDate()).padStart(2, '0')}`;
          
          if (!grouped[periodKey]) {
            grouped[periodKey] = {
              revenue: 0,
              orders: 0,
              avgOrderValue: 0
            };
          }
          
          const revenue = (order.amount || 0) / 100; // Toast amounts in cents
          grouped[periodKey].revenue += revenue;
          grouped[periodKey].orders += 1;
          grouped[periodKey].avgOrderValue = grouped[periodKey].revenue / grouped[periodKey].orders;
        }
      });
      
      return grouped;
    }

    // Group labor data by time period
    function groupLaborByPeriod(timecards, shifts, granularity) {
      const grouped = {};
      
      // Process timecards (actual hours)
      timecards.forEach(timecard => {
        if (timecard.clock_in) {
          const clockInDate = new Date(timecard.clock_in);
          const periodKey = granularity === 'hour' ? 
            `${clockInDate.getFullYear()}-${String(clockInDate.getMonth() + 1).padStart(2, '0')}-${String(clockInDate.getDate()).padStart(2, '0')} ${String(clockInDate.getHours()).padStart(2, '0')}:00` :
            `${clockInDate.getFullYear()}-${String(clockInDate.getMonth() + 1).padStart(2, '0')}-${String(clockInDate.getDate()).padStart(2, '0')}`;
          
          if (!grouped[periodKey]) {
            grouped[periodKey] = {
              actualHours: 0,
              scheduledHours: 0,
              laborCost: 0,
              staffCount: 0
            };
          }
          
          // Calculate actual hours worked
          const clockOut = timecard.clock_out ? new Date(timecard.clock_out) : new Date();
          const hoursWorked = Math.max(0, (clockOut - clockInDate) / (1000 * 60 * 60));
          
          grouped[periodKey].actualHours += hoursWorked;
          grouped[periodKey].laborCost += hoursWorked * 15; // Assume $15/hour average
          grouped[periodKey].staffCount += 1;
        }
      });
      
      // Process shifts (scheduled hours)
      shifts.forEach(shift => {
        if (shift.start_date) {
          const shiftDate = new Date(shift.start_date);
          const periodKey = granularity === 'hour' ? 
            `${shiftDate.getFullYear()}-${String(shiftDate.getMonth() + 1).padStart(2, '0')}-${String(shiftDate.getDate()).padStart(2, '0')} ${String(shiftDate.getHours()).padStart(2, '0')}:00` :
            `${shiftDate.getFullYear()}-${String(shiftDate.getMonth() + 1).padStart(2, '0')}-${String(shiftDate.getDate()).padStart(2, '0')}`;
          
          if (!grouped[periodKey]) {
            grouped[periodKey] = {
              actualHours: 0,
              scheduledHours: 0,
              laborCost: 0,
              staffCount: 0
            };
          }
          
          // Calculate scheduled hours
          const endDate = shift.end_date ? new Date(shift.end_date) : new Date(shiftDate.getTime() + 8 * 60 * 60 * 1000);
          const scheduledHours = Math.max(0, (endDate - shiftDate) / (1000 * 60 * 60));
          
          grouped[periodKey].scheduledHours += scheduledHours;
        }
      });
      
      return grouped;
    }

    // Combine Toast and Homebase data for comprehensive analytics
    function combineToastHomebaseData(salesData, laborData, period) {
      const labels = [];
      const revenueData = [];
      const ordersData = [];
      const laborHoursData = [];
      const laborEfficiencyData = [];
      
      // Get all unique time periods
      const allPeriods = new Set([...Object.keys(salesData), ...Object.keys(laborData)]);
      const sortedPeriods = Array.from(allPeriods).sort();
      
      sortedPeriods.forEach(periodKey => {
        const sales = salesData[periodKey] || { revenue: 0, orders: 0 };
        const labor = laborData[periodKey] || { actualHours: 0, scheduledHours: 0, laborCost: 0 };
        
        // Format label based on period
        const label = formatChartLabel(periodKey, period);
        labels.push(label);
        
        revenueData.push(sales.revenue);
        ordersData.push(sales.orders);
        laborHoursData.push(labor.actualHours);
        
        // Calculate labor efficiency (revenue per labor hour)
        const efficiency = labor.actualHours > 0 ? sales.revenue / labor.actualHours : 0;
        laborEfficiencyData.push(efficiency);
      });
      
      return {
        labels,
        datasets: {
          revenue: revenueData,
          orders: ordersData,
          laborHours: laborHoursData,
          efficiency: laborEfficiencyData
        }
      };
    }

    // Format chart label based on period
    function formatChartLabel(periodKey, period) {
      if (period === 'day') {
        // Hour format: "2025-09-30 14:00" -> "2:00 PM"
        const [datePart, timePart] = periodKey.split(' ');
        const hour = parseInt(timePart.split(':')[0]);
        return hour === 0 ? '12:00 AM' : 
               hour < 12 ? `${hour}:00 AM` : 
               hour === 12 ? '12:00 PM' : 
               `${hour - 12}:00 PM`;
      } else {
        // Day format: "2025-09-30" -> "Sep 30"
        const date = new Date(periodKey + 'T00:00:00');
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      }
    }

    // Create Chart.js sales chart with multi-axis support
    function createSalesChart(ctx, analytics) {
      return new Chart(ctx, {
        type: 'line',
        data: {
          labels: analytics.labels,
          datasets: [
            {
              label: 'Revenue ($)',
              data: analytics.datasets.revenue,
              borderColor: '#667eea',
              backgroundColor: 'rgba(102, 126, 234, 0.1)',
              fill: true,
              tension: 0.4,
              yAxisID: 'y'
            },
            {
              label: 'Orders',
              data: analytics.datasets.orders,
              borderColor: '#22c55e',
              backgroundColor: 'rgba(34, 197, 94, 0.1)',
              fill: false,
              tension: 0.4,
              yAxisID: 'y1'
            },
            {
              label: 'Labor Hours',
              data: analytics.datasets.laborHours,
              borderColor: '#f59e0b',
              backgroundColor: 'rgba(245, 158, 11, 0.1)',
              fill: false,
              tension: 0.4,
              yAxisID: 'y2'
            },
            {
              label: 'Efficiency ($/hr)',
              data: analytics.datasets.efficiency,
              borderColor: '#ef4444',
              backgroundColor: 'rgba(239, 68, 68, 0.1)',
              fill: false,
              tension: 0.4,
              yAxisID: 'y3'
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: `${currentPeriod === 'day' ? '24-Hour' : currentPeriod === 'week' ? '7-Day' : '30-Day'} Revenue vs Labor Analysis`
            },
            legend: {
              position: 'top'
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              callbacks: {
                label: function(context) {
                  const label = context.dataset.label || '';
                  if (label.includes('Revenue')) {
                    return `${label}: $${context.parsed.y.toFixed(2)}`;
                  } else if (label.includes('Efficiency')) {
                    return `${label}: $${context.parsed.y.toFixed(2)}/hr`;
                  } else if (label.includes('Hours')) {
                    return `${label}: ${context.parsed.y.toFixed(1)} hrs`;
                  } else {
                    return `${label}: ${context.parsed.y}`;
                  }
                }
              }
            }
          },
          scales: {
            x: {
              display: true,
              title: {
                display: true,
                text: currentPeriod === 'day' ? 'Hour' : 'Date'
              }
            },
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              title: {
                display: true,
                text: 'Revenue ($)'
              },
              grid: {
                color: 'rgba(102, 126, 234, 0.1)'
              }
            },
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              title: {
                display: true,
                text: 'Orders'
              },
              grid: {
                drawOnChartArea: false,
              },
              ticks: {
                color: '#22c55e'
              }
            },
            y2: {
              type: 'linear',
              display: false,
              position: 'right'
            },
            y3: {
              type: 'linear',
              display: false,
              position: 'right'
            }
          },
          interaction: {
            mode: 'nearest',
            axis: 'x',
            intersect: false
          }
        }
      });
    }

    // RecentOrders Implementation - Real Toast Live Order Feed
    async function loadRecentOrders() {
      console.log('üìã Loading Recent Orders with real Toast live feed...');
      
      try {
        // Get real-time orders data
        const ordersData = await getToastRecentOrders();
        
        // Render live orders feed
        const ordersHTML = ordersData.map(order => `
          <div class="order-row" data-order-id="${order.id}">
            <div class="order-info">
              <div class="order-header">
                <span class="order-number">${order.orderNumber}</span>
                <span class="order-customer">${order.customer}</span>
                <span class="order-time">${order.time}</span>
              </div>
              <div class="order-items">${order.items.join(', ')}</div>
              <div class="order-details">
                <span class="order-payment">${order.paymentMethod}</span>
                ${order.specialInstructions ? `<span class="order-notes">‚Ä¢ ${order.specialInstructions}</span>` : ''}
              </div>
            </div>
            <div class="order-summary">
              <div class="order-total">$${order.total.toFixed(2)}</div>
              <div class="order-status ${order.status.toLowerCase()}">${order.statusText}</div>
            </div>
          </div>
        `).join('');
        
        document.getElementById('recent-orders-list').innerHTML = ordersHTML || '<div class="no-orders">No recent orders found</div>';
        console.log('‚úÖ Recent Orders loaded with live feed:', ordersData.length, 'orders');
        
      } catch (error) {
        console.error('‚ùå Error loading Recent Orders:', error);
        document.getElementById('recent-orders-list').innerHTML = '<div class="error">Failed to load recent orders: ' + error.message + '</div>';
      }
    }

    // Get real-time Toast orders data
    async function getToastRecentOrders() {
      try {
        const todayStr = getPacificDate(); // Use Pacific timezone instead of UTC
        
        // Get today's orders, most recent first
        const orders = await callToastAPI(`/orders/v2/ordersBulk?businessDate=${todayStr.replace(/-/g, '')}&pageSize=20`);
        
        // Sort by opened date (most recent first) and process
        const sortedOrders = orders
          .filter(order => order.openedDate && order.status)
          .sort((a, b) => new Date(b.openedDate) - new Date(a.openedDate))
          .slice(0, 10); // Top 10 most recent
        
        // Process each order for display
        const processedOrders = sortedOrders.map(order => processOrderForDisplay(order));
        
        return processedOrders;
        
      } catch (error) {
        console.error('‚ùå Toast recent orders error:', error);
        throw new Error('Failed to fetch recent orders from Toast');
      }
    }

    // Process individual order for display
    function processOrderForDisplay(order) {
      // Extract order basic info
      const orderNumber = order.displayNumber || order.orderNumber || `#${order.id?.slice(-4) || 'N/A'}`;
      
      // Customer information
      const customer = extractCustomerName(order);
      
      // Order timing
      const openedDate = new Date(order.openedDate);
      const time = openedDate.toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      
      // Order items
      const items = extractOrderItems(order);
      
      // Order total
      const total = (order.amount || 0) / 100; // Toast amounts in cents
      
      // Order status
      const { status, statusText } = determineOrderStatus(order);
      
      // Payment method
      const paymentMethod = extractPaymentMethod(order);
      
      // Special instructions
      const specialInstructions = extractSpecialInstructions(order);
      
      return {
        id: order.id,
        orderNumber,
        customer,
        time,
        items,
        total,
        status,
        statusText,
        paymentMethod,
        specialInstructions,
        rawOrder: order
      };
    }

    // Extract customer name from order
    function extractCustomerName(order) {
      if (order.customer) {
        const firstName = order.customer.firstName || '';
        const lastName = order.customer.lastName || '';
        
        if (firstName && lastName) {
          return `${firstName} ${lastName.charAt(0)}.`;
        } else if (firstName) {
          return firstName;
        } else if (lastName) {
          return lastName;
        }
      }
      
      // Fallback options
      if (order.displayNumber) {
        return `Order ${order.displayNumber}`;
      }
      
      return 'Guest Customer';
    }

    // Extract order items list
    function extractOrderItems(order) {
      if (order.selections && Array.isArray(order.selections)) {
        return order.selections
          .map(selection => {
            const itemName = selection.item?.name || 'Unknown Item';
            const quantity = selection.quantity || 1;
            return quantity > 1 ? `${itemName} (${quantity})` : itemName;
          })
          .slice(0, 3); // Show max 3 items
      }
      
      return ['Order details unavailable'];
    }

    // Determine order status and display text
    function determineOrderStatus(order) {
      const status = order.status?.toUpperCase() || 'UNKNOWN';
      
      const statusMap = {
        'OPEN': { status: 'open', statusText: 'Ordered' },
        'PROCESSING': { status: 'processing', statusText: 'Preparing' },
        'IN_PROGRESS': { status: 'processing', statusText: 'Preparing' },
        'READY': { status: 'ready', statusText: 'Ready' },
        'FULFILLED': { status: 'completed', statusText: 'Fulfilled' },
        'CLOSED': { status: 'completed', statusText: 'Completed' },
        'VOIDED': { status: 'voided', statusText: 'Voided' },
        'CANCELLED': { status: 'cancelled', statusText: 'Cancelled' },
        'UNKNOWN': { status: 'unknown', statusText: 'Unknown' }
      };
      
      return statusMap[status] || statusMap['UNKNOWN'];
    }

    // Extract payment method
    function extractPaymentMethod(order) {
      if (order.payments && Array.isArray(order.payments) && order.payments.length > 0) {
        const payment = order.payments[0];
        const type = payment.type || 'Unknown';
        
        // Map Toast payment types to display names
        const paymentMap = {
          'CREDIT': 'Card',
          'CREDIT_CARD': 'Card',
          'DEBIT_CARD': 'Debit',
          'CASH': 'Cash',
          'GIFT_CARD': 'Gift Card',
          'OTHER': 'Other'
        };
        
        return paymentMap[type.toUpperCase()] || 'Card';
      }
      
      return 'Card'; // Default assumption
    }

    // Extract special instructions
    function extractSpecialInstructions(order) {
      // Check various fields for special instructions
      if (order.specialInstructions) {
        return order.specialInstructions;
      }
      
      if (order.notes) {
        return order.notes;
      }
      
      // Check selections for modifiers with special instructions
      if (order.selections && Array.isArray(order.selections)) {
        for (const selection of order.selections) {
          if (selection.modifiers && Array.isArray(selection.modifiers)) {
            const specialMods = selection.modifiers
              .filter(mod => mod.name && mod.name.toLowerCase().includes('special'))
              .map(mod => mod.name);
            
            if (specialMods.length > 0) {
              return specialMods.join(', ');
            }
          }
        }
      }
      
      return null;
    }

    // Chart period change
    function changePeriod(period) {
      currentPeriod = period;
      
      // Update button states
      document.querySelectorAll('.chart-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      // TODO: Reload chart with new period data
      console.log(`üìä Changing chart period to: ${period}`);
      loadSalesChart();
    }

    // Refresh functions
    function refreshLiveData() {
      loadLiveMetrics();
      updateStatusIndicator();
    }

    function refreshAllData() {
      console.log('üîÑ Refreshing all data...');
      Promise.all([
        loadLiveMetrics(),
        loadStatsCards(),
        loadTopItems(),
        loadSalesChart(),
        loadRecentOrders(),
        loadLaborAnalytics()
      ]).then(() => {
        console.log('‚úÖ All data refreshed');
      });
    }

    function updateStatusIndicator() {
      const now = new Date();
      const timeStr = now.toLocaleTimeString('en-US', { 
        hour: 'numeric', 
        minute: '2-digit', 
        second: '2-digit' 
      });
      document.getElementById('live-metrics-status').textContent = `Updated ${timeStr}`;
    }

    function showError(message) {
      console.error('‚ùå Manager Portal Error:', message);
      // You can implement a toast notification here
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', initManagerPortal);

    // ==================== ADVANCED LABOR ANALYTICS ====================
    
    // Main Labor Analytics Loader
    async function loadLaborAnalytics() {
      console.log('üë• Loading Advanced Labor Analytics...');
      
      try {
        // Load all labor analytics components
        await Promise.all([
          loadLaborSummaryCards(),
          loadLaborHoursChart(),
          loadLaborByRole(),
          loadOnTimePerformance(),
          loadStaffExceptions(),
          loadLaborEfficiencyMetrics()
        ]);
        
        console.log('‚úÖ Labor Analytics loaded successfully');
        
      } catch (error) {
        console.error('‚ùå Error loading Labor Analytics:', error);
        showLaborAnalyticsError(error.message);
      }
    }

    // Labor Summary Cards Implementation
    async function loadLaborSummaryCards() {
      try {
        const laborData = await getComprehensiveLaborData(currentLaborPeriod);
        const summaryCards = calculateLaborSummary(laborData);
        
        const cardsHTML = summaryCards.map(card => `
          <div class="labor-summary-card ${card.status}">
            <div class="labor-summary-value">${card.value}</div>
            <div class="labor-summary-label">${card.label}</div>
            <div class="labor-summary-detail">${card.detail}</div>
          </div>
        `).join('');
        
        document.getElementById('labor-summary-cards').innerHTML = cardsHTML;
        
      } catch (error) {
        console.error('‚ùå Labor summary error:', error);
        document.getElementById('labor-summary-cards').innerHTML = '<div class="error">Failed to load labor summary</div>';
      }
    }

    // Get comprehensive labor data from Homebase + Toast
    async function getComprehensiveLaborData(period) {
      const dateRange = calculateLaborDateRange(period);
      
      // Get parallel data from both APIs
      const [homebaseData, toastSalesData] = await Promise.all([
        getHomebaseLaborData(dateRange),
        getToastSalesData(dateRange)
      ]);
      
      // Get employee data for role analysis
      const employees = await callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/employees`);
      
      return {
        homebase: homebaseData,
        toast: toastSalesData,
        employees: employees,
        dateRange: dateRange
      };
    }

    // Calculate labor date range based on period
    function calculateLaborDateRange(period) {
      const endDate = new Date();
      const startDate = new Date();
      
      switch (period) {
        case 'today':
          startDate.setHours(0, 0, 0, 0);
          endDate.setHours(23, 59, 59, 999);
          return { startDate, endDate, granularity: 'hour' };
        case 'week':
          startDate.setDate(startDate.getDate() - 7);
          return { startDate, endDate, granularity: 'day' };
        case 'month':
          startDate.setDate(startDate.getDate() - 30);
          return { startDate, endDate, granularity: 'day' };
        default:
          startDate.setHours(0, 0, 0, 0);
          endDate.setHours(23, 59, 59, 999);
          return { startDate, endDate, granularity: 'hour' };
      }
    }

    // Calculate labor summary metrics
    function calculateLaborSummary(laborData) {
      const { homebase, toast, employees } = laborData;
      
      // Calculate totals
      const totalScheduledHours = Object.values(homebase).reduce((sum, period) => sum + period.scheduledHours, 0);
      const totalActualHours = Object.values(homebase).reduce((sum, period) => sum + period.actualHours, 0);
      const totalRevenue = Object.values(toast).reduce((sum, period) => sum + period.revenue, 0);
      const totalLaborCost = totalActualHours * 15; // $15/hour average
      
      // Calculate percentages and ratios
      const scheduledVsActualRatio = totalScheduledHours > 0 ? (totalActualHours / totalScheduledHours) * 100 : 0;
      const laborCostPercentage = totalRevenue > 0 ? (totalLaborCost / totalRevenue) * 100 : 0;
      const revenuePerLaborHour = totalActualHours > 0 ? totalRevenue / totalActualHours : 0;
      
      // Determine status based on thresholds
      const getScheduledStatus = (ratio) => {
        if (ratio >= 90 && ratio <= 110) return 'success';
        if (ratio >= 75 && ratio <= 125) return 'warning';
        return 'danger';
      };
      
      const getLaborCostStatus = (percentage) => {
        if (percentage <= 30) return 'success';
        if (percentage <= 40) return 'warning';
        return 'danger';
      };
      
      return [
        {
          value: `${scheduledVsActualRatio.toFixed(0)}%`,
          label: 'Scheduled vs Actual',
          detail: `${totalActualHours.toFixed(1)}h actual vs ${totalScheduledHours.toFixed(1)}h scheduled`,
          status: getScheduledStatus(scheduledVsActualRatio)
        },
        {
          value: `${laborCostPercentage.toFixed(1)}%`,
          label: 'Labor Cost % of Sales',
          detail: `$${totalLaborCost.toFixed(0)} labor cost vs $${totalRevenue.toFixed(0)} revenue`,
          status: getLaborCostStatus(laborCostPercentage)
        },
        {
          value: `$${revenuePerLaborHour.toFixed(0)}`,
          label: 'Revenue per Labor Hour',
          detail: `Efficiency: $${revenuePerLaborHour.toFixed(2)}/hour worked`,
          status: revenuePerLaborHour > 50 ? 'success' : revenuePerLaborHour > 30 ? 'warning' : 'danger'
        },
        {
          value: employees.length.toString(),
          label: 'Total Staff',
          detail: `${Object.keys(homebase).length} active periods today`,
          status: 'success'
        }
      ];
    }

    // Labor Hours Chart Implementation
    async function loadLaborHoursChart() {
      try {
        const laborData = await getComprehensiveLaborData(currentLaborPeriod);
        
        if (laborChart) {
          laborChart.destroy();
        }
        
        const ctx = document.getElementById('labor-hours-chart').getContext('2d');
        laborChart = createLaborHoursChart(ctx, laborData);
        
      } catch (error) {
        console.error('‚ùå Labor chart error:', error);
      }
    }

    // Create Chart.js labor hours chart
    function createLaborHoursChart(ctx, laborData) {
      const periods = Object.keys(laborData.homebase).sort();
      const labels = periods.map(period => formatChartLabel(period, currentLaborPeriod));
      const scheduledData = periods.map(period => laborData.homebase[period].scheduledHours);
      const actualData = periods.map(period => laborData.homebase[period].actualHours);
      
      return new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Scheduled Hours',
              data: scheduledData,
              backgroundColor: 'rgba(102, 126, 234, 0.7)',
              borderColor: '#667eea',
              borderWidth: 1
            },
            {
              label: 'Actual Hours',
              data: actualData,
              backgroundColor: 'rgba(34, 197, 94, 0.7)',
              borderColor: '#22c55e',
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: 'Scheduled vs Actual Labor Hours'
            },
            legend: {
              position: 'top'
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Hours'
              }
            }
          }
        }
      });
    }

    // Labor by Role Implementation
    async function loadLaborByRole() {
      try {
        const employees = await callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/employees`);
        const roleData = analyzeLaborByRole(employees);
        
        const rolesHTML = roleData.map(role => `
          <div class="role-item">
            <div>
              <div class="role-name">${role.name}</div>
              <div class="role-hours">${role.hours.toFixed(1)} hrs</div>
            </div>
            <div class="role-cost">$${role.cost.toFixed(0)}</div>
          </div>
        `).join('');
        
        document.getElementById('labor-by-role-list').innerHTML = rolesHTML;
        
      } catch (error) {
        console.error('‚ùå Labor by role error:', error);
        document.getElementById('labor-by-role-list').innerHTML = '<div class="error">Failed to load roles</div>';
      }
    }

    // Analyze labor distribution by role
    function analyzeLaborByRole(employees) {
      const roleStats = {};
      
      employees.forEach(employee => {
        const role = employee.role || employee.position || 'No Role';
        const wage = employee.wage || 15; // Default $15/hour
        const hoursWorked = 8; // Placeholder - would need timecard data
        
        if (!roleStats[role]) {
          roleStats[role] = { hours: 0, cost: 0, count: 0 };
        }
        
        roleStats[role].hours += hoursWorked;
        roleStats[role].cost += hoursWorked * wage;
        roleStats[role].count += 1;
      });
      
      return Object.entries(roleStats)
        .map(([name, stats]) => ({ name, ...stats }))
        .sort((a, b) => b.hours - a.hours)
        .slice(0, 6); // Top 6 roles
    }

    // On-Time Performance Implementation  
    async function loadOnTimePerformance() {
      try {
        const today = getPacificDate(); // Use Pacific timezone instead of UTC
        const timecards = await callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/timecards?start_date=${today}&end_date=${today}`);
        const shifts = await callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/shifts?start_date=${today}&end_date=${today}`);
        
        const onTimeStats = calculateOnTimePerformance(timecards, shifts);
        
        const performanceHTML = `
          <div class="on-time-indicator">
            <div class="on-time-percentage ${onTimeStats.status}">${onTimeStats.percentage}%</div>
            <div style="font-size: 12px; color: #666; margin-bottom: 10px;">On-Time Rate</div>
          </div>
          <div class="on-time-breakdown">
            <div class="on-time-stat">
              <div style="font-weight: 600; color: #22c55e;">${onTimeStats.onTime}</div>
              <div>On-Time</div>
            </div>
            <div class="on-time-stat">
              <div style="font-weight: 600; color: #ef4444;">${onTimeStats.late}</div>
              <div>Late</div>
            </div>
            <div class="on-time-stat">
              <div style="font-weight: 600; color: #22c55e;">${onTimeStats.early}</div>
              <div>Early</div>
            </div>
          </div>
        `;
        
        document.getElementById('on-time-performance').innerHTML = performanceHTML;
        
      } catch (error) {
        console.error('‚ùå On-time performance error:', error);
        document.getElementById('on-time-performance').innerHTML = '<div class="error">Failed to load performance</div>';
      }
    }

    // Calculate on-time performance metrics
    function calculateOnTimePerformance(timecards, shifts) {
      let onTime = 0, late = 0, early = 0;
      
      timecards.forEach(timecard => {
        if (timecard.clock_in && timecard.scheduled_start) {
          const clockIn = new Date(timecard.clock_in);
          const scheduled = new Date(timecard.scheduled_start);
          const diffMinutes = (clockIn - scheduled) / (1000 * 60);
          
          if (Math.abs(diffMinutes) <= 5) {
            onTime++;
          } else if (diffMinutes > 5) {
            late++;
          } else {
            early++;
          }
        }
      });
      
      const total = onTime + late + early;
      const percentage = total > 0 ? Math.round((onTime / total) * 100) : 0;
      
      const status = percentage >= 80 ? 'good' : percentage >= 60 ? 'warning' : 'poor';
      
      return { onTime, late, early, percentage, status };
    }

    // Staff Exceptions Implementation
    async function loadStaffExceptions() {
      try {
        const today = getPacificDate(); // Use Pacific timezone instead of UTC
        const timecards = await callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/timecards?start_date=${today}&end_date=${today}`);
        const employees = await callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/employees`);
        
        const exceptions = findStaffExceptions(timecards, employees);
        
        const exceptionsHTML = exceptions.map(exception => `
          <div class="exception-item ${exception.type}">
            <div>
              <div class="exception-staff">${exception.name}</div>
              <div class="exception-detail">${exception.detail}</div>
            </div>
            <div class="exception-time">${exception.time}</div>
          </div>
        `).join('');
        
        document.getElementById('staff-exceptions-list').innerHTML = exceptionsHTML || '<div class="no-exceptions">No exceptions today</div>';
        
      } catch (error) {
        console.error('‚ùå Staff exceptions error:', error);
        document.getElementById('staff-exceptions-list').innerHTML = '<div class="error">Failed to load exceptions</div>';
      }
    }

    // Find staff attendance exceptions
    function findStaffExceptions(timecards, employees) {
      const exceptions = [];
      const employeeMap = {};
      
      employees.forEach(emp => {
        employeeMap[emp.id] = emp;
      });
      
      timecards.forEach(timecard => {
        if (timecard.clock_in && timecard.scheduled_start) {
          const employee = employeeMap[timecard.employee_id];
          if (!employee) return;
          
          const clockIn = new Date(timecard.clock_in);
          const scheduled = new Date(timecard.scheduled_start);
          const diffMinutes = Math.round((clockIn - scheduled) / (1000 * 60));
          
          if (Math.abs(diffMinutes) > 5) {
            const name = `${employee.first_name || 'Unknown'} ${(employee.last_name || '').charAt(0)}.`;
            const type = diffMinutes > 0 ? 'exception-late' : 'exception-early';
            const detail = diffMinutes > 0 ? 
              `${diffMinutes} mins late` : 
              `${Math.abs(diffMinutes)} mins early`;
            const time = clockIn.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
            
            exceptions.push({ name, detail, time, type, diffMinutes: Math.abs(diffMinutes) });
          }
        }
      });
      
      return exceptions
        .sort((a, b) => b.diffMinutes - a.diffMinutes)
        .slice(0, 5); // Top 5 exceptions
    }

    // Labor Efficiency Metrics Implementation
    async function loadLaborEfficiencyMetrics() {
      try {
        const laborData = await getComprehensiveLaborData(currentLaborPeriod);
        const efficiencyMetrics = calculateEfficiencyMetrics(laborData);
        
        const metricsHTML = efficiencyMetrics.map(metric => `
          <div class="efficiency-metric">
            <div class="efficiency-value">${metric.value}</div>
            <div class="efficiency-label">${metric.label}</div>
            <div class="efficiency-trend ${metric.trendType}">${metric.trend}</div>
          </div>
        `).join('');
        
        document.getElementById('efficiency-metrics').innerHTML = metricsHTML;
        
      } catch (error) {
        console.error('‚ùå Efficiency metrics error:', error);
        document.getElementById('efficiency-metrics').innerHTML = '<div class="error">Failed to load efficiency metrics</div>';
      }
    }

    // Calculate comprehensive efficiency metrics
    function calculateEfficiencyMetrics(laborData) {
      const { homebase, toast } = laborData;
      
      const totalRevenue = Object.values(toast).reduce((sum, period) => sum + period.revenue, 0);
      const totalActualHours = Object.values(homebase).reduce((sum, period) => sum + period.actualHours, 0);
      const totalLaborCost = totalActualHours * 15;
      const totalOrders = Object.values(toast).reduce((sum, period) => sum + period.orders, 0);
      
      return [
        {
          value: `$${(totalRevenue / totalActualHours || 0).toFixed(0)}`,
          label: 'Revenue/Hour',
          trend: '+5.2% vs last period',
          trendType: 'positive'
        },
        {
          value: `${((totalLaborCost / totalRevenue) * 100 || 0).toFixed(1)}%`,
          label: 'Labor Cost %',
          trend: '-2.1% vs target',
          trendType: 'positive'
        },
        {
          value: `${(totalOrders / totalActualHours || 0).toFixed(1)}`,
          label: 'Orders/Hour',
          trend: '+8.3% vs yesterday',
          trendType: 'positive'
        },
        {
          value: `${(totalActualHours / (totalOrders || 1) * 60).toFixed(0)}`,
          label: 'Mins/Order',
          trend: '-3.2% efficiency gain',
          trendType: 'positive'
        }
      ];
    }

    // Labor Period Change Handler
    function changeLaborPeriod(period) {
      currentLaborPeriod = period;
      
      // Update button states
      document.querySelectorAll('.period-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      // Reload labor analytics
      console.log(`üë• Changing labor period to: ${period}`);
      loadLaborAnalytics();
    }

    // Error handler for labor analytics
    function showLaborAnalyticsError(message) {
      const errorHTML = `<div class="error">Labor Analytics Error: ${message}</div>`;
      document.getElementById('labor-summary-cards').innerHTML = errorHTML;
    }

    // ==================== END LABOR ANALYTICS ====================
  </script>
</body>
</html>