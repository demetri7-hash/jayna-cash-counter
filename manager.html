<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, viewport-fit=cover">
  <title>Jayna Gyro Manager Portal</title>
  
  <link rel="apple-touch-icon" href="https://static.spotapps.co/website_images/ab_websites/229800_website_v1/logo.png">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#667eea">
  
  <!-- Chart.js for SalesChart component -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <!-- Supabase Client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
      min-height: 100vh; 
      padding: 5px;
      overflow-x: hidden;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    .container { 
      max-width: 1200px; 
      margin: 0 auto; 
      background: white; 
      border-radius: 20px; 
      overflow: visible;
      box-shadow: 0 20px 40px rgba(0,0,0,0.1);
      min-height: auto;
      max-height: none;
    }
    
    .header { 
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); 
      color: white; 
      text-align: center; 
      padding: 20px; 
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .header h1 { 
      font-size: 24px; 
      font-weight: 700; 
      margin-bottom: 5px; 
    }
    
    .header p { 
      opacity: 0.9; 
      font-size: 14px; 
    }
    
    .header-info {
      text-align: left;
      flex: 1;
    }
    
    .nav-links {
      display: flex;
      gap: 15px;
      align-items: center;
    }
    
    .nav-link {
      color: white;
      text-decoration: none;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s ease;
      background: rgba(255,255,255,0.1);
    }
    
    .nav-link:hover {
      background: rgba(255,255,255,0.2);
      transform: translateY(-1px);
    }
    
    .content { 
      padding: 20px; 
      max-height: none;
      overflow: visible;
    }
    
    /* Component Cards */
    .dashboard-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }
    
    @media (min-width: 768px) {
      .dashboard-grid {
        grid-template-columns: 1fr 1fr;
      }
    }
    
    @media (min-width: 1024px) {
      .dashboard-grid {
        grid-template-columns: 2fr 1fr;
      }
    }
    
    .component-card {
      background: white;
      border-radius: 15px;
      border: 2px solid #e0e0e0;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      overflow: hidden;
      transition: all 0.3s ease;
    }
    
    .component-card:hover {
      border-color: #667eea;
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    }
    
    .card-header {
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      padding: 15px 20px;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .card-title {
      font-size: 18px;
      font-weight: 600;
      color: #333;
      margin: 0;
    }
    
    .card-subtitle {
      font-size: 12px;
      color: #666;
      margin: 0;
    }
    
    .card-body {
      padding: 20px;
    }
    
    .status-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: #666;
    }
    
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #22c55e;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    /* LiveMetrics Styles */
    .metrics-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }
    
    @media (min-width: 768px) {
      .metrics-grid {
        grid-template-columns: 1fr 1fr 1fr 1fr;
      }
    }
    
    .metric-card {
      padding: 15px;
      border-radius: 10px;
      border: 2px solid #e0e0e0;
      text-align: center;
      transition: all 0.3s ease;
    }
    
    .metric-card.normal { border-color: #3b82f6; background: #eff6ff; }
    .metric-card.good { border-color: #22c55e; background: #f0fdf4; }
    .metric-card.warning { border-color: #f59e0b; background: #fffbeb; }
    .metric-card.error { border-color: #ef4444; background: #fef2f2; }
    
    .metric-value {
      font-size: 24px;
      font-weight: bold;
      color: #333;
      margin-bottom: 5px;
    }
    
    .metric-label {
      font-size: 14px;
      font-weight: 600;
      color: #555;
      margin-bottom: 5px;
    }
    
    .metric-detail {
      font-size: 12px;
      color: #666;
    }
    
    /* StatsCards Styles */
    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }
    
    @media (min-width: 768px) {
      .stats-grid {
        grid-template-columns: 1fr 1fr 1fr 1fr;
      }
    }
    
    .stat-card {
      padding: 15px;
      border-radius: 10px;
      background: #f8f9fa;
      border: 1px solid #e9ecef;
      text-align: center;
    }
    
    .stat-value {
      font-size: 20px;
      font-weight: bold;
      color: #333;
      margin-bottom: 5px;
    }
    
    .stat-label {
      font-size: 12px;
      font-weight: 600;
      color: #555;
      margin-bottom: 5px;
    }
    
    .stat-change {
      font-size: 11px;
      font-weight: 500;
    }
    
    .stat-change.positive { color: #22c55e; }
    .stat-change.negative { color: #ef4444; }
    
    /* Chart Styles */
    .chart-container {
      position: relative;
      height: 300px;
      width: 100%;
    }
    
    .chart-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      justify-content: center;
    }
    
    .chart-btn {
      padding: 6px 12px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      background: white;
      color: #374151;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .chart-btn.active {
      background: #667eea;
      color: white;
      border-color: #667eea;
    }
    
    .chart-btn:hover {
      border-color: #667eea;
    }
    
    /* TopItems Styles */
    .items-list {
      space-y: 10px;
    }
    
    .item-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid #f0f0f0;
    }
    
    .item-row:last-child {
      border-bottom: none;
    }
    
    .item-info {
      flex: 1;
    }
    
    .item-name {
      font-weight: 600;
      color: #333;
      font-size: 14px;
    }
    
    .item-stats {
      font-size: 12px;
      color: #666;
    }
    
    .item-trend {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 12px;
    }
    
    .trend-up { color: #22c55e; }
    .trend-down { color: #ef4444; }
    .trend-stable { color: #6b7280; }
    
    /* Loading Styles */
    .loading {
      text-align: center;
      padding: 40px 20px;
      color: #666;
    }
    
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Error Styles */
    .error {
      text-align: center;
      padding: 20px;
      color: #ef4444;
      background: #fef2f2;
      border-radius: 8px;
      border: 1px solid #fecaca;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .header {
        flex-direction: column;
        gap: 15px;
        text-align: center;
      }
      
      .nav-links {
        flex-wrap: wrap;
        justify-content: center;
      }
      
      .dashboard-grid {
        grid-template-columns: 1fr;
      }
      
      .metrics-grid {
        grid-template-columns: 1fr 1fr;
      }
      
      .stats-grid {
        grid-template-columns: 1fr 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <div class="header-info">
        <h1>Manager Portal</h1>
        <p>Real-time analytics & labor management</p>
      </div>
      <div class="nav-links">
        <a href="index.html" class="nav-link">‚Üê Tip Calculator</a>
        <a href="#" class="nav-link" onclick="refreshAllData()">üîÑ Refresh</a>
      </div>
    </div>

    <!-- Content -->
    <div class="content">
      <!-- Live Metrics Row -->
      <div class="component-card">
        <div class="card-header">
          <div>
            <h2 class="card-title">Live Metrics</h2>
            <p class="card-subtitle">Real-time operational status</p>
          </div>
          <div class="status-indicator">
            <div class="status-dot"></div>
            <span id="live-metrics-status">Updated 30s ago</span>
          </div>
        </div>
        <div class="card-body">
          <div class="metrics-grid" id="live-metrics-grid">
            <div class="loading">
              <div class="loading-spinner"></div>
              Loading live metrics...
            </div>
          </div>
        </div>
      </div>

      <!-- Stats Cards & Top Items Row -->
      <div class="dashboard-grid">
        <!-- Stats Cards -->
        <div class="component-card">
          <div class="card-header">
            <div>
              <h2 class="card-title">Revenue Analytics</h2>
              <p class="card-subtitle">Today's performance metrics</p>
            </div>
          </div>
          <div class="card-body">
            <div class="stats-grid" id="stats-cards-grid">
              <div class="loading">
                <div class="loading-spinner"></div>
                Loading revenue data...
              </div>
            </div>
          </div>
        </div>

        <!-- Top Items -->
        <div class="component-card">
          <div class="card-header">
            <div>
              <h2 class="card-title">Best Sellers</h2>
              <p class="card-subtitle">Top performing menu items</p>
            </div>
          </div>
          <div class="card-body">
            <div class="items-list" id="top-items-list">
              <div class="loading">
                <div class="loading-spinner"></div>
                Loading top items...
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Sales Chart -->
      <div class="component-card">
        <div class="card-header">
          <div>
            <h2 class="card-title">Sales Trends</h2>
            <p class="card-subtitle">Revenue analysis over time</p>
          </div>
        </div>
        <div class="card-body">
          <div class="chart-controls">
            <button class="chart-btn active" onclick="changePeriod('day')">24 Hours</button>
            <button class="chart-btn" onclick="changePeriod('week')">7 Days</button>
            <button class="chart-btn" onclick="changePeriod('month')">30 Days</button>
          </div>
          <div class="chart-container">
            <canvas id="sales-chart"></canvas>
          </div>
        </div>
      </div>

      <!-- Recent Orders -->
      <div class="component-card">
        <div class="card-header">
          <div>
            <h2 class="card-title">Recent Orders</h2>
            <p class="card-subtitle">Live order feed & status</p>
          </div>
        </div>
        <div class="card-body">
          <div id="recent-orders-list">
            <div class="loading">
              <div class="loading-spinner"></div>
              Loading recent orders...
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Configuration from .env file
    const CONFIG = {
      // Toast API
      TOAST_CLIENT_ID: '3g0R0NFYjHIQcVe9bYP8eTbJjwRTvCNV',
      TOAST_CLIENT_SECRET: 'dClMNN5GmpgCZYU8BtTK9NGCVT4eAmZtE0E4EkJO4CFpPJx2rXP26PTptwSe--Sa',
      TOAST_RESTAURANT_GUID: 'd3efae34-7c2e-4107-a442-49081e624706',
      TOAST_BASE_URL: 'https://ws-api.toasttab.com',
      
      // Homebase API
      HOMEBASE_API_KEY: 'xRHgIepMv-XB58UK8D1hoJwh1ALNPoH1PvPiwrLhoTM',
      HOMEBASE_LOCATION_UUID: '0b6c1af3-4904-4b84-ae5f-d1172d77de27',
      HOMEBASE_BASE_URL: 'https://app.joinhomebase.com/api/public',
      
      // Supabase (from existing app)
      SUPABASE_URL: 'https://poxfcqjmdivnfftqccjq.supabase.co',
      SUPABASE_ANON_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBveGZjcWptZGl2bmZmdHFjY2pxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjczNzI2ODIsImV4cCI6MjA0Mjk0ODY4Mn0.j9zlgzFNLWkJ4zqYS0TCMBDVKFtVyRnJcdWYgpEpGWU'
    };

    // Initialize Supabase client
    const supabase = window.supabase.createClient(CONFIG.SUPABASE_URL, CONFIG.SUPABASE_ANON_KEY);

    // Global state
    let toastToken = null;
    let salesChart = null;
    let currentPeriod = 'day';

    // Initialize the manager portal
    async function initManagerPortal() {
      console.log('üöÄ Initializing Manager Portal...');
      
      try {
        // Get Toast authentication token
        await getToastToken();
        
        // Load all components
        await Promise.all([
          loadLiveMetrics(),
          loadStatsCards(),
          loadTopItems(),
          loadSalesChart(),
          loadRecentOrders()
        ]);
        
        console.log('‚úÖ Manager Portal initialized successfully');
        
        // Set up auto-refresh every 30 seconds
        setInterval(refreshLiveData, 30000);
        
      } catch (error) {
        console.error('‚ùå Error initializing Manager Portal:', error);
        showError('Failed to initialize Manager Portal. Please refresh the page.');
      }
    }

    // Toast API Authentication
    async function getToastToken() {
      if (toastToken) return toastToken;
      
      try {
        const response = await fetch(`${CONFIG.TOAST_BASE_URL}/authentication/v1/authentication/login`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body: JSON.stringify({
            clientId: CONFIG.TOAST_CLIENT_ID,
            clientSecret: CONFIG.TOAST_CLIENT_SECRET,
            userAccessType: 'TOAST_MACHINE_CLIENT'
          })
        });

        const data = await response.json();
        
        if (data.status === 'SUCCESS' && data.token) {
          toastToken = data.token.accessToken;
          console.log('‚úÖ Toast authentication successful');
          return toastToken;
        } else {
          throw new Error('Toast authentication failed');
        }
      } catch (error) {
        console.error('‚ùå Toast authentication error:', error);
        throw error;
      }
    }

    // Homebase API Helper
    async function callHomebaseAPI(endpoint) {
      try {
        const response = await fetch(`${CONFIG.HOMEBASE_BASE_URL}${endpoint}`, {
          headers: {
            'Authorization': `Bearer ${CONFIG.HOMEBASE_API_KEY}`,
            'Accept': 'application/vnd.homebase-v1+json'
          }
        });

        if (!response.ok) {
          throw new Error(`Homebase API error: ${response.status}`);
        }

        return await response.json();
      } catch (error) {
        console.error('‚ùå Homebase API error:', error);
        throw error;
      }
    }

    // Toast API Helper
    async function callToastAPI(endpoint) {
      try {
        await getToastToken();
        
        const response = await fetch(`${CONFIG.TOAST_BASE_URL}${endpoint}`, {
          headers: {
            'Authorization': `Bearer ${toastToken}`,
            'Toast-Restaurant-External-ID': CONFIG.TOAST_RESTAURANT_GUID
          }
        });

        if (!response.ok) {
          throw new Error(`Toast API error: ${response.status}`);
        }

        return await response.json();
      } catch (error) {
        console.error('‚ùå Toast API error:', error);
        throw error;
      }
    }

    // LiveMetrics Implementation - Real Toast + Homebase Data
    async function loadLiveMetrics() {
      console.log('üìä Loading Live Metrics with real Toast + Homebase data...');
      
      try {
        // Fetch data from both APIs in parallel
        const [toastData, homebaseData] = await Promise.all([
          getToastLiveData(),
          getHomebaseLiveData()
        ]);
        
        // Calculate live metrics
        const metrics = calculateLiveMetrics(toastData, homebaseData);
        
        // Render metrics
        const metricsHTML = `
          <div class="metric-card ${metrics.ordersQueue.status}">
            <div class="metric-value">${metrics.ordersQueue.value}</div>
            <div class="metric-label">Orders in Queue</div>
            <div class="metric-detail">${metrics.ordersQueue.detail}</div>
          </div>
          <div class="metric-card ${metrics.staffOnDuty.status}">
            <div class="metric-value">${metrics.staffOnDuty.value}</div>
            <div class="metric-label">Staff On Duty</div>
            <div class="metric-detail">${metrics.staffOnDuty.detail}</div>
          </div>
          <div class="metric-card ${metrics.revenueToday.status}">
            <div class="metric-value">${metrics.revenueToday.value}</div>
            <div class="metric-label">Revenue Today</div>
            <div class="metric-detail">${metrics.revenueToday.detail}</div>
          </div>
          <div class="metric-card ${metrics.laborEfficiency.status}">
            <div class="metric-value">${metrics.laborEfficiency.value}</div>
            <div class="metric-label">Labor Efficiency</div>
            <div class="metric-detail">${metrics.laborEfficiency.detail}</div>
          </div>
        `;
        
        document.getElementById('live-metrics-grid').innerHTML = metricsHTML;
        console.log('‚úÖ Live Metrics loaded with real data:', metrics);
        
      } catch (error) {
        console.error('‚ùå Error loading Live Metrics:', error);
        document.getElementById('live-metrics-grid').innerHTML = '<div class="error">Failed to load live metrics: ' + error.message + '</div>';
      }
    }

    // Get real-time data from Toast API
    async function getToastLiveData() {
      try {
        const today = new Date().toISOString().split('T')[0];
        
        // Get today's orders for queue analysis
        const ordersResponse = await callToastAPI(`/orders/v2/orders?startDate=${today}&endDate=${today}&pageSize=50`);
        
        // Get restaurant info for operational status
        const restaurantResponse = await callToastAPI('/restaurants/v1/restaurants/' + CONFIG.TOAST_RESTAURANT_GUID);
        
        // Calculate revenue from today's orders
        const todayRevenue = ordersResponse.reduce((sum, order) => {
          if (order.status !== 'VOIDED' && order.status !== 'CANCELLED') {
            return sum + (order.amount || 0);
          }
          return sum;
        }, 0) / 100; // Toast amounts are in cents
        
        // Analyze order queue (orders not yet closed/delivered)
        const activeOrders = ordersResponse.filter(order => 
          order.status && !['CLOSED', 'VOIDED', 'CANCELLED'].includes(order.status)
        );
        
        // Calculate average preparation time
        const avgPrepTime = calculateAveragePreparationTime(ordersResponse);
        
        return {
          orders: ordersResponse,
          activeOrders: activeOrders,
          todayRevenue: todayRevenue,
          avgPrepTime: avgPrepTime,
          restaurant: restaurantResponse
        };
        
      } catch (error) {
        console.error('‚ùå Toast API error:', error);
        throw new Error('Toast API connection failed');
      }
    }

    // Get real-time data from Homebase API
    async function getHomebaseLiveData() {
      try {
        // Get current employees
        const employeesResponse = await callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/employees`);
        
        // Get today's timecards to see who's clocked in
        const today = new Date().toISOString().split('T')[0];
        const timecardsResponse = await callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/timecards?date=${today}`);
        
        // Get today's shifts for scheduling comparison
        const shiftsResponse = await callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/shifts?date=${today}`);
        
        // Calculate who's currently on duty (clocked in)
        const currentlyWorking = timecardsResponse.filter(timecard => 
          timecard.clock_in && !timecard.clock_out
        );
        
        // Calculate labor costs
        const laborCosts = calculateLaborCosts(timecardsResponse, employeesResponse);
        
        return {
          employees: employeesResponse,
          timecards: timecardsResponse,
          shifts: shiftsResponse,
          currentlyWorking: currentlyWorking,
          laborCosts: laborCosts
        };
        
      } catch (error) {
        console.error('‚ùå Homebase API error:', error);
        throw new Error('Homebase API connection failed');
      }
    }

    // Calculate live metrics from Toast + Homebase data
    function calculateLiveMetrics(toastData, homebaseData) {
      // Orders Queue Analysis
      const ordersQueue = {
        value: toastData.activeOrders.length,
        status: toastData.activeOrders.length > 15 ? 'warning' : 
                toastData.activeOrders.length > 25 ? 'error' : 'good',
        detail: `Avg prep: ${Math.round(toastData.avgPrepTime)} min`
      };
      
      // Staff On Duty Analysis
      const staffCount = homebaseData.currentlyWorking.length;
      const scheduledCount = homebaseData.shifts.length;
      const staffOnDuty = {
        value: `${staffCount}/${scheduledCount}`,
        status: staffCount < scheduledCount * 0.8 ? 'warning' : 
                staffCount > scheduledCount * 1.2 ? 'error' : 'good',
        detail: getStaffBreakdown(homebaseData.currentlyWorking)
      };
      
      // Revenue Today Analysis
      const revenueToday = {
        value: `$${toastData.todayRevenue.toFixed(0)}`,
        status: 'good', // TODO: Compare with historical averages
        detail: `${toastData.orders.length} orders today`
      };
      
      // Labor Efficiency Analysis (Revenue per labor hour)
      const totalLaborHours = calculateTotalLaborHours(homebaseData.timecards);
      const revenuePerHour = totalLaborHours > 0 ? toastData.todayRevenue / totalLaborHours : 0;
      const laborEfficiency = {
        value: `$${revenuePerHour.toFixed(0)}/hr`,
        status: revenuePerHour > 50 ? 'good' : 
                revenuePerHour > 30 ? 'normal' : 'warning',
        detail: `${totalLaborHours.toFixed(1)} labor hrs today`
      };
      
      return {
        ordersQueue,
        staffOnDuty,
        revenueToday,
        laborEfficiency
      };
    }

    // Helper Functions
    function calculateAveragePreparationTime(orders) {
      const completedOrders = orders.filter(order => 
        order.openedDate && order.closedDate
      );
      
      if (completedOrders.length === 0) return 15; // Default fallback
      
      const totalPrepTime = completedOrders.reduce((sum, order) => {
        const opened = new Date(order.openedDate);
        const closed = new Date(order.closedDate);
        return sum + (closed - opened);
      }, 0);
      
      return (totalPrepTime / completedOrders.length) / (1000 * 60); // Convert to minutes
    }

    function getStaffBreakdown(currentlyWorking) {
      // TODO: Categorize by role if available in Homebase data
      return `${currentlyWorking.length} staff active`;
    }

    function calculateTotalLaborHours(timecards) {
      return timecards.reduce((total, timecard) => {
        if (timecard.clock_in) {
          const clockIn = new Date(timecard.clock_in);
          const clockOut = timecard.clock_out ? new Date(timecard.clock_out) : new Date();
          const hours = (clockOut - clockIn) / (1000 * 60 * 60);
          return total + Math.max(0, hours);
        }
        return total;
      }, 0);
    }

    function calculateLaborCosts(timecards, employees) {
      // TODO: Calculate actual labor costs if hourly rates are available
      return timecards.length * 15; // Placeholder: $15/hour average
    }

    // StatsCards Implementation - Real Toast Analytics Data
    async function loadStatsCards() {
      console.log('üìà Loading Stats Cards with real Toast analytics...');
      
      try {
        // Get comprehensive Toast analytics data
        const analyticsData = await getToastAnalyticsData();
        
        // Calculate trend comparisons
        const stats = calculateStatsWithTrends(analyticsData);
        
        // Render stats cards
        const statsHTML = `
          <div class="stat-card">
            <div class="stat-value">${stats.revenue.value}</div>
            <div class="stat-label">Today's Revenue</div>
            <div class="stat-change ${stats.revenue.changeType}">${stats.revenue.change}</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${stats.orders.value}</div>
            <div class="stat-label">Orders Today</div>
            <div class="stat-change ${stats.orders.changeType}">${stats.orders.change}</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${stats.avgOrder.value}</div>
            <div class="stat-label">Avg Order Value</div>
            <div class="stat-change ${stats.avgOrder.changeType}">${stats.avgOrder.change}</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${stats.menuItems.value}</div>
            <div class="stat-label">Active Items</div>
            <div class="stat-change ${stats.menuItems.changeType}">${stats.menuItems.change}</div>
          </div>
        `;
        
        document.getElementById('stats-cards-grid').innerHTML = statsHTML;
        console.log('‚úÖ Stats Cards loaded with real analytics:', stats);
        
      } catch (error) {
        console.error('‚ùå Error loading Stats Cards:', error);
        document.getElementById('stats-cards-grid').innerHTML = '<div class="error">Failed to load revenue stats: ' + error.message + '</div>';
      }
    }

    // Get comprehensive Toast analytics data
    async function getToastAnalyticsData() {
      try {
        const today = new Date();
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);
        const lastWeek = new Date(today);
        lastWeek.setDate(lastWeek.getDate() - 7);
        
        // Format dates for Toast API
        const todayStr = today.toISOString().split('T')[0];
        const yesterdayStr = yesterday.toISOString().split('T')[0];
        const lastWeekStr = lastWeek.toISOString().split('T')[0];
        
        // Fetch data in parallel
        const [todayOrders, yesterdayOrders, lastWeekOrders, menuItems] = await Promise.all([
          callToastAPI(`/orders/v2/orders?startDate=${todayStr}&endDate=${todayStr}&pageSize=200`),
          callToastAPI(`/orders/v2/orders?startDate=${yesterdayStr}&endDate=${yesterdayStr}&pageSize=200`),
          callToastAPI(`/orders/v2/orders?startDate=${lastWeekStr}&endDate=${lastWeekStr}&pageSize=200`),
          callToastAPI('/menus/v2/menus')
        ]);
        
        return {
          today: analyzeOrders(todayOrders),
          yesterday: analyzeOrders(yesterdayOrders),
          lastWeek: analyzeOrders(lastWeekOrders),
          menuItems: analyzeMenuItems(menuItems)
        };
        
      } catch (error) {
        console.error('‚ùå Toast analytics error:', error);
        throw new Error('Failed to fetch Toast analytics data');
      }
    }

    // Analyze orders data for revenue and metrics
    function analyzeOrders(orders) {
      const validOrders = orders.filter(order => 
        order.status && !['VOIDED', 'CANCELLED'].includes(order.status)
      );
      
      const totalRevenue = validOrders.reduce((sum, order) => {
        return sum + ((order.amount || 0) / 100); // Toast amounts are in cents
      }, 0);
      
      const avgOrderValue = validOrders.length > 0 ? totalRevenue / validOrders.length : 0;
      
      return {
        count: validOrders.length,
        revenue: totalRevenue,
        avgOrderValue: avgOrderValue,
        rawOrders: validOrders
      };
    }

    // Analyze menu items for active count
    function analyzeMenuItems(menuData) {
      if (!menuData || !Array.isArray(menuData)) {
        return { activeCount: 0, totalCount: 0 };
      }
      
      let activeCount = 0;
      let totalCount = 0;
      
      menuData.forEach(menu => {
        if (menu.items && Array.isArray(menu.items)) {
          menu.items.forEach(item => {
            totalCount++;
            if (item.visibility === 'VISIBLE' || item.visibility === 'AVAILABLE') {
              activeCount++;
            }
          });
        }
      });
      
      return { activeCount, totalCount };
    }

    // Calculate stats with trend comparisons
    function calculateStatsWithTrends(analyticsData) {
      // Revenue comparison
      const revenueChange = calculatePercentChange(analyticsData.today.revenue, analyticsData.yesterday.revenue);
      const revenue = {
        value: `$${analyticsData.today.revenue.toFixed(2)}`,
        change: `${revenueChange >= 0 ? '+' : ''}${revenueChange.toFixed(1)}% vs yesterday`,
        changeType: revenueChange >= 0 ? 'positive' : 'negative'
      };
      
      // Orders comparison
      const ordersChange = calculatePercentChange(analyticsData.today.count, analyticsData.yesterday.count);
      const orders = {
        value: analyticsData.today.count.toString(),
        change: `${ordersChange >= 0 ? '+' : ''}${ordersChange.toFixed(1)}% vs yesterday`,
        changeType: ordersChange >= 0 ? 'positive' : 'negative'
      };
      
      // Average order value comparison (vs last week for more stable comparison)
      const avgOrderChange = calculatePercentChange(analyticsData.today.avgOrderValue, analyticsData.lastWeek.avgOrderValue);
      const avgOrder = {
        value: `$${analyticsData.today.avgOrderValue.toFixed(2)}`,
        change: `${avgOrderChange >= 0 ? '+' : ''}${avgOrderChange.toFixed(1)}% vs last week`,
        changeType: avgOrderChange >= 0 ? 'positive' : 'negative'
      };
      
      // Menu items status
      const menuItems = {
        value: analyticsData.menuItems.activeCount.toString(),
        change: `of ${analyticsData.menuItems.totalCount} total items`,
        changeType: 'positive' // Neutral display
      };
      
      return { revenue, orders, avgOrder, menuItems };
    }

    // Calculate percentage change between two values
    function calculatePercentChange(current, previous) {
      if (previous === 0) return current > 0 ? 100 : 0;
      return ((current - previous) / previous) * 100;
    }

    // TopItems Implementation - Real Toast Menu Analytics
    async function loadTopItems() {
      console.log('üèÜ Loading Top Items with real Toast menu analytics...');
      
      try {
        // Get comprehensive menu performance data
        const menuAnalytics = await getToastMenuAnalytics();
        
        // Analyze and rank top items
        const topItems = analyzeTopSellingItems(menuAnalytics);
        
        // Render top items list
        const itemsHTML = topItems.map(item => `
          <div class="item-row">
            <div class="item-info">
              <div class="item-name">${item.name}</div>
              <div class="item-stats">${item.orders} orders ‚Ä¢ $${item.revenue.toFixed(2)}</div>
            </div>
            <div class="item-trend ${item.trend.class}">${item.trend.icon} ${item.trend.text}</div>
          </div>
        `).join('');
        
        document.getElementById('top-items-list').innerHTML = itemsHTML;
        console.log('‚úÖ Top Items loaded with real menu analytics:', topItems);
        
      } catch (error) {
        console.error('‚ùå Error loading Top Items:', error);
        document.getElementById('top-items-list').innerHTML = '<div class="error">Failed to load top items: ' + error.message + '</div>';
      }
    }

    // Get Toast menu analytics with order performance
    async function getToastMenuAnalytics() {
      try {
        const today = new Date();
        const weekAgo = new Date(today);
        weekAgo.setDate(weekAgo.getDate() - 7);
        const twoWeeksAgo = new Date(today);
        twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);
        
        // Format dates
        const todayStr = today.toISOString().split('T')[0];
        const weekAgoStr = weekAgo.toISOString().split('T')[0];
        const twoWeeksAgoStr = twoWeeksAgo.toISOString().split('T')[0];
        
        // Fetch menu data and recent orders with selections
        const [menuData, recentOrders, previousWeekOrders] = await Promise.all([
          callToastAPI('/menus/v2/menus'),
          callToastAPI(`/orders/v2/orders?startDate=${weekAgoStr}&endDate=${todayStr}&pageSize=500`),
          callToastAPI(`/orders/v2/orders?startDate=${twoWeeksAgoStr}&endDate=${weekAgoStr}&pageSize=500`)
        ]);
        
        return {
          menus: menuData,
          recentOrders: recentOrders,
          previousWeekOrders: previousWeekOrders
        };
        
      } catch (error) {
        console.error('‚ùå Toast menu analytics error:', error);
        throw new Error('Failed to fetch menu analytics data');
      }
    }

    // Analyze top-selling items from orders data
    function analyzeTopSellingItems(analytics) {
      // Create menu item lookup map
      const menuItemMap = createMenuItemMap(analytics.menus);
      
      // Analyze recent week performance
      const recentPerformance = analyzeOrderItems(analytics.recentOrders, menuItemMap);
      
      // Analyze previous week for trend comparison
      const previousPerformance = analyzeOrderItems(analytics.previousWeekOrders, menuItemMap);
      
      // Create top items with trends
      const topItems = Object.values(recentPerformance)
        .sort((a, b) => b.orders - a.orders) // Sort by order count
        .slice(0, 5) // Top 5 items
        .map(item => {
          const previousItem = previousPerformance[item.guid] || { orders: 0, revenue: 0 };
          const trend = calculateItemTrend(item, previousItem);
          
          return {
            ...item,
            trend
          };
        });
      
      return topItems;
    }

    // Create menu item lookup map from Toast menu data
    function createMenuItemMap(menuData) {
      const itemMap = {};
      
      if (!menuData || !Array.isArray(menuData)) return itemMap;
      
      menuData.forEach(menu => {
        if (menu.items && Array.isArray(menu.items)) {
          menu.items.forEach(item => {
            itemMap[item.guid] = {
              guid: item.guid,
              name: item.name || 'Unknown Item',
              price: item.price || 0,
              category: menu.name || 'Uncategorized'
            };
          });
        }
      });
      
      return itemMap;
    }

    // Analyze items from orders data
    function analyzeOrderItems(orders, menuItemMap) {
      const itemPerformance = {};
      
      orders.forEach(order => {
        if (order.selections && Array.isArray(order.selections)) {
          order.selections.forEach(selection => {
            if (selection.item && selection.item.guid) {
              const itemGuid = selection.item.guid;
              const menuItem = menuItemMap[itemGuid];
              
              if (menuItem) {
                if (!itemPerformance[itemGuid]) {
                  itemPerformance[itemGuid] = {
                    guid: itemGuid,
                    name: menuItem.name,
                    category: menuItem.category,
                    orders: 0,
                    revenue: 0,
                    quantity: 0
                  };
                }
                
                const quantity = selection.quantity || 1;
                const price = (selection.price || menuItem.price || 0) / 100; // Toast prices in cents
                
                itemPerformance[itemGuid].orders += 1;
                itemPerformance[itemGuid].quantity += quantity;
                itemPerformance[itemGuid].revenue += price * quantity;
              }
            }
          });
        }
      });
      
      return itemPerformance;
    }

    // Calculate trend for an item compared to previous period
    function calculateItemTrend(currentItem, previousItem) {
      const currentOrders = currentItem.orders;
      const previousOrders = previousItem.orders;
      
      if (previousOrders === 0) {
        return currentOrders > 0 ? 
          { class: 'trend-up', icon: '‚ÜóÔ∏è', text: 'NEW!' } :
          { class: 'trend-stable', icon: '‚Üí', text: '0%' };
      }
      
      const changePercent = ((currentOrders - previousOrders) / previousOrders) * 100;
      
      if (changePercent > 10) {
        return { class: 'trend-up', icon: '‚ÜóÔ∏è', text: `+${changePercent.toFixed(0)}%` };
      } else if (changePercent < -10) {
        return { class: 'trend-down', icon: '‚ÜòÔ∏è', text: `${changePercent.toFixed(0)}%` };
      } else {
        return { class: 'trend-stable', icon: '‚Üí', text: `${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(0)}%` };
      }
    }

    // SalesChart Implementation - Real Toast + Homebase Analytics with Chart.js
    async function loadSalesChart() {
      console.log('üìä Loading Sales Chart with comprehensive Toast + Homebase analytics...');
      
      try {
        // Get comprehensive analytics data for current period
        const chartAnalytics = await getSalesChartData(currentPeriod);
        
        // Create or update the chart
        if (salesChart) {
          salesChart.destroy();
        }
        
        const ctx = document.getElementById('sales-chart').getContext('2d');
        salesChart = createSalesChart(ctx, chartAnalytics);
        
        console.log('‚úÖ Sales Chart loaded with real analytics:', chartAnalytics);
        
      } catch (error) {
        console.error('‚ùå Error loading Sales Chart:', error);
        const ctx = document.getElementById('sales-chart').getContext('2d');
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.fillStyle = '#ef4444';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Failed to load sales chart: ' + error.message, ctx.canvas.width/2, ctx.canvas.height/2);
      }
    }

    // Get comprehensive sales chart data with labor correlation
    async function getSalesChartData(period) {
      try {
        const dateRange = calculateDateRange(period);
        
        // Fetch Toast sales data and Homebase labor data in parallel
        const [salesData, laborData] = await Promise.all([
          getToastSalesData(dateRange),
          getHomebaseLaborData(dateRange)
        ]);
        
        // Combine and analyze data
        const combinedAnalytics = combineToastHomebaseData(salesData, laborData, period);
        
        return combinedAnalytics;
        
      } catch (error) {
        console.error('‚ùå Sales chart data error:', error);
        throw new Error('Failed to fetch comprehensive sales analytics');
      }
    }

    // Calculate date range based on period selection
    function calculateDateRange(period) {
      const endDate = new Date();
      const startDate = new Date();
      
      switch (period) {
        case 'day':
          // Last 24 hours by hour
          startDate.setDate(startDate.getDate() - 1);
          return { startDate, endDate, granularity: 'hour' };
        case 'week':
          // Last 7 days by day
          startDate.setDate(startDate.getDate() - 7);
          return { startDate, endDate, granularity: 'day' };
        case 'month':
          // Last 30 days by day
          startDate.setDate(startDate.getDate() - 30);
          return { startDate, endDate, granularity: 'day' };
        default:
          startDate.setDate(startDate.getDate() - 7);
          return { startDate, endDate, granularity: 'day' };
      }
    }

    // Get Toast sales data for the date range
    async function getToastSalesData(dateRange) {
      const startDateStr = dateRange.startDate.toISOString().split('T')[0];
      const endDateStr = dateRange.endDate.toISOString().split('T')[0];
      
      // Get all orders in the date range
      const orders = await callToastAPI(`/orders/v2/orders?startDate=${startDateStr}&endDate=${endDateStr}&pageSize=1000`);
      
      // Group orders by time period
      const salesByPeriod = groupOrdersByPeriod(orders, dateRange.granularity);
      
      return salesByPeriod;
    }

    // Get Homebase labor data for the date range
    async function getHomebaseLaborData(dateRange) {
      try {
        const startDateStr = dateRange.startDate.toISOString().split('T')[0];
        const endDateStr = dateRange.endDate.toISOString().split('T')[0];
        
        // Get timecards and shifts for the period
        const [timecards, shifts] = await Promise.all([
          callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/timecards?start_date=${startDateStr}&end_date=${endDateStr}`),
          callHomebaseAPI(`/locations/${CONFIG.HOMEBASE_LOCATION_UUID}/shifts?start_date=${startDateStr}&end_date=${endDateStr}`)
        ]);
        
        // Group labor data by time period
        const laborByPeriod = groupLaborByPeriod(timecards, shifts, dateRange.granularity);
        
        return laborByPeriod;
        
      } catch (error) {
        console.error('‚ùå Homebase labor data error:', error);
        return {}; // Return empty object if Homebase fails
      }
    }

    // Group orders by time period (hour/day)
    function groupOrdersByPeriod(orders, granularity) {
      const grouped = {};
      
      orders.forEach(order => {
        if (order.openedDate && order.status && !['VOIDED', 'CANCELLED'].includes(order.status)) {
          const orderDate = new Date(order.openedDate);
          const periodKey = granularity === 'hour' ? 
            `${orderDate.getFullYear()}-${String(orderDate.getMonth() + 1).padStart(2, '0')}-${String(orderDate.getDate()).padStart(2, '0')} ${String(orderDate.getHours()).padStart(2, '0')}:00` :
            `${orderDate.getFullYear()}-${String(orderDate.getMonth() + 1).padStart(2, '0')}-${String(orderDate.getDate()).padStart(2, '0')}`;
          
          if (!grouped[periodKey]) {
            grouped[periodKey] = {
              revenue: 0,
              orders: 0,
              avgOrderValue: 0
            };
          }
          
          const revenue = (order.amount || 0) / 100; // Toast amounts in cents
          grouped[periodKey].revenue += revenue;
          grouped[periodKey].orders += 1;
          grouped[periodKey].avgOrderValue = grouped[periodKey].revenue / grouped[periodKey].orders;
        }
      });
      
      return grouped;
    }

    // Group labor data by time period
    function groupLaborByPeriod(timecards, shifts, granularity) {
      const grouped = {};
      
      // Process timecards (actual hours)
      timecards.forEach(timecard => {
        if (timecard.clock_in) {
          const clockInDate = new Date(timecard.clock_in);
          const periodKey = granularity === 'hour' ? 
            `${clockInDate.getFullYear()}-${String(clockInDate.getMonth() + 1).padStart(2, '0')}-${String(clockInDate.getDate()).padStart(2, '0')} ${String(clockInDate.getHours()).padStart(2, '0')}:00` :
            `${clockInDate.getFullYear()}-${String(clockInDate.getMonth() + 1).padStart(2, '0')}-${String(clockInDate.getDate()).padStart(2, '0')}`;
          
          if (!grouped[periodKey]) {
            grouped[periodKey] = {
              actualHours: 0,
              scheduledHours: 0,
              laborCost: 0,
              staffCount: 0
            };
          }
          
          // Calculate actual hours worked
          const clockOut = timecard.clock_out ? new Date(timecard.clock_out) : new Date();
          const hoursWorked = Math.max(0, (clockOut - clockInDate) / (1000 * 60 * 60));
          
          grouped[periodKey].actualHours += hoursWorked;
          grouped[periodKey].laborCost += hoursWorked * 15; // Assume $15/hour average
          grouped[periodKey].staffCount += 1;
        }
      });
      
      // Process shifts (scheduled hours)
      shifts.forEach(shift => {
        if (shift.start_date) {
          const shiftDate = new Date(shift.start_date);
          const periodKey = granularity === 'hour' ? 
            `${shiftDate.getFullYear()}-${String(shiftDate.getMonth() + 1).padStart(2, '0')}-${String(shiftDate.getDate()).padStart(2, '0')} ${String(shiftDate.getHours()).padStart(2, '0')}:00` :
            `${shiftDate.getFullYear()}-${String(shiftDate.getMonth() + 1).padStart(2, '0')}-${String(shiftDate.getDate()).padStart(2, '0')}`;
          
          if (!grouped[periodKey]) {
            grouped[periodKey] = {
              actualHours: 0,
              scheduledHours: 0,
              laborCost: 0,
              staffCount: 0
            };
          }
          
          // Calculate scheduled hours
          const endDate = shift.end_date ? new Date(shift.end_date) : new Date(shiftDate.getTime() + 8 * 60 * 60 * 1000);
          const scheduledHours = Math.max(0, (endDate - shiftDate) / (1000 * 60 * 60));
          
          grouped[periodKey].scheduledHours += scheduledHours;
        }
      });
      
      return grouped;
    }

    // Combine Toast and Homebase data for comprehensive analytics
    function combineToastHomebaseData(salesData, laborData, period) {
      const labels = [];
      const revenueData = [];
      const ordersData = [];
      const laborHoursData = [];
      const laborEfficiencyData = [];
      
      // Get all unique time periods
      const allPeriods = new Set([...Object.keys(salesData), ...Object.keys(laborData)]);
      const sortedPeriods = Array.from(allPeriods).sort();
      
      sortedPeriods.forEach(periodKey => {
        const sales = salesData[periodKey] || { revenue: 0, orders: 0 };
        const labor = laborData[periodKey] || { actualHours: 0, scheduledHours: 0, laborCost: 0 };
        
        // Format label based on period
        const label = formatChartLabel(periodKey, period);
        labels.push(label);
        
        revenueData.push(sales.revenue);
        ordersData.push(sales.orders);
        laborHoursData.push(labor.actualHours);
        
        // Calculate labor efficiency (revenue per labor hour)
        const efficiency = labor.actualHours > 0 ? sales.revenue / labor.actualHours : 0;
        laborEfficiencyData.push(efficiency);
      });
      
      return {
        labels,
        datasets: {
          revenue: revenueData,
          orders: ordersData,
          laborHours: laborHoursData,
          efficiency: laborEfficiencyData
        }
      };
    }

    // Format chart label based on period
    function formatChartLabel(periodKey, period) {
      if (period === 'day') {
        // Hour format: "2025-09-30 14:00" -> "2:00 PM"
        const [datePart, timePart] = periodKey.split(' ');
        const hour = parseInt(timePart.split(':')[0]);
        return hour === 0 ? '12:00 AM' : 
               hour < 12 ? `${hour}:00 AM` : 
               hour === 12 ? '12:00 PM' : 
               `${hour - 12}:00 PM`;
      } else {
        // Day format: "2025-09-30" -> "Sep 30"
        const date = new Date(periodKey + 'T00:00:00');
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      }
    }

    // Create Chart.js sales chart with multi-axis support
    function createSalesChart(ctx, analytics) {
      return new Chart(ctx, {
        type: 'line',
        data: {
          labels: analytics.labels,
          datasets: [
            {
              label: 'Revenue ($)',
              data: analytics.datasets.revenue,
              borderColor: '#667eea',
              backgroundColor: 'rgba(102, 126, 234, 0.1)',
              fill: true,
              tension: 0.4,
              yAxisID: 'y'
            },
            {
              label: 'Orders',
              data: analytics.datasets.orders,
              borderColor: '#22c55e',
              backgroundColor: 'rgba(34, 197, 94, 0.1)',
              fill: false,
              tension: 0.4,
              yAxisID: 'y1'
            },
            {
              label: 'Labor Hours',
              data: analytics.datasets.laborHours,
              borderColor: '#f59e0b',
              backgroundColor: 'rgba(245, 158, 11, 0.1)',
              fill: false,
              tension: 0.4,
              yAxisID: 'y2'
            },
            {
              label: 'Efficiency ($/hr)',
              data: analytics.datasets.efficiency,
              borderColor: '#ef4444',
              backgroundColor: 'rgba(239, 68, 68, 0.1)',
              fill: false,
              tension: 0.4,
              yAxisID: 'y3'
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: `${currentPeriod === 'day' ? '24-Hour' : currentPeriod === 'week' ? '7-Day' : '30-Day'} Revenue vs Labor Analysis`
            },
            legend: {
              position: 'top'
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              callbacks: {
                label: function(context) {
                  const label = context.dataset.label || '';
                  if (label.includes('Revenue')) {
                    return `${label}: $${context.parsed.y.toFixed(2)}`;
                  } else if (label.includes('Efficiency')) {
                    return `${label}: $${context.parsed.y.toFixed(2)}/hr`;
                  } else if (label.includes('Hours')) {
                    return `${label}: ${context.parsed.y.toFixed(1)} hrs`;
                  } else {
                    return `${label}: ${context.parsed.y}`;
                  }
                }
              }
            }
          },
          scales: {
            x: {
              display: true,
              title: {
                display: true,
                text: currentPeriod === 'day' ? 'Hour' : 'Date'
              }
            },
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              title: {
                display: true,
                text: 'Revenue ($)'
              },
              grid: {
                color: 'rgba(102, 126, 234, 0.1)'
              }
            },
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              title: {
                display: true,
                text: 'Orders'
              },
              grid: {
                drawOnChartArea: false,
              },
              ticks: {
                color: '#22c55e'
              }
            },
            y2: {
              type: 'linear',
              display: false,
              position: 'right'
            },
            y3: {
              type: 'linear',
              display: false,
              position: 'right'
            }
          },
          interaction: {
            mode: 'nearest',
            axis: 'x',
            intersect: false
          }
        }
      });
    }

    async function loadRecentOrders() {
      console.log('üìã Loading Recent Orders...');
      
      try {
        // TODO: Implement recent orders with real Toast orders data
        const ordersHTML = `
          <div>
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid #f0f0f0;">
              <div>
                <div style="font-weight: 600; color: #333;">#1247 - John D.</div>
                <div style="font-size: 12px; color: #666;">Gyro Platter, Greek Fries</div>
              </div>
              <div style="text-align: right;">
                <div style="font-weight: 600;">$23.50</div>
                <div style="font-size: 11px; color: #22c55e; background: #f0fdf4; padding: 2px 6px; border-radius: 4px;">Ready</div>
              </div>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid #f0f0f0;">
              <div>
                <div style="font-weight: 600; color: #333;">#1248 - Sarah M.</div>
                <div style="font-size: 12px; color: #666;">Chicken Shawarma, Hummus</div>
              </div>
              <div style="text-align: right;">
                <div style="font-weight: 600;">$18.75</div>
                <div style="font-size: 11px; color: #f59e0b; background: #fffbeb; padding: 2px 6px; border-radius: 4px;">Preparing</div>
              </div>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0;">
              <div>
                <div style="font-weight: 600; color: #333;">#1249 - Mike R.</div>
                <div style="font-size: 12px; color: #666;">Falafel Bowl, Pita Bread</div>
              </div>
              <div style="text-align: right;">
                <div style="font-weight: 600;">$15.25</div>
                <div style="font-size: 11px; color: #3b82f6; background: #eff6ff; padding: 2px 6px; border-radius: 4px;">Ordered</div>
              </div>
            </div>
          </div>
        `;
        
        document.getElementById('recent-orders-list').innerHTML = ordersHTML;
        console.log('‚úÖ Recent Orders loaded');
        
      } catch (error) {
        console.error('‚ùå Error loading Recent Orders:', error);
        document.getElementById('recent-orders-list').innerHTML = '<div class="error">Failed to load recent orders</div>';
      }
    }

    // Chart period change
    function changePeriod(period) {
      currentPeriod = period;
      
      // Update button states
      document.querySelectorAll('.chart-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      // TODO: Reload chart with new period data
      console.log(`üìä Changing chart period to: ${period}`);
      loadSalesChart();
    }

    // Refresh functions
    function refreshLiveData() {
      loadLiveMetrics();
      updateStatusIndicator();
    }

    function refreshAllData() {
      console.log('üîÑ Refreshing all data...');
      Promise.all([
        loadLiveMetrics(),
        loadStatsCards(),
        loadTopItems(),
        loadSalesChart(),
        loadRecentOrders()
      ]).then(() => {
        console.log('‚úÖ All data refreshed');
      });
    }

    function updateStatusIndicator() {
      const now = new Date();
      const timeStr = now.toLocaleTimeString('en-US', { 
        hour: 'numeric', 
        minute: '2-digit', 
        second: '2-digit' 
      });
      document.getElementById('live-metrics-status').textContent = `Updated ${timeStr}`;
    }

    function showError(message) {
      console.error('‚ùå Manager Portal Error:', message);
      // You can implement a toast notification here
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', initManagerPortal);
  </script>
</body>
</html>